<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Valence/Arousal + 7 Emotions â€” Analyze â†’ XDF â†’ Playback</title>
  <style>
    body { background:#222; color:#fff; font-family:sans-serif; padding:1em; }
    .row { margin: 1em 0; }
    .muted { color: #888; margin-left: 1em; }
    button { margin-right: 0.5em; }
    canvas { box-shadow: 0 0 12px; }
    video { display:block; margin-bottom:8px; width:100%; max-width:720px; background:#000; }
    canvas { background:#333; max-width:100%; height:400px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; align-items:center; }
    button { padding:0.5em 1em; font-size:14px; border:0; border-radius:6px; background:#444; color:#fff; cursor:pointer; }
    button:hover { background:#555; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { opacity:.75; font-size:12px; }
    
    /* æ–°å¢æ§åˆ¶é¢æ¿æ ·å¼ */
    input[type="checkbox"] { transform: scale(1.2); margin-right: 3px; }
    input[type="number"] { padding: 4px 8px; border: 1px solid #666; border-radius: 4px; background: #222; color: #fff; }
    input[type="number"]:focus { border-color: #888; outline: none; }
    label { cursor: pointer; user-select: none; }
  </style>
</head>
<body>
  <h2>ğŸ¥ ç”Ÿç†æ•°æ®åˆ†æå›æ”¾</h2>

  <div class="row">
    <button id="selectVideoBtn">ğŸ“ é€‰æ‹©è§†é¢‘æ–‡ä»¶</button>
    <input id="videoInput" type="file" accept="video/*" style="display:none">
    <span id="videoInfo" class="muted">è¯·å…ˆé€‰æ‹©è§†é¢‘æ–‡ä»¶</span>
  </div>

  <div style="position: relative; display: inline-block;">
    <video id="video" controls crossorigin="anonymous" style="display:none;">
      <!-- è§†é¢‘æºå°†é€šè¿‡JavaScriptåŠ¨æ€è®¾ç½® -->
    </video>
    
    <!-- æ£€æµ‹åŒºåŸŸè¦†ç›–å±‚ -->
    <div id="regionOverlay" style="
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      border: 2px solid #ff0000;
      background: rgba(255,0,0,0.1);
      display: none;
      z-index: 10;
    "></div>
    
    <!-- æ‹–æ‹½æ§åˆ¶ç‚¹ -->
    <div id="dragHandle" style="
      position: absolute;
      width: 12px;
      height: 12px;
      background: #ff0000;
      border: 2px solid #fff;
      cursor: se-resize;
      display: none;
      z-index: 11;
    "></div>
  </div>

  <div class="row">
    <button id="analyzeBtn" disabled>â‘  Analyzeï¼ˆé¢„å¤„ç†ï¼‰</button>
    <button id="downloadBtn" disabled>â¬‡ï¸ å¯¼å‡º XDF</button>
    <button id="importBtn">ğŸ“‚ å¯¼å…¥ XDF å›æ”¾</button>
    <input id="xdfInput" type="file" accept=".xdf" style="display:none">
    <label for="frameInterval" style="margin-left: 20px;">æ¯Nå¸§æŠ½ä¸€å¸§:</label>
    <input id="frameInterval" type="number" min="1" max="300" value="10" style="width:60px;">
    <span id="status" class="muted"></span>
  </div>

  <div class="row">
    <button id="toggleRegion">å¯ç”¨åŒºåŸŸæ£€æµ‹</button>
    <span id="regionInfo" style="margin-left: 20px; color: #ccc;">ç‚¹å‡»å¯ç”¨åå¯åœ¨è§†é¢‘ä¸Šæ‹–æ‹½é€‰æ‹©æ£€æµ‹åŒºåŸŸ</span>
  </div>

  <div class="row" id="zoomRow">
    <label for="windowStart">èµ·ç‚¹æ—¶é—´ï¼š</label>
    <input id="windowStart" type="number" min="0" step="0.1" placeholder="ç§’" style="width:120px" value="0">
    <label for="windowEnd">ç»ˆç‚¹æ—¶é—´ï¼š</label>
    <input id="windowEnd" type="number" min="0" step="0.1" placeholder="ç§’" style="width:120px" value="30">
    <button id="applyWindow">åº”ç”¨</button>
  </div>

  <!-- æ•°æ®æ˜¾ç¤ºæ§åˆ¶é¢æ¿ -->
  <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin: 10px 0;">
    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
      
      <!-- æ£€æµ‹æ¨¡å¼æ§åˆ¶ -->
      <div style="display: flex; gap: 15px; align-items: center; border-right: 1px solid #555; padding-right: 15px;">
        <!-- API é€‰æ‹©å™¨ -->
        <div style="display: flex; gap: 10px; align-items: center; border-right: 1px solid #666; padding-right: 12px;">
          <label style="color: #ccc; font-size: 12px;">æƒ…ç»ªæ£€æµ‹API:</label>
          <select id="apiSelector" style="background: #444; color: #fff; border: 1px solid #666; border-radius: 4px; padding: 2px 6px; font-size: 12px;">
            <option value="morphcast">MorphCast (äº‘ç«¯)</option>
            <option value="deepface">DeepFace (æœ¬åœ°)</option>
          </select>
          <span id="apiStatus" style="font-size: 11px; color: #888;">çŠ¶æ€: æœªè¿æ¥</span>
        </div>
        
        <label style="display: flex; align-items: center; gap: 5px; color: #ccc;">
          <input type="checkbox" id="emotionToggle" checked>
          <span>å¯ç”¨7ç±»æƒ…ç»ªæ£€æµ‹</span>
        </label>
      </div>
    </div>
    
    <!-- çŠ¶æ€æ˜¾ç¤º -->
    <div style="margin-top: 8px; font-size: 12px; color: #888;">
      <span id="dataProcessingStatus">æ•°æ®å¤„ç†çŠ¶æ€ï¼šæ­£å¸¸æ˜¾ç¤º</span>
    </div>
  </div>

  <!-- ç”Ÿç†ä¿¡å·æ•°æ®å¯¼å…¥åŒºåŸŸ -->
  <div class="row" style="margin-top: 10px; padding: 15px; border: 1px solid #444; border-radius: 5px;">
    <h3 style="color: #ccc; margin: 0 0 10px 0;">ğŸ“Š ç”Ÿç†ä¿¡å·æ•°æ®å¯¼å…¥</h3>
    
    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
      <!-- æ–‡ä»¶å¯¼å…¥ -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">å¯¼å…¥ç”Ÿç†ä¿¡å·æ•°æ®</label>
        <input type="file" id="physioFileInput" accept=".csv,.xdf,.json" style="color: #ccc; background: #333; border: 1px solid #555; padding: 5px; border-radius: 3px;">
      </div>
      
      <!-- é‡‡æ ·é…ç½® -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">æ•°æ®é‡‡æ ·</label>
        <div style="display: flex; gap: 5px; align-items: center;">
          <label style="color: #aaa; font-size: 11px;">æœ€å¤§ç‚¹æ•°:</label>
          <input type="number" id="maxDataPoints" value="20000" min="100" max="50000" step="100" style="width: 80px; padding: 2px 4px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px; font-size: 11px;">
        </div>
      </div>
      
      <!-- æ•°æ®çŠ¶æ€ -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">æ•°æ®çŠ¶æ€</label>
        <span id="physiologicalStatus" style="color: #888; font-size: 12px;">æœªå¯¼å…¥æ•°æ®</span>
      </div>
      
      <!-- è½¬æ¢å¯¼å‡º -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">æ•°æ®å¤„ç†</label>
        <button id="convertToXdfBtn" disabled style="padding: 6px 12px; font-size: 12px; background: #4caf50; border: none; border-radius: 4px; color: white; cursor: pointer;">è½¬æ¢å¹¶å¯¼å‡ºXDF</button>
      </div>
      
      <!-- å¼‚å¸¸æ ‡è®°çŠ¶æ€ -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <span id="anomalyMarkingStatus" style="color: #4caf50; font-size: 12px; font-weight: bold;">ğŸ¯ Ctrl+ç‚¹å‡»VAå›¾è¡¨æ ‡è®°å¼‚å¸¸ç‚¹ (0ä¸ªæ ‡è®°)</span>
      </div>
    </div>
  </div>

  <canvas id="chart" style="width: 100%; max-width: 100%;"></canvas>
  
  <!-- Rate-of-Change æ•°æ®åå¤„ç†æ§åˆ¶é¢æ¿ -->
  <div id="rocProcessingPanel" style="display: none; margin-top: 20px; background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #444;">
    <h3 style="color: #fff; margin-bottom: 15px;">ğŸ“Š Rate-of-Change æ•°æ®åå¤„ç†æµç¨‹</h3>
    
    <!-- æ­¥éª¤0: åŸºç¡€æ•´ç† -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">0ï¸âƒ£ åŸºç¡€æ•´ç†</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="sortDataBtn">æ—¶é—´å¯¹é½/å»é‡</button>
        <button id="resampleBtn">é‡é‡‡æ ·(5Hz)</button>
        <button id="resample50HzBtn">é‡é‡‡æ ·(50Hz)</button>
        <span id="step0Status" class="muted">æœªå¤„ç†</span>
      </div>
    </div>

    <!-- æ­¥éª¤0.5: NeuroKit GSRé¢„å¤„ç† -->
    <div class="row" style="background: #2d5016; padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px solid #4caf50;">
      <h4 style="color: #4caf50; margin: 0 0 10px 0;">ğŸ§  NeuroKit GSRé¢„å¤„ç†</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <select id="neurokitMethod" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
          <option value="neurokit">NeuroKit2å®˜æ–¹</option>
          <option value="biosppy">BioSPPyå…¼å®¹</option>
          <option value="cvxeda">cvxEDAåˆ†è§£</option>
          <option value="none">è·³è¿‡é¢„å¤„ç†</option>
        </select>
        <button id="neurokitProcessBtn" style="background: #4caf50; color: #fff;">NeuroKitå¤„ç†GSR</button>
        <span id="neurokitStatus" class="muted">æœªå¤„ç†</span>
        <div id="neurokitProgress" style="display: none; color: #4caf50; font-size: 12px;"></div>
      </div>
    </div>
    
    <!-- å¼‚å¸¸æ£€æµ‹åŒºåŸŸ -->
    <div class="row" style="margin-top: 15px; padding: 15px; border: 1px solid #6366f1; border-radius: 5px; background: #1a1a2e;">
      <h3 style="color: #a78bfa; margin: 0 0 15px 0;">ğŸ¤– æœºå™¨å­¦ä¹ å¼‚å¸¸æ£€æµ‹ (Isolation Forest)</h3>
      
      <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 10px;">
        <!-- æ•°æ®æºé€‰æ‹© -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">æ•°æ®æº</label>
          <select id="anomalyDataSource" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
            <option value="gsr">çš®ç”µæ•°æ® (GSR)</option>
            <option value="valence">æ•ˆä»·æ•°æ® (Valence)</option>
            <option value="combined">ğŸ”— è”åˆæ•°æ® (GSR + Valence)</option>
          </select>
        </div>
        
        <!-- æ±¡æŸ“ç‡è®¾ç½® -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">å¼‚å¸¸æ¯”ä¾‹</label>
          <select id="contaminationRate" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
            <option value="0.05">5% (ä¸¥æ ¼)</option>
            <option value="0.10" selected>10% (æ ‡å‡†)</option>
            <option value="0.15">15% (å®½æ¾)</option>
            <option value="0.20">20% (éå¸¸å®½æ¾)</option>
          </select>
        </div>
        
        <!-- åŒºé—´æ£€æµ‹å‚æ•° -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">ğŸ”¶ åŒºé—´å‚æ•°</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">æœ€å¤§é—´éš”:</label>
            <input id="maxGapParam" type="number" value="2.0" min="0.1" max="10" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">ç§’</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">æœ€å°æ—¶é•¿:</label>
            <input id="minDurationParam" type="number" value="1.0" min="0.1" max="30" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">ç§’</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">å‰å‘åç§»:</label>
            <input id="forwardOffsetParam" type="number" value="0.0" min="0.0" max="1.0" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">æ¯”ä¾‹</span>
          </div>
        </div>
        
        <!-- æ“ä½œæŒ‰é’® -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">æ“ä½œ</label>
          <button id="runAnomalyDetectionBtn" style="padding: 6px 12px; font-size: 12px; background: #6366f1; border: none; border-radius: 4px; color: white;">è¿è¡Œæ£€æµ‹</button>
        </div>
        
        <!-- æ˜¾ç¤ºæ§åˆ¶ -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">æ˜¾ç¤º</label>
          <button id="toggleAnomalyDisplay" disabled style="padding: 6px 12px; font-size: 12px; background: #ef4444; border: none; border-radius: 4px; color: white;">æ˜¾ç¤ºå¼‚å¸¸ç‚¹</button>
          <button id="toggleIntervalDisplay" disabled style="padding: 6px 12px; font-size: 12px; background: #8b5cf6; border: none; border-radius: 4px; color: white;">ğŸ”¶ æ˜¾ç¤ºå¼‚å¸¸åŒºé—´</button>
          <button id="recalculateIntervals" disabled style="padding: 6px 12px; font-size: 12px; background: #f59e0b; border: none; border-radius: 4px; color: white;">ğŸ”„ é‡æ–°è®¡ç®—åŒºé—´</button>
        </div>
      </div>
      
      <!-- çŠ¶æ€å’Œè¿›åº¦ -->
      <div id="anomalyDetectionStatus" style="margin-top: 8px; font-size: 12px; color: #888;">
        æœªè¿è¡Œæ£€æµ‹
      </div>
      
      <!-- æ£€æµ‹ç»“æœ -->
      <div id="anomalyDetectionResults" style="display: none; margin-top: 10px; padding: 8px; background: rgba(99, 102, 241, 0.1); border-radius: 4px;">
        <div style="color: #a78bfa; font-size: 12px;">
          æ£€æµ‹å®Œæˆï¼š<span id="anomalyCount">0</span> ä¸ªå¼‚å¸¸ç‚¹ / <span id="totalPoints">0</span> ä¸ªæ•°æ®ç‚¹ 
          (<span id="anomalyPercentage">0%</span>)
        </div>
      </div>
    </div>
    
    <!-- æ­¥éª¤1: å»ä¼ªè¿¹/å»å°–å³° -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">1ï¸âƒ£ å»ä¼ªè¿¹/å»å°–å³°</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">ä¸­å€¼æ»¤æ³¢çª—å£:</label>
        <input id="medianWindow" type="number" min="3" max="15" step="2" value="5" style="width:60px;">
        <button id="medianFilterBtn">åº”ç”¨ä¸­å€¼æ»¤æ³¢</button>
        <button id="outlierClipBtn">å¼‚å¸¸å€¼æˆªæ–­</button>
        <span id="step1Status" class="muted">æœªå¤„ç†</span>
      </div>
    </div>
    
    <!-- æ­¥éª¤2: åŸºçº¿ä¸å°ºåº¦ -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">2ï¸âƒ£ åŸºçº¿ä¸å°ºåº¦æ ‡å‡†åŒ–</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="zeroMeanBtn">é›¶å‡å€¼åŒ–</button>
        <button id="zeroScaleBtn">å½’é›¶ç¼©æ”¾</button>
        <button id="zScoreBtn">Z-Scoreæ ‡å‡†åŒ–</button>
        
        <!-- æ–°å¢ï¼šæ—¶é—´å¯¹é½åŠŸèƒ½ -->
        <div style="display: flex; gap: 5px; align-items: center; margin-left: 15px; border-left: 1px solid #555; padding-left: 15px;">
          <label style="color: #ccc; font-size: 12px;">æ—¶é—´å¯¹é½:</label>
          <button id="alignDataBtn" style="padding: 4px 8px; font-size: 12px; background: #2196f3; border: none; border-radius: 3px; color: white;">äº’ç›¸å…³å¯¹é½VA-GSR</button>
        </div>
        
        <span id="step2Status" class="muted">æœªå¤„ç†</span>
      </div>
      
      <!-- å¯¹é½è¯¦ç»†å‚æ•°æ§åˆ¶ -->
      <div id="alignmentControls" style="margin-top: 8px; padding: 8px; background: #2a2a2a; border-radius: 4px;">
        <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
          <div style="display: flex; gap: 5px; align-items: center;">
            <label style="color: #ccc; font-size: 11px;">æœ€å¤§å»¶è¿Ÿ:</label>
            <input id="maxLagSeconds" type="number" min="0" max="30" step="0.1" value="5.0" style="width: 60px; padding: 2px 4px; background: #444; color: #fff; border: 1px solid #666; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">ç§’</span>
          </div>
          
          <button id="showAlignmentDetails" style="padding: 3px 6px; font-size: 11px; background: #666; border: none; border-radius: 3px; color: white;">è¯¦ç»†åˆ†æ</button>
        </div>
      </div>
    </div>
    
    <!-- æ­¥éª¤3: å¯¼æ•°è®¡ç®— -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">3ï¸âƒ£ å˜åŒ–ç‡è®¡ç®—</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">SGçª—å£:</label>
        <input id="sgWindow" type="number" min="7" max="31" step="2" value="15" style="width:60px;">
        <button id="sgDerivativeBtn">SGå¯¼æ•°</button>
        <label style="color: #ccc;">æ–œç‡çª—å£:</label>
        <input id="slopeWindow" type="number" min="5" max="21" step="2" value="9" style="width:60px;">
        <button id="slopeDerivativeBtn">é²æ£’æ–œç‡</button>
        <span id="step3Status" class="muted">æœªå¤„ç†</span>
      </div>
    </div>
    
    <!-- æ­¥éª¤4: å¯¼æ•°åå¤„ç† -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">4ï¸âƒ£ å¯¼æ•°åå¤„ç†</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="smoothDerivativeBtn">å¯¼æ•°å¹³æ»‘(3ç‚¹)</button>
        <button id="normalizeDerivativeBtn">å¯¼æ•°æ ‡å‡†åŒ–</button>
        <span id="step4Status" class="muted">æœªå¤„ç†</span>
      </div>
    </div>
    
    <!-- æ­¥éª¤5: äº‹ä»¶åˆ¤å®š -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">5ï¸âƒ£ äº‹ä»¶åˆ¤å®š</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">ä¸Šå‡é˜ˆå€¼:</label>
        <input id="upThreshold" type="number" min="-2" max="2" step="0.01" value="0.12" style="width:80px;">
        <label style="color: #ccc;">ä¸‹é™é˜ˆå€¼:</label>
        <input id="downThreshold" type="number" min="-2" max="2" step="0.01" value="-0.12" style="width:80px;">
        <label style="color: #ccc;">æœ€å°æŒç»­(s):</label>
        <input id="minDuration" type="number" min="0.1" max="5" step="0.1" value="0.8" style="width:80px;">
        <button id="detectEventsBtn">æ£€æµ‹äº‹ä»¶</button>
        <button id="showEventsBtn" style="display:none;">æ˜¾ç¤ºäº‹ä»¶æ ‡è®°</button>
        <span id="step5Status" class="muted">æœªå¤„ç†</span>
      </div>
    </div>

    <!-- æ§åˆ¶æŒ‰é’® -->
    <div class="row" style="border-top: 1px solid #555; padding-top: 10px;">
      <button id="resetProcessingBtn" style="background: #d32f2f;">é‡ç½®æ‰€æœ‰å¤„ç†</button>
      <button id="showDerivativeBtn">æ˜¾ç¤º/éšè—å¯¼æ•°æ›²çº¿</button>
      <button id="exportProcessedBtn">å¯¼å‡ºå¤„ç†åæ•°æ®</button>
      <span id="processingStatus" style="color: #4caf50; margin-left: 20px;">å°±ç»ª</span>
    </div>
  
  <!-- 7ç±»æƒ…ç»ªæ˜¾ç¤ºåŒºåŸŸ -->
  <div id="emotionChartContainer" style="margin-top: 20px;">
    <h3 style="color: #fff; margin-bottom: 10px;">ğŸ­ 7ç±»æƒ…ç»ªæ¦‚ç‡åˆ†å¸ƒ</h3>
    <canvas id="emotionChart" style="background:#333; max-width:100%; height:300px;"></canvas>
    
    <!-- å½“å‰æ—¶é—´ç‚¹çš„æƒ…ç»ªè¯¦æƒ… -->
    <div id="currentEmotionDetails" style="margin-top: 10px; padding: 10px; background: #333; border-radius: 5px;">
      <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
        <span id="currentEmotionDisplay" style="color: #fff; font-size: 16px; font-weight: bold;">--</span>
      </div>
    </div>
  </div>

  <!-- SDK + Chart.js + Numeric.js -->
  <script src="https://ai-sdk.morphcast.com/v1.16/ai-sdk.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

  <script type="module">
    import { VAChart } from './va-chart.js';

    // æ–¹å¼Cï¼šåœ¨æ­¤å†™æ­» MorphCast License Keyï¼ˆä¼˜å…ˆä½¿ç”¨ï¼‰ã€‚ç•™ç©ºåˆ™æŒ‰ URL/localStorage è¯»å–ã€‚
    const LICENSE_KEY = 'skb80c78744414c9ff1cfb03e980a675a55b6eea31e6cd';

    // EDAä¿¡å·é¢„å¤„ç†ç±» - åŸºäºNeuroKitæ–¹æ³•
    class EDAPreprocessor {
      constructor() {
        this.apiUrl = 'http://localhost:8080'; // DeepFace APIåœ°å€ (åŒ…å«EDAå¤„ç†åŠŸèƒ½)
        this.methods = {
          'neurokit': 'NeuroKit2å®˜æ–¹æ–¹æ³•',
          'biosppy': 'BioSPPyå…¼å®¹æ–¹æ³•', 
          'cvxeda': 'cvxEDAåˆ†è§£æ–¹æ³•',
          'none': 'æ— é¢„å¤„ç†'
        };
        this.fallbackEnabled = true; // å¯ç”¨å¤‡ç”¨æ–¹æ³•
      }

      // ä¸»è¦çš„EDAæ¸…ç†å‡½æ•° - é€šè¿‡APIè°ƒç”¨
      async clean(edaSignal, samplingRate = 50, method = 'neurokit', progressCallback = null) {
        console.log(`EDAé¢„å¤„ç†å¼€å§‹: ${edaSignal.length}ä¸ªæ•°æ®ç‚¹, é‡‡æ ·ç‡=${samplingRate}Hz, æ–¹æ³•=${method}`);
        
        if (method === 'none') {
          if (progressCallback) progressCallback({ progress: 100, message: 'è·³è¿‡é¢„å¤„ç†' });
          return [...edaSignal];
        }

        try {
          // å°è¯•è°ƒç”¨Python API
          if (progressCallback) progressCallback({ progress: 10, message: 'è¿æ¥NeuroKit2 API...' });
          
          const response = await fetch(`${this.apiUrl}/eda/clean`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              signal: edaSignal,
              sampling_rate: samplingRate,
              method: method
            }),
            timeout: 30000 // 30ç§’è¶…æ—¶
          });

          if (progressCallback) progressCallback({ progress: 50, message: 'NeuroKit2å¤„ç†ä¸­...' });

          if (!response.ok) {
            throw new Error(`APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            if (progressCallback) progressCallback({ progress: 90, message: 'NeuroKit2å¤„ç†å®Œæˆ' });
            
            console.log(`NeuroKit2é¢„å¤„ç†å®Œæˆ:`, result.data);
            console.log(`è´¨é‡è¯„åˆ†: ${result.data.quality_score}`);
            console.log(`ä½¿ç”¨æ–¹æ³•: ${result.data.method_used}`);
            
            if (progressCallback) progressCallback({ progress: 100, message: `å®˜æ–¹${result.data.method_used}é¢„å¤„ç†å®Œæˆ` });
            return result.data.cleaned_signal;
          } else {
            throw new Error(result.error || 'APIè¿”å›é”™è¯¯çŠ¶æ€');
          }

        } catch (error) {
          console.warn(`NeuroKit2 APIè°ƒç”¨å¤±è´¥: ${error.message}, ä½¿ç”¨å¤‡ç”¨æ–¹æ³•`);
          
          if (this.fallbackEnabled) {
            if (progressCallback) progressCallback({ progress: 60, message: 'APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨é¢„å¤„ç†...' });
            return await this.fallbackClean(edaSignal, samplingRate, method, progressCallback);
          } else {
            throw error;
          }
        }
      }

      // EDAä¿¡å·åˆ†è§£ - é€šè¿‡APIè°ƒç”¨
      async decompose(edaSignal, samplingRate = 50, progressCallback = null) {
        try {
          if (progressCallback) progressCallback({ progress: 10, message: 'è¿æ¥åˆ†è§£API...' });
          
          const response = await fetch(`${this.apiUrl}/eda/decompose`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              signal: edaSignal,
              sampling_rate: samplingRate
            }),
            timeout: 30000
          });

          if (progressCallback) progressCallback({ progress: 70, message: 'NeuroKit2åˆ†è§£ä¸­...' });

          if (!response.ok) {
            throw new Error(`åˆ†è§£APIè°ƒç”¨å¤±è´¥: ${response.status}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            if (progressCallback) progressCallback({ progress: 100, message: 'NeuroKit2åˆ†è§£å®Œæˆ' });
            console.log(`EDAä¿¡å·åˆ†è§£å®Œæˆ:`, result.data);
            return result.data;
          } else {
            throw new Error(result.error || 'åˆ†è§£APIè¿”å›é”™è¯¯');
          }

        } catch (error) {
          console.warn(`åˆ†è§£APIè°ƒç”¨å¤±è´¥: ${error.message}`);
          if (progressCallback) progressCallback({ progress: 100, message: 'åˆ†è§£å¤±è´¥' });
          throw error;
        }
      }

      // æ£€æŸ¥APIå¯ç”¨æ€§
      async checkApiStatus() {
        try {
          const response = await fetch(`${this.apiUrl}/eda/info`, {
            method: 'GET',
            timeout: 5000
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('EDA APIçŠ¶æ€:', result);
            return result;
          } else {
            throw new Error(`APIçŠ¶æ€æ£€æŸ¥å¤±è´¥: ${response.status}`);
          }
        } catch (error) {
          console.warn(`NeuroKit2 APIä¸å¯ç”¨: ${error.message}`);
          return { neurokit_available: false, error: error.message };
        }
      }

      // å¤‡ç”¨çš„æœ¬åœ°é¢„å¤„ç†æ–¹æ³•
      async fallbackClean(edaSignal, samplingRate, method, progressCallback) {
        console.log('ä½¿ç”¨å¤‡ç”¨é¢„å¤„ç†æ–¹æ³•ï¼ˆéå®˜æ–¹NeuroKit2ï¼‰');
        
        let cleanedSignal = [...edaSignal];
        
        try {
          // æ­¥éª¤1: å»é™¤æ˜æ˜¾å¼‚å¸¸å€¼
          if (progressCallback) progressCallback({ progress: 70, message: 'å¤‡ç”¨æ–¹æ³•: å»é™¤å¼‚å¸¸å€¼...' });
          cleanedSignal = this.removeOutliers(cleanedSignal);
          
          // æ­¥éª¤2: ä¸­å€¼æ»¤æ³¢
          if (progressCallback) progressCallback({ progress: 80, message: 'å¤‡ç”¨æ–¹æ³•: ä¸­å€¼æ»¤æ³¢...' });
          cleanedSignal = this.medianFilter(cleanedSignal, 5);
          
          // æ­¥éª¤3: ç®€å•ä½é€šæ»¤æ³¢
          if (progressCallback) progressCallback({ progress: 90, message: 'å¤‡ç”¨æ–¹æ³•: ä½é€šæ»¤æ³¢...' });
          cleanedSignal = this.simpleMovingAverage(cleanedSignal, Math.max(3, Math.floor(samplingRate * 0.1)));
          
          if (progressCallback) progressCallback({ progress: 100, message: `å¤‡ç”¨é¢„å¤„ç†å®Œæˆ (${method})` });
          
          console.log(`å¤‡ç”¨é¢„å¤„ç†å®Œæˆ: ${cleanedSignal.length}ä¸ªæ•°æ®ç‚¹`);
          return cleanedSignal;
          
        } catch (error) {
          console.error('å¤‡ç”¨é¢„å¤„ç†ä¹Ÿå¤±è´¥:', error);
          if (progressCallback) progressCallback({ progress: 100, message: 'é¢„å¤„ç†å¤±è´¥' });
          return edaSignal; // è¿”å›åŸå§‹ä¿¡å·
        }
      }

      // å¤‡ç”¨æ–¹æ³•ï¼šå»é™¤å¼‚å¸¸å€¼
      removeOutliers(data, threshold = 3) {
        const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
        const std = Math.sqrt(data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length);
        
        return data.map(val => {
          if (Math.abs(val - mean) > threshold * std) {
            return mean; // ç”¨å‡å€¼æ›¿æ¢å¼‚å¸¸å€¼
          }
          return val;
        });
      }

      // å¤‡ç”¨æ–¹æ³•ï¼šä¸­å€¼æ»¤æ³¢
      medianFilter(data, windowSize = 5) {
        const filtered = [];
        const halfWindow = Math.floor(windowSize / 2);
        
        for (let i = 0; i < data.length; i++) {
          const window = [];
          
          const start = Math.max(0, i - halfWindow);
          const end = Math.min(data.length - 1, i + halfWindow);
          
          for (let j = start; j <= end; j++) {
            window.push(data[j]);
          }
          
          window.sort((a, b) => a - b);
          filtered[i] = window[Math.floor(window.length / 2)];
        }
        
        return filtered;
      }

      // å¤‡ç”¨æ–¹æ³•ï¼šç®€å•ç§»åŠ¨å¹³å‡
      simpleMovingAverage(data, windowSize = 5) {
        const smoothed = [];
        const halfWindow = Math.floor(windowSize / 2);
        
        for (let i = 0; i < data.length; i++) {
          let sum = 0;
          let count = 0;
          
          const start = Math.max(0, i - halfWindow);
          const end = Math.min(data.length - 1, i + halfWindow);
          
          for (let j = start; j <= end; j++) {
            sum += data[j];
            count++;
          }
          
          smoothed[i] = sum / count;
        }
        
        return smoothed;
      }
    }

    const video = document.getElementById('video');
    const selectVideoBtn = document.getElementById('selectVideoBtn');
    const videoInput = document.getElementById('videoInput');
    const videoInfo = document.getElementById('videoInfo');
    const chartCanvas = document.getElementById('chart');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const importBtn = document.getElementById('importBtn');
    const xdfInput = document.getElementById('xdfInput');
    const frameIntervalInput = document.getElementById('frameInterval');
    const statusEl = document.getElementById('status');

    // ===== å¼‚å¸¸æ ‡è®°åŠŸèƒ½ =====
    let manualAnomalyMarks = [];

    // æ·»åŠ å¼‚å¸¸æ ‡è®°
    function addAnomalyMark(time, valence) {
      console.log(`ğŸ¯ å°è¯•æ·»åŠ å¼‚å¸¸æ ‡è®°: æ—¶é—´=${time.toFixed(3)}s, valence=${valence.toFixed(3)}`);
      console.log(`ğŸ“Š å½“å‰å·²æœ‰æ ‡è®°æ•°é‡: ${manualAnomalyMarks.length}`);
      
      const existingIndex = manualAnomalyMarks.findIndex(mark => 
        Math.abs(mark.time - time) < 0.1
      );
      
      if (existingIndex === -1) {
        const newMark = {
          time: time,
          valence: valence,
          marked: true,
          markTime: Date.now()
        };
        
        manualAnomalyMarks.push(newMark);
        console.log(`âœ… æˆåŠŸæ·»åŠ å¼‚å¸¸æ ‡è®°:`, newMark);
        console.log(`ğŸ“ˆ æ–°çš„æ ‡è®°æ€»æ•°: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
      } else {
        console.log(`âš ï¸ æ—¶é—´ ${time.toFixed(3)}s å·²æœ‰å¼‚å¸¸æ ‡è®°ï¼Œè·³è¿‡æ·»åŠ `);
        console.log(`ğŸ” ç°æœ‰æ ‡è®°:`, manualAnomalyMarks[existingIndex]);
      }
    }

    // ç§»é™¤å¼‚å¸¸æ ‡è®°
    function removeAnomalyMark(time) {
      console.log(`ğŸ—‘ï¸ å°è¯•ç§»é™¤å¼‚å¸¸æ ‡è®°: æ—¶é—´=${time.toFixed(3)}s`);
      console.log(`ğŸ“Š ç§»é™¤å‰æ ‡è®°æ•°é‡: ${manualAnomalyMarks.length}`);
      console.log(`ğŸ“‹ å½“å‰æ‰€æœ‰æ ‡è®°çš„æ—¶é—´:`, manualAnomalyMarks.map(mark => mark.time.toFixed(3)));
      
      // å¯»æ‰¾åŒ¹é…çš„æ ‡è®°
      let bestMatch = null;
      let bestDistance = Infinity;
      let bestIndex = -1;
      
      manualAnomalyMarks.forEach((mark, index) => {
        const distance = Math.abs(mark.time - time);
        console.log(`ğŸ” æ£€æŸ¥æ ‡è®°${index}: æ—¶é—´=${mark.time.toFixed(3)}s, è·ç¦»=${distance.toFixed(3)}s`);
        
        if (distance < bestDistance) {
          bestDistance = distance;
          bestMatch = mark;
          bestIndex = index;
        }
      });
      
      console.log(`ğŸ¯ æœ€ä½³åŒ¹é…: ç´¢å¼•=${bestIndex}, è·ç¦»=${bestDistance.toFixed(3)}s, é˜ˆå€¼=0.1s`);
      
      if (bestIndex !== -1 && bestDistance < 0.1) {
        const removed = manualAnomalyMarks.splice(bestIndex, 1)[0];
        console.log(`âœ… æˆåŠŸç§»é™¤å¼‚å¸¸æ ‡è®°:`, removed);
        console.log(`ğŸ“‰ æ–°çš„æ ‡è®°æ€»æ•°: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
        return true;
      } else if (bestIndex !== -1 && bestDistance < 2.0) {
        // å¦‚æœåœ¨2ç§’èŒƒå›´å†…æœ‰æ ‡è®°ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦è¦ç§»é™¤
        const removed = manualAnomalyMarks.splice(bestIndex, 1)[0];
        console.log(`âš ï¸ æ‰©å¤§èŒƒå›´ç§»é™¤å¼‚å¸¸æ ‡è®° (è·ç¦»${bestDistance.toFixed(3)}s):`, removed);
        console.log(`ğŸ“‰ æ–°çš„æ ‡è®°æ€»æ•°: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
        return true;
      } else {
        console.log(`âŒ æœªæ‰¾åˆ°å¯ç§»é™¤çš„æ ‡è®°: æœ€ä½³è·ç¦»${bestDistance.toFixed(3)}s > é˜ˆå€¼2.0s`);
        console.log(`ğŸ’¡ æç¤º: è¯·ç‚¹å‡»æ›´æ¥è¿‘ç°æœ‰å¼‚å¸¸æ ‡è®°çš„ä½ç½®`);
        return false;
      }
    }

    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    function updateAnomalyMarkingStatus() {
      const status = document.getElementById('anomalyMarkingStatus');
      const count = manualAnomalyMarks.length;
      
      status.textContent = `ğŸ¯ Ctrl+ç‚¹å‡»VAå›¾è¡¨æ ‡è®°å¼‚å¸¸ç‚¹ (${count}ä¸ªæ ‡è®°)`;
      status.style.color = count > 0 ? '#4caf50' : '#888';
      
      console.log(`ğŸ“Š å¼‚å¸¸æ ‡è®°çŠ¶æ€æ›´æ–°: ${count}ä¸ªæ ‡è®°`);
      
      // æ£€æŸ¥æ˜¯å¦åº”è¯¥å¯ç”¨XDFå¯¼å‡ºæŒ‰é’®
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
    }

    // æ›´æ–°XDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€
    function updateXDFExportButtonState() {
      const hasGSR = physiologicalData.gsr && physiologicalData.gsr.length > 0;
      const hasPPG = physiologicalData.ppg && physiologicalData.ppg.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      const hasEmotionData = dataLog && dataLog.some(record => record.face && isFinite(record.valence));
      
      const shouldEnable = hasGSR || hasPPG || hasAnomalies || hasEmotionData;
      
      const btnElement = document.getElementById('convertToXdfBtn');
      if (btnElement) {
        btnElement.disabled = !shouldEnable;
        
        console.log(`ğŸ”„ XDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€æ›´æ–°:`, {
          å¯ç”¨: shouldEnable,
          GSRæ•°æ®: hasGSR,
          PPGæ•°æ®: hasPPG,
          å¼‚å¸¸æ ‡è®°: hasAnomalies,
          æƒ…ç»ªæ•°æ®: hasEmotionData
        });
      }
    }

    // æ›´æ–°æƒ…ç»ªæ•°æ®XDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€
    function updateEmotionXDFExportButtonState() {
      const hasEmotionData = dataLog && dataLog.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      
      const shouldEnable = hasEmotionData || hasAnomalies;
      
      const btnElement = document.getElementById('downloadBtn');
      if (btnElement) {
        btnElement.disabled = !shouldEnable;
        
        console.log(`ğŸ”„ æƒ…ç»ªXDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€æ›´æ–°:`, {
          å¯ç”¨: shouldEnable,
          æƒ…ç»ªæ•°æ®: hasEmotionData,
          å¼‚å¸¸æ ‡è®°: hasAnomalies
        });
      }
    }

    // æ›´æ–°å›¾è¡¨ä¸­çš„å¼‚å¸¸æ ‡è®°æ˜¾ç¤º
    function updateChartAnomalyMarks() {
      console.log(`ğŸ”„ æ›´æ–°å›¾è¡¨å¼‚å¸¸æ ‡è®°æ˜¾ç¤º, æ ‡è®°æ•°é‡: ${manualAnomalyMarks.length}`);
      console.log(`ğŸ“‹ å½“å‰å¼‚å¸¸æ ‡è®°åˆ—è¡¨:`, manualAnomalyMarks);
      
      if (typeof chart !== 'undefined') {
        console.log(`âœ… chartå¯¹è±¡å­˜åœ¨, ç±»å‹: ${typeof chart}`);
        
        if (chart.updateAnomalyMarks) {
          console.log(`âœ… chart.updateAnomalyMarksæ–¹æ³•å­˜åœ¨ï¼Œè°ƒç”¨æ›´æ–°`);
          chart.updateAnomalyMarks(manualAnomalyMarks);
        } else {
          console.log(`âŒ chart.updateAnomalyMarksæ–¹æ³•ä¸å­˜åœ¨`);
          console.log(`ğŸ” chartå¯¹è±¡å¯ç”¨æ–¹æ³•:`, Object.getOwnPropertyNames(chart));
        }
      } else {
        console.log(`âŒ chartå¯¹è±¡æœªå®šä¹‰`);
      }
    }

    // éšè—æŠ“å¸§ç”»å¸ƒï¼ˆåˆ†æé˜¶æ®µç”¨ï¼‰
    const grabCanvas = document.createElement('canvas');
    const grabCtx = grabCanvas.getContext('2d', { willReadFrequently: true });

    const chart = new VAChart(chartCanvas);
    
    // æš´éœ²chartå®ä¾‹ä¸ºå…¨å±€å˜é‡
    window.chart = chart;

    // æƒ…ç»ªæ£€æµ‹çŠ¶æ€
    let emotionDetectionEnabled = true; // æ˜¯å¦å¯ç”¨æƒ…ç»ªæ£€æµ‹
    let emotionChart = null; // æƒ…ç»ªå›¾è¡¨å®ä¾‹
    const emotionNames = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise'];
    const emotionColors = ['#ff6b6b', '#8b5cf6', '#06b6d4', '#10b981', '#6b7280', '#3b82f6', '#f59e0b'];

    // API ç®¡ç†
    let currentAPI = 'morphcast'; // å½“å‰ä½¿ç”¨çš„API: 'morphcast' æˆ– 'deepface'
    let deepfaceApiUrl = 'http://localhost:8080'; // DeepFace API åœ°å€ (ç‹¬ç«‹ç«¯å£)
    let apiConnected = false; // API è¿æ¥çŠ¶æ€

    // ç”Ÿç†ä¿¡å·æ•°æ®å­˜å‚¨
    let physiologicalData = {
      gsr: [],
      ppg: [],
      startTime: null
    };

    // å¼‚å¸¸æ£€æµ‹ç›¸å…³
    let anomalyDetectionResults = null;
    let showingAnomalies = false;

    // æ—¶é—´å¯¹é½å¤„ç†å™¨ç±»
    class TimeAlignmentProcessor {
      constructor() {
        this.alignmentResults = null;
      }

      // äº’ç›¸å…³å¯¹é½æ–¹æ³•
      async alignData(valenceData, gsrData, options = {}) {
        const config = {
          maxLagSeconds: options.maxLagSeconds || 5.0,
          ...options
        };

        console.log(`ğŸ”„ å¼€å§‹äº’ç›¸å…³æ—¶é—´å¯¹é½, é…ç½®:`, config);
        console.log(`ğŸ“Š è¾“å…¥æ•°æ®: Valence ${valenceData.length}ç‚¹, GSR ${gsrData.length}ç‚¹`);

        return await this.crossCorrelationAlignment(valenceData, gsrData, config);
      }

      // Step 2: äº’ç›¸å…³å¯¹é½
      async crossCorrelationAlignment(valenceData, gsrData, config) {
        console.log('ğŸ” æ‰§è¡Œäº’ç›¸å…³å¯¹é½...');

        // 1. æ•°æ®é¢„å¤„ç†å’Œé‡é‡‡æ ·åˆ°ç»Ÿä¸€æ—¶é—´è½´
        const { alignedValence, alignedGSR, timeAxis } = this.preprocessForCorrelation(valenceData, gsrData);
        
        if (alignedValence.length === 0 || alignedGSR.length === 0) {
          throw new Error('æ•°æ®é¢„å¤„ç†å¤±è´¥ï¼šæ²¡æœ‰æœ‰æ•ˆçš„é‡å æ—¶é—´æ®µ');
        }

        console.log(`ğŸ“ˆ é¢„å¤„ç†å®Œæˆ: ç»Ÿä¸€æ—¶é—´è½´ ${timeAxis.length}ç‚¹, æ—¶é—´èŒƒå›´ ${timeAxis[0].toFixed(2)}s - ${timeAxis[timeAxis.length-1].toFixed(2)}s`);

        // 2. è®¡ç®—äº’ç›¸å…³
        const maxLagSamples = Math.floor(config.maxLagSeconds / (timeAxis[1] - timeAxis[0]));
        const correlation = this.calculateCrossCorrelation(alignedValence, alignedGSR, maxLagSamples);
        
        // 3. æ‰¾åˆ°æœ€ä½³æ»å
        const bestLag = this.findBestLag(correlation, maxLagSamples);
        const lagSeconds = bestLag.lagSamples * (timeAxis[1] - timeAxis[0]);
        const confidence = bestLag.correlation;

        console.log(`ğŸ¯ äº’ç›¸å…³ç»“æœ: æœ€ä½³æ»å ${lagSeconds.toFixed(3)}s (${bestLag.lagSamples}æ ·æœ¬), ç›¸å…³æ€§ ${confidence.toFixed(3)}`);

        // 4. åº”ç”¨æ—¶é—´åç§»
        const alignedData = this.applyTimeOffset(valenceData, gsrData, lagSeconds);

        this.alignmentResults = {
          method: 'cross_correlation',
          lagSeconds: lagSeconds,
          confidence: confidence,
          correlation: correlation,
          alignedValence: alignedData.alignedValence,
          alignedGSR: alignedData.alignedGSR,
          diagnostics: {
            originalValenceLength: valenceData.length,
            originalGSRLength: gsrData.length,
            processedLength: timeAxis.length,
            maxLagSeconds: config.maxLagSeconds,
            samplingRate: 1 / (timeAxis[1] - timeAxis[0])
          }
        };

        return this.alignmentResults;
      }



      // æ•°æ®é¢„å¤„ç†ï¼šé‡é‡‡æ ·åˆ°ç»Ÿä¸€æ—¶é—´è½´
      preprocessForCorrelation(valenceData, gsrData) {
        // æ‰¾åˆ°æ•°æ®çš„é‡å æ—¶é—´èŒƒå›´
        const valenceTimeRange = [valenceData[0].time, valenceData[valenceData.length - 1].time];
        const gsrTimeRange = [gsrData[0].time, gsrData[gsrData.length - 1].time];
        
        const startTime = Math.max(valenceTimeRange[0], gsrTimeRange[0]);
        const endTime = Math.min(valenceTimeRange[1], gsrTimeRange[1]);
        
        if (startTime >= endTime) {
          throw new Error('æ•°æ®æ²¡æœ‰æ—¶é—´é‡å ');
        }

        // åˆ›å»ºç»Ÿä¸€çš„æ—¶é—´è½´ (0.2sé—´éš” = 5Hz)
        const samplingInterval = 0.2;
        const timeAxis = [];
        for (let t = startTime; t <= endTime; t += samplingInterval) {
          timeAxis.push(t);
        }

        // æ’å€¼åˆ°ç»Ÿä¸€æ—¶é—´è½´
        const alignedValence = this.interpolateToTimeAxis(valenceData, timeAxis, 'valence');
        const alignedGSR = this.interpolateToTimeAxis(gsrData, timeAxis, 'gsr');

        return { alignedValence, alignedGSR, timeAxis };
      }

      // çº¿æ€§æ’å€¼åˆ°æŒ‡å®šæ—¶é—´è½´
      interpolateToTimeAxis(sourceData, targetTimeAxis, valueField) {
        const result = [];
        
        for (const targetTime of targetTimeAxis) {
          // æ‰¾åˆ°æ’å€¼ç‚¹
          let beforeIndex = -1;
          let afterIndex = -1;
          
          for (let i = 0; i < sourceData.length - 1; i++) {
            if (sourceData[i].time <= targetTime && sourceData[i + 1].time >= targetTime) {
              beforeIndex = i;
              afterIndex = i + 1;
              break;
            }
          }
          
          let interpolatedValue;
          
          if (beforeIndex !== -1 && afterIndex !== -1) {
            // çº¿æ€§æ’å€¼
            const before = sourceData[beforeIndex];
            const after = sourceData[afterIndex];
            const ratio = (targetTime - before.time) / (after.time - before.time);
            interpolatedValue = before[valueField] + ratio * (after[valueField] - before[valueField]);
          } else {
            // ä½¿ç”¨æœ€è¿‘é‚»
            let closestIndex = 0;
            let minDistance = Math.abs(sourceData[0].time - targetTime);
            
            for (let i = 1; i < sourceData.length; i++) {
              const distance = Math.abs(sourceData[i].time - targetTime);
              if (distance < minDistance) {
                minDistance = distance;
                closestIndex = i;
              }
            }
            
            interpolatedValue = sourceData[closestIndex][valueField];
          }
          
          result.push(interpolatedValue);
        }
        
        return result;
      }

      // è®¡ç®—äº’ç›¸å…³
      calculateCrossCorrelation(signal1, signal2, maxLag) {
        const correlation = [];
        const length = Math.min(signal1.length, signal2.length);
        
        // è®¡ç®—ä» -maxLag åˆ° +maxLag çš„ç›¸å…³æ€§
        for (let lag = -maxLag; lag <= maxLag; lag++) {
          let sum = 0;
          let count = 0;
          
          const mean1 = signal1.reduce((a, b) => a + b, 0) / signal1.length;
          const mean2 = signal2.reduce((a, b) => a + b, 0) / signal2.length;
          
          let sum1Sq = 0, sum2Sq = 0, sumProduct = 0;
          
          for (let i = 0; i < length; i++) {
            const j = i + lag;
            if (j >= 0 && j < length) {
              const val1 = signal1[i] - mean1;
              const val2 = signal2[j] - mean2;
              
              sum1Sq += val1 * val1;
              sum2Sq += val2 * val2;
              sumProduct += val1 * val2;
              count++;
            }
          }
          
          const correlation_value = count > 0 ? sumProduct / Math.sqrt(sum1Sq * sum2Sq) : 0;
          correlation.push({ lag: lag, correlation: correlation_value });
        }
        
        return correlation;
      }

      // æ‰¾åˆ°æœ€ä½³æ»å
      findBestLag(correlation) {
        let bestResult = { lagSamples: 0, correlation: 0 };
        
        for (const result of correlation) {
          if (Math.abs(result.correlation) > Math.abs(bestResult.correlation)) {
            bestResult = { lagSamples: result.lag, correlation: result.correlation };
          }
        }
        
        return bestResult;
      }

      // åº”ç”¨æ—¶é—´åç§»
      applyTimeOffset(valenceData, gsrData, lagSeconds) {
        const alignedValence = valenceData.map(d => ({ ...d }));
        const alignedGSR = gsrData.map(d => ({ 
          ...d, 
          time: d.time - lagSeconds // GSRæ—¶é—´å‘å‰/å‘ååç§»
        }));

        return { alignedValence, alignedGSR };
      }




      // ç”Ÿæˆå¯¹é½æŠ¥å‘Š
      generateAlignmentReport() {
        if (!this.alignmentResults) {
          return 'æ²¡æœ‰å¯¹é½ç»“æœ';
        }
        
        const result = this.alignmentResults;
        let report = `ğŸ“Š æ—¶é—´å¯¹é½æŠ¥å‘Š\n`;
        report += `æ–¹æ³•: ${result.method}\n`;
        report += `æ—¶é—´åç§»: ${result.lagSeconds.toFixed(3)}ç§’\n`;
        report += `ç›¸å…³æ€§ç½®ä¿¡åº¦: ${result.confidence.toFixed(3)}\n`;
        
        if (result.driftModel) {
          report += `\nğŸ”§ æ¼‚ç§»ä¿®æ­£:\n`;
          report += `æ—¶é’Ÿåå·®: ${((result.driftModel.scale - 1) * 100).toFixed(3)}%\n`;
          report += `æ‹Ÿåˆè´¨é‡ RÂ²: ${result.driftModel.r2.toFixed(3)}\n`;
        }
        
        report += `\nğŸ“ˆ è¯Šæ–­ä¿¡æ¯:\n`;
        report += `åŸå§‹æ•°æ®: VA ${result.diagnostics.originalValenceLength}ç‚¹, GSR ${result.diagnostics.originalGSRLength}ç‚¹\n`;
        report += `å¤„ç†é‡‡æ ·ç‡: ${result.diagnostics.samplingRate.toFixed(1)}Hz\n`;
        
        return report;
      }
    }

    // Isolation Forestå¼‚å¸¸æ£€æµ‹å™¨ç±»
    class IsolationForestDetector {
      constructor() {
        this.apiUrl = deepfaceApiUrl; // ä½¿ç”¨DeepFace APIåœ°å€
        this.results = null;
      }

      // å‡†å¤‡æ•°æ®
      prepareData(dataSource) {
        let data = [];
        let timestamps = [];
        let sourceInfo = '';
        
        switch(dataSource) {
          case 'gsr':
            if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
              throw new Error('è¯·å…ˆå¯¼å…¥GSRæ•°æ®');
            }
            
            for (const item of physiologicalData.gsr) {
              if (isFinite(item.gsr)) {
                data.push([item.gsr]); // å•ç»´ç‰¹å¾
                timestamps.push(item.time);
              }
            }
            // æ£€æµ‹GSRæ•°æ®æ˜¯å¦å·²æ ‡å‡†åŒ–
            const gsrValues = data.map(d => d[0]);
            const gsrMean = gsrValues.reduce((a, b) => a + b, 0) / gsrValues.length;
            const isStandardized = Math.abs(gsrMean) < 0.1 && gsrValues.some(v => Math.abs(v) > 2);
            sourceInfo = `GSRæ•°æ®${isStandardized ? '(å·²æ ‡å‡†åŒ–)' : '(åŸå§‹)'}ï¼š${data.length}ä¸ªæ•°æ®ç‚¹`;
            break;
            
          case 'valence':
            if (!dataLog || dataLog.length === 0) {
              throw new Error('è¯·å…ˆè¿›è¡Œæƒ…ç»ªåˆ†æ');
            }
            
            for (const record of dataLog) {
              if (record.face && isFinite(record.valence)) {
                data.push([record.valence]); // å•ç»´ç‰¹å¾
                timestamps.push(record.time);
              }
            }
            // æ£€æµ‹Valenceæ•°æ®æ˜¯å¦å·²æ ‡å‡†åŒ–
            const valenceValues = data.map(d => d[0]);
            const valenceMean = valenceValues.reduce((a, b) => a + b, 0) / valenceValues.length;
            const isValenceStandardized = Math.abs(valenceMean) < 0.1 && valenceValues.some(v => Math.abs(v) > 2);
            sourceInfo = `Valenceæ•°æ®${isValenceStandardized ? '(å·²æ ‡å‡†åŒ–)' : '(åŸå§‹)'}ï¼š${data.length}ä¸ªæ•°æ®ç‚¹`;
            break;
            
          case 'combined':
            console.log('ğŸ”„ å‡†å¤‡è”åˆå¼‚å¸¸æ£€æµ‹æ•°æ® (GSR + Valence)');
            
            // ä½¿ç”¨æ•°æ®å¯¹é½æ–¹æ³•
            const combinedData = this.alignAndCombineData();
            
            for (const item of combinedData) {
              if (isFinite(item.gsr) && isFinite(item.valence)) {
                data.push([item.gsr, item.valence]); // äºŒç»´ç‰¹å¾å‘é‡
                timestamps.push(item.time);
              }
            }
            
            // æ£€æµ‹è”åˆæ•°æ®æ˜¯å¦å·²æ ‡å‡†åŒ–
            if (data.length > 0) {
              const gsrVals = data.map(d => d[0]);
              const valenceVals = data.map(d => d[1]);
              const gsrMean = gsrVals.reduce((a, b) => a + b, 0) / gsrVals.length;
              const valenceMean = valenceVals.reduce((a, b) => a + b, 0) / valenceVals.length;
              const gsrStd = Math.abs(gsrMean) < 0.1 && gsrVals.some(v => Math.abs(v) > 2);
              const valenceStd = Math.abs(valenceMean) < 0.1 && valenceVals.some(v => Math.abs(v) > 2);
              const statusText = (gsrStd && valenceStd) ? '(å·²æ ‡å‡†åŒ–)' : 
                                 (gsrStd || valenceStd) ? '(éƒ¨åˆ†æ ‡å‡†åŒ–)' : '(åŸå§‹)';
              sourceInfo = `è”åˆæ•°æ®${statusText}ï¼š${data.length}ä¸ªæ•°æ®ç‚¹ (GSR + Valence)`;
            } else {
              sourceInfo = `è”åˆæ•°æ®ï¼š${data.length}ä¸ªæ•°æ®ç‚¹ (GSR + Valence)`;
            }
            console.log(`âœ… è”åˆæ•°æ®å‡†å¤‡å®Œæˆ: ${data.length}ä¸ªäºŒç»´ç‰¹å¾å‘é‡`);
            break;
            
          default:
            throw new Error('æœªçŸ¥çš„æ•°æ®æº');
        }
        
        if (data.length === 0) {
          throw new Error(`${dataSource} æ•°æ®ä¸ºç©º`);
        }
        
        console.log(`å‡†å¤‡å¼‚å¸¸æ£€æµ‹æ•°æ®ï¼š${sourceInfo}`);
        return { data, timestamps, sourceInfo };
      }

      // è¿è¡ŒIsolation Forestæ£€æµ‹
      async runDetection(dataSource, contamination = 0.1) {
        try {
          const { data, timestamps, sourceInfo } = this.prepareData(dataSource);
          
          // è°ƒç”¨PyOD API
          const response = await fetch(`${this.apiUrl}/anomaly/isolation_forest`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              data: data,
              contamination: contamination,
              random_state: 42
            }),
            timeout: 30000
          });

          if (!response.ok) {
            throw new Error(`APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            // å¤„ç†è¿”å›ç»“æœ
            const anomalyIndices = [];
            const anomalyScores = result.anomaly_scores || [];
            const predictions = result.predictions || [];
            
            predictions.forEach((pred, idx) => {
              if (pred === 1) { // å¼‚å¸¸ç‚¹
                anomalyIndices.push(idx);
              }
            });
            
            this.results = {
              dataSource: dataSource,
              contamination: contamination,
              totalPoints: data.length,
              anomalyIndices: anomalyIndices,
              anomalyScores: anomalyScores,
              timestamps: timestamps,
              data: data,
              anomalies: anomalyIndices.map(idx => ({
                index: idx,
                time: timestamps[idx],
                value: dataSource === 'combined' ? data[idx] : data[idx][0], // è”åˆæ•°æ®ä¿ç•™å®Œæ•´æ•°ç»„
                score: anomalyScores[idx]
              })),
              sourceInfo: sourceInfo
            };
            
            console.log(`Isolation Forestå¼‚å¸¸æ£€æµ‹å®Œæˆ:`, this.results);
            return this.results;
            
          } else {
            throw new Error(result.error || 'APIè¿”å›é”™è¯¯çŠ¶æ€');
          }

        } catch (error) {
          console.error(`Isolation Forestå¼‚å¸¸æ£€æµ‹å¤±è´¥: ${error.message}`);
          throw error;
        }
      }

      // æ˜¾ç¤ºå¼‚å¸¸ç‚¹
      showAnomalies() {
        if (!this.results || !chart) return;
        
        // å‡†å¤‡å¼‚å¸¸ç‚¹æ•°æ®ï¼Œå¤„ç†è”åˆæ•°æ®çš„Yå€¼
        const anomalyPoints = this.results.anomalies.map(anomaly => ({
          x: anomaly.time,
          y: this.getAnomalyYValue(anomaly),
          score: anomaly.score
        }));
        
        // è°ƒè¯•ä¿¡æ¯
        console.log(`å‡†å¤‡æ˜¾ç¤ºå¼‚å¸¸ç‚¹:`, {
          totalAnomalies: anomalyPoints.length,
          dataSource: this.results.dataSource,
          samplePoints: anomalyPoints.slice(0, 5),
          yRange: {
            min: Math.min(...anomalyPoints.map(p => p.y)),
            max: Math.max(...anomalyPoints.map(p => p.y))
          },
          xRange: {
            min: Math.min(...anomalyPoints.map(p => p.x)),
            max: Math.max(...anomalyPoints.map(p => p.x))
          }
        });
        
        // æ ¹æ®æ•°æ®æºé€‰æ‹©æ˜¾ç¤ºæ ·å¼
        let options = {};
        
        switch(this.results.dataSource) {
          case 'gsr':
            options = {
              color: '#ff6b6b',
              size: 4, // GSRç”¨æ›´å°çš„ç‚¹ï¼Œå› ä¸ºæ•°æ®å¯†é›†
              label: 'MLå¼‚å¸¸ç‚¹(GSR)',
              dataSource: 'GSR'
            };
            break;
            
          case 'valence':
            options = {
              color: '#fbbf24',
              size: 6,
              label: 'MLå¼‚å¸¸ç‚¹(Valence)',
              dataSource: 'VALENCE'
            };
            break;
            
          case 'combined':
            options = {
              color: '#8b5cf6', // ç´«è‰²è¡¨ç¤ºè”åˆæ£€æµ‹
              size: 8,
              label: 'MLå¼‚å¸¸ç‚¹(è”åˆ)',
              dataSource: 'COMBINED'
            };
            break;
            
          default:
            options = {
              color: '#ff6b6b',
              size: 6,
              label: 'MLå¼‚å¸¸ç‚¹',
              dataSource: this.results.dataSource.toUpperCase()
            };
        }
        
        // ä½¿ç”¨VAChartçš„æ–¹æ³•æ˜¾ç¤ºå¼‚å¸¸ç‚¹
        chart.showMLAnomalies(anomalyPoints, options);
        
        showingAnomalies = true;
        console.log(`æ˜¾ç¤º ${anomalyPoints.length} ä¸ª${options.dataSource}å¼‚å¸¸ç‚¹`);
      }

      // è·å–å¼‚å¸¸ç‚¹çš„Yå€¼æ˜¾ç¤ºä½ç½®
      getAnomalyYValue(anomaly) {
        const dataSource = this.results.dataSource;
        
        switch(dataSource) {
          case 'gsr':
          case 'valence':
            return anomaly.value;
            
          case 'combined':
            // å¯¹äºè”åˆæ•°æ®ï¼Œä¼˜å…ˆæ˜¾ç¤ºåœ¨Valenceä½ç½®
            // anomaly.valueæ˜¯äºŒç»´æ•°ç»„ [gsr, valence]ï¼Œæˆ‘ä»¬å–valenceå€¼
            if (Array.isArray(anomaly.value) && anomaly.value.length >= 2) {
              return anomaly.value[1]; // valenceå€¼
            }
            return 0;
            
          default:
            return anomaly.value;
        }
      }

      // éšè—å¼‚å¸¸ç‚¹
      hideAnomalies() {
        if (chart) {
          chart.hideMLAnomalies();
        }
        showingAnomalies = false;
        console.log('å·²éšè—å¼‚å¸¸ç‚¹');
      }

      // åˆ‡æ¢å¼‚å¸¸ç‚¹æ˜¾ç¤º
      toggleAnomalies() {
        if (showingAnomalies) {
          this.hideAnomalies();
        } else {
          this.showAnomalies();
        }
      }

      // æ•°æ®å¯¹é½å’Œèåˆæ–¹æ³•
      alignAndCombineData() {
        const gsrData = physiologicalData.gsr;
        const valenceData = dataLog.filter(record => record.face && isFinite(record.valence));
        
        if (!gsrData || gsrData.length === 0) {
          throw new Error('GSRæ•°æ®ä¸ºç©ºï¼Œè¯·å…ˆå¯¼å…¥GSRæ•°æ®');
        }
        if (!valenceData || valenceData.length === 0) {
          throw new Error('Valenceæ•°æ®ä¸ºç©ºï¼Œè¯·å…ˆè¿›è¡Œæƒ…ç»ªåˆ†æ');
        }
        
        console.log(`ğŸ”„ æ•°æ®å¯¹é½å¼€å§‹: GSR ${gsrData.length}ç‚¹, Valence ${valenceData.length}ç‚¹`);
        
        const combinedData = [];
        const tolerance = 0.5; // 500msæ—¶é—´å®¹å·®
        
        // ç­–ç•¥ï¼šä»¥GSRæ•°æ®ä¸ºåŸºå‡†ï¼ŒåŒ¹é…æœ€è¿‘çš„Valenceæ•°æ®
        for (const gsrPoint of gsrData) {
          let closestValence = null;
          let minTimeDiff = Infinity;
          
          for (const valencePoint of valenceData) {
            const timeDiff = Math.abs(valencePoint.time - gsrPoint.time);
            if (timeDiff < minTimeDiff && timeDiff <= tolerance) {
              minTimeDiff = timeDiff;
              closestValence = valencePoint;
            }
          }
          
          if (closestValence) {
            combinedData.push({
              time: gsrPoint.time,
              gsr: gsrPoint.gsr,
              valence: closestValence.valence,
              timeDiff: minTimeDiff
            });
          }
        }
        
        console.log(`âœ… æ•°æ®å¯¹é½å®Œæˆ: ${combinedData.length}ä¸ªæœ‰æ•ˆæ•°æ®ç‚¹`);
        console.log(`ğŸ“Š å¹³å‡æ—¶é—´å·®: ${(combinedData.reduce((sum, p) => sum + p.timeDiff, 0) / combinedData.length).toFixed(3)}s`);
        
        return combinedData;
      }

      // æ£€æŸ¥APIçŠ¶æ€
      async checkApiStatus() {
        try {
          const response = await fetch(`${this.apiUrl}/anomaly/info`, {
            method: 'GET',
            timeout: 5000
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('PyODå¼‚å¸¸æ£€æµ‹APIçŠ¶æ€:', result);
            return { available: true, info: result };
          } else {
            throw new Error(`APIçŠ¶æ€æ£€æŸ¥å¤±è´¥: ${response.status}`);
          }
        } catch (error) {
          console.warn(`PyODå¼‚å¸¸æ£€æµ‹APIä¸å¯ç”¨: ${error.message}`);
          return { available: false, error: error.message };
        }
      }
    }

    // å¼‚å¸¸åŒºé—´æ£€æµ‹å™¨ç±»
    class AnomalyIntervalDetector {
        constructor() {
            this.maxGap = 2.0;          // æœ€å¤§èšç±»é—´éš”ï¼ˆç§’ï¼‰
            this.minDuration = 1.0;     // æœ€å°åŒºé—´é•¿åº¦ï¼ˆç§’ï¼‰
        }

        // æ£€æµ‹å¼‚å¸¸åŒºé—´
        detectIntervals(anomalies, options = {}) {
            const config = { ...this, ...options };
            
            if (!anomalies || anomalies.length === 0) {
                console.log('æ²¡æœ‰å¼‚å¸¸ç‚¹æ•°æ®ï¼Œè·³è¿‡åŒºé—´æ£€æµ‹');
                return [];
            }

            console.log(`ğŸ” å¼€å§‹å¼‚å¸¸åŒºé—´æ£€æµ‹ - è¾“å…¥${anomalies.length}ä¸ªå¼‚å¸¸ç‚¹`);
            console.log(`å‚æ•°: maxGap=${config.maxGap}s, minDuration=${config.minDuration}s`);

            // 1. æŒ‰æ—¶é—´æ’åº
            const sortedAnomalies = [...anomalies].sort((a, b) => a.time - b.time);
            
            // 2. èšç±»ç›¸è¿‘çš„å¼‚å¸¸ç‚¹
            const clusters = this.clusterByTime(sortedAnomalies, config.maxGap);
            console.log(`èšç±»ç»“æœ: ${clusters.length}ä¸ªèšç±»`);
            
            // 3. è½¬æ¢ä¸ºæ—¶é—´åŒºé—´
            const intervals = clusters.map(cluster => this.clusterToInterval(cluster, config));
            console.log(`åˆå§‹åŒºé—´: ${intervals.length}ä¸ªï¼Œå¹³å‡é•¿åº¦${intervals.length > 0 ? (intervals.reduce((sum, i) => sum + i.duration, 0) / intervals.length).toFixed(2) : 0}s`);
            
            // 4. è¿‡æ»¤çŸ­åŒºé—´
            const validIntervals = intervals.filter(interval => {
                const isValid = interval.duration >= config.minDuration;
                if (!isValid) {
                    console.log(`è¿‡æ»¤çŸ­åŒºé—´: ${interval.startTime.toFixed(1)}s-${interval.endTime.toFixed(1)}s (${interval.duration.toFixed(1)}s < ${config.minDuration}s)`);
                }
                return isValid;
            });
            
            console.log(`âœ… åŒºé—´æ£€æµ‹å®Œæˆ: ${validIntervals.length}ä¸ªæœ‰æ•ˆåŒºé—´`);
            console.log(`ğŸ“ˆ å¤„ç†æ•ˆæœ: åŸå§‹${clusters.length}èšç±» â†’ å½¢æˆ${intervals.length}åŒºé—´ â†’ æœ€ç»ˆ${validIntervals.length}æœ‰æ•ˆåŒºé—´`);
            this.logIntervalSummary(validIntervals);
            
            return validIntervals;
        }

        // æŒ‰æ—¶é—´èšç±»
        clusterByTime(anomalies, maxGap) {
            const clusters = [];
            let currentCluster = [anomalies[0]];
            
            for (let i = 1; i < anomalies.length; i++) {
                const prevTime = anomalies[i-1].time;
                const currTime = anomalies[i].time;
                const timeGap = currTime - prevTime;
                
                if (timeGap <= maxGap) {
                    currentCluster.push(anomalies[i]);
                } else {
                    clusters.push([...currentCluster]);
                    currentCluster = [anomalies[i]];
                }
            }
            
            clusters.push(currentCluster);
            return clusters;
        }

        // å°†èšç±»è½¬æ¢ä¸ºåŒºé—´
        clusterToInterval(cluster, config) {
            const times = cluster.map(point => point.time);
            const scores = cluster.map(point => point.score || 0);
            const values = cluster.map(point => point.value);
            
            const startTime = Math.min(...times);
            const endTime = Math.max(...times);
            const duration = endTime - startTime;
            
            const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
            const maxScore = Math.max(...scores);
            const avgValue = values.reduce((sum, val) => sum + val, 0) / values.length;
            
            // è®¡ç®—ç½®ä¿¡åº¦ï¼ˆåŸºäºå¼‚å¸¸ç‚¹å¯†åº¦å’Œåˆ†æ•°ï¼‰
            const density = cluster.length / Math.max(duration, 0.1);
            const confidence = Math.min(1.0, (density * 0.3 + (Math.abs(avgScore) / 3.0) * 0.7));
            
            return {
                startTime: startTime,
                endTime: endTime,
                duration: duration,
                anomalyCount: cluster.length,
                avgScore: avgScore,
                maxScore: maxScore,
                avgValue: avgValue,
                confidence: confidence,
                type: this.classifyInterval(cluster, duration),
                originalPoints: cluster
            };
        }

        // åˆ†ç±»åŒºé—´ç±»å‹
        classifyInterval(cluster, duration) {
            if (duration < 1.0) return 'spike';        // å°–å³°å¼‚å¸¸
            if (duration < 3.0) return 'brief';        // çŸ­æš‚å¼‚å¸¸
            if (duration < 10.0) return 'short';       // çŸ­æœŸå¼‚å¸¸
            if (duration < 30.0) return 'medium';      // ä¸­æœŸå¼‚å¸¸
            return 'sustained';                        // æŒç»­å¼‚å¸¸
        }

        // åˆå¹¶ç›¸é‚»åŒºé—´
        mergeAdjacentIntervals(intervals, mergeThreshold) {
            if (intervals.length <= 1) return intervals;
            
            intervals.sort((a, b) => a.startTime - b.startTime);
            
            const merged = [];
            let current = { ...intervals[0] };
            
            for (let i = 1; i < intervals.length; i++) {
                const next = intervals[i];
                const gap = next.startTime - current.endTime;
                
                if (gap <= mergeThreshold) {
                    // åˆå¹¶åŒºé—´
                    current = {
                        startTime: current.startTime,
                        endTime: next.endTime,
                        duration: next.endTime - current.startTime,
                        anomalyCount: current.anomalyCount + next.anomalyCount,
                        avgScore: (current.avgScore * current.anomalyCount + next.avgScore * next.anomalyCount) / 
                                 (current.anomalyCount + next.anomalyCount),
                        maxScore: Math.max(current.maxScore, next.maxScore),
                        avgValue: (current.avgValue * current.anomalyCount + next.avgValue * next.anomalyCount) / 
                                 (current.anomalyCount + next.anomalyCount),
                        confidence: Math.max(current.confidence, next.confidence),
                        type: 'merged',
                        originalPoints: [...current.originalPoints, ...next.originalPoints]
                    };
                    console.log(`åˆå¹¶åŒºé—´: ${current.startTime.toFixed(1)}s-${current.endTime.toFixed(1)}s (é—´éš”${gap.toFixed(1)}s)`);
                } else {
                    merged.push(current);
                    current = { ...next };
                }
            }
            
            merged.push(current);
            return merged;
        }

        // è¾“å‡ºåŒºé—´æ±‡æ€»ä¿¡æ¯
        logIntervalSummary(intervals) {
            if (intervals.length === 0) {
                console.log('ğŸ“Š åŒºé—´æ±‡æ€»: æ²¡æœ‰æ£€æµ‹åˆ°æœ‰æ•ˆçš„å¼‚å¸¸åŒºé—´');
                return;
            }

            console.log('ï¿½ å¼‚å¸¸åŒºé—´æ±‡æ€»:');
            intervals.forEach((interval, index) => {
                console.log(`  ï¿½ åŒºé—´${index + 1}: ` +
                    `${interval.startTime.toFixed(1)}s-${interval.endTime.toFixed(1)}s ` +
                    `(${interval.duration.toFixed(1)}s, ${interval.anomalyCount}ç‚¹, ` +
                    `ç½®ä¿¡åº¦${(interval.confidence * 100).toFixed(0)}%)`);
            });

            // ç»Ÿè®¡ä¿¡æ¯
            const totalDuration = intervals.reduce((sum, interval) => sum + interval.duration, 0);
            const totalAnomalies = intervals.reduce((sum, interval) => sum + interval.anomalyCount, 0);
            const avgConfidence = intervals.reduce((sum, interval) => sum + interval.confidence, 0) / intervals.length;

            console.log(`ğŸ“ˆ æ€»ä½“ç»Ÿè®¡: ${intervals.length}ä¸ªåŒºé—´, æ€»æ—¶é•¿${totalDuration.toFixed(1)}s, ` +
                `${totalAnomalies}ä¸ªå¼‚å¸¸ç‚¹, å¹³å‡ç½®ä¿¡åº¦${(avgConfidence * 100).toFixed(0)}%`);
        }
    }

    // åˆ›å»ºå¼‚å¸¸æ£€æµ‹å™¨å®ä¾‹
    const isolationForestDetector = new IsolationForestDetector();
    const anomalyIntervalDetector = new AnomalyIntervalDetector();

    // åˆå§‹åŒ–æƒ…ç»ªå›¾è¡¨
    function initEmotionChart() {
      const emotionChartCanvas = document.getElementById('emotionChart');
      const ctx = emotionChartCanvas.getContext('2d');
      
      const datasets = emotionNames.map((name, index) => ({
        label: name,
        backgroundColor: emotionColors[index],
        borderColor: emotionColors[index],
        data: [],
        fill: false,
        lineTension: 0,
        pointRadius: 0,
        borderWidth: 2
      }));

      emotionChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: false,
          animation: { duration: 0 },
          legend: { 
            position: 'top', 
            labels: { fontColor: '#fff' },
            onClick: (e, legendItem) => {
              const index = legendItem.datasetIndex;
              const meta = emotionChart.getDatasetMeta(index);
              meta.hidden = meta.hidden === null ? !datasets[index].hidden : !meta.hidden;
              emotionChart.update();
            }
          },
          scales: {
            xAxes: [{
              type: 'linear',
              display: true,
              scaleLabel: { display: true, labelString: 'time (sec)', fontColor: '#fff' },
              ticks: { min: 0, suggestedMax: 300, stepSize: 2, fontColor: '#fff' },
              gridLines: {
                color: 'rgba(255,255,255,0.08)',
                zeroLineColor: 'rgba(255,255,255,0.35)',
                zeroLineWidth: 2
              }
            }],
            yAxes: [{
              display: true,
              scaleLabel: { display: true, labelString: 'Probability', fontColor: '#fff' },
              ticks: { min: 0, max: 1, stepSize: 0.2, fontColor: '#fff' },
              gridLines: {
                color: 'rgba(255,255,255,0.08)',
                zeroLineColor: 'rgba(255,255,255,0.35)',
                zeroLineWidth: 2
              }
            }]
          },
          tooltips: { mode: 'index', intersect: false }
        }
      });
      
      Chart.defaults.global.defaultFontColor = "#fff";
    }
    
    initEmotionChart();

    // æš´éœ²å…¨å±€å˜é‡ä¾›va-chart.jsè®¿é—®
    window.emotionChart = emotionChart;
    window.emotionDetectionEnabled = emotionDetectionEnabled;

    // CSVè§£æå‡½æ•° - ç›´æ¥è½¬æ¢ä¸ºXDFæ ¼å¼
    function parseShimmerCSVToXDF(csvText) {
      const lines = csvText.trim().split('\n');
      
      // å¤„ç†å¯èƒ½çš„åˆ†éš”ç¬¦å£°æ˜è¡Œ
      let headerLineIndex = 0;
      let separator = '\t'; // é»˜è®¤åˆ¶è¡¨ç¬¦åˆ†éš”
      
      // æ£€æŸ¥ç¬¬ä¸€è¡Œæ˜¯å¦æ˜¯åˆ†éš”ç¬¦å£°æ˜
      if (lines[0].includes('sep=')) {
        console.log('æ£€æµ‹åˆ°åˆ†éš”ç¬¦å£°æ˜:', lines[0]);
        // æå–åˆ†éš”ç¬¦
        const sepMatch = lines[0].match(/sep=(.)/);
        if (sepMatch) {
          separator = sepMatch[1];
          console.log('ä½¿ç”¨åˆ†éš”ç¬¦:', separator);
        }
        headerLineIndex = 1; // è·³è¿‡åˆ†éš”ç¬¦å£°æ˜è¡Œ
      }
      
      if (headerLineIndex >= lines.length) {
        throw new Error('CSVæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼šæ²¡æœ‰æ‰¾åˆ°æ ‡é¢˜è¡Œ');
      }
      
      const headers = lines[headerLineIndex].split(separator)
        .map(h => h.trim().replace(/\r/g, ''))
        .filter(h => h.length > 0); // è¿‡æ»¤æ‰ç©ºçš„è¡¨å¤´
      console.log('æ¸…ç†åçš„CSV Headers:', headers); // è°ƒè¯•ä¿¡æ¯
      
      // æŸ¥æ‰¾ç›¸å…³åˆ—çš„ç´¢å¼•
      const timeIndex = headers.findIndex(h => 
        h.includes('Timestamp') || 
        h.includes('timestamp') || 
        h.includes('TIME') || 
        h.includes('Time')
      );
      
      const gsrIndex = headers.findIndex(h => 
        h.includes('GSR_Skin_Conductance') || 
        (h.includes('GSR') && h.includes('Conductance'))
      );
      
      const ppgIndex = headers.findIndex(h => 
        h.includes('PPG') && h.includes('CAL')
      );
      
      console.log('Column indices - Time:', timeIndex, 'GSR:', gsrIndex, 'PPG:', ppgIndex);
      console.log('Time column name:', timeIndex >= 0 ? headers[timeIndex] : 'NOT FOUND');
      console.log('GSR column name:', gsrIndex >= 0 ? headers[gsrIndex] : 'NOT FOUND');
      console.log('PPG column name:', ppgIndex >= 0 ? headers[ppgIndex] : 'NOT FOUND');
      
      const gsrTimeSeries = [];
      const gsrTimeStamps = [];
      const ppgTimeSeries = [];
      const ppgTimeStamps = [];
      let startTime = null;
      
      // ä»æ ‡é¢˜è¡Œåçš„ä¸‹ä¸€è¡Œå¼€å§‹ï¼ˆè·³è¿‡å•ä½è¡Œï¼‰
      const dataStartIndex = headerLineIndex + 2;
      let processedLines = 0;
      let validTimeCount = 0;
      let validGSRCount = 0;
      let validPPGCount = 0;
      
      console.log('å¼€å§‹æ•°æ®è§£æ:');
      console.log('- headerLineIndex:', headerLineIndex);
      console.log('- dataStartIndex:', dataStartIndex);
      console.log('- æ€»è¡Œæ•°:', lines.length);
      console.log('- é¢„æœŸå¤„ç†è¡Œæ•°:', lines.length - dataStartIndex);
      console.log('- headers.length:', headers.length);
      
      // æ•°æ®é‡‡æ ·è®¾ç½® - ä»UIè·å–é…ç½®
      const maxDataPointsInput = document.getElementById('maxDataPoints');
      const maxDataPoints = maxDataPointsInput ? parseInt(maxDataPointsInput.value) || 20000 : 20000;
      const totalDataLines = lines.length - dataStartIndex;
      let samplingRate = 1; // é»˜è®¤ä¸é‡‡æ ·
      
      if (totalDataLines > maxDataPoints) {
        samplingRate = Math.ceil(totalDataLines / maxDataPoints);
        console.log(`æ•°æ®é‡è¾ƒå¤§(${totalDataLines}è¡Œ)ï¼Œå°†æŒ‰${samplingRate}:1æ¯”ç‡é‡‡æ ·ï¼Œé¢„è®¡å¤„ç†çº¦${Math.ceil(totalDataLines / samplingRate)}è¡Œ`);
      } else {
        console.log(`æ•°æ®é‡é€‚ä¸­(${totalDataLines}è¡Œ)ï¼Œå°†å¤„ç†å…¨éƒ¨æ•°æ®`);
      }
      
      let samplingCounter = 0;
      
      for (let i = dataStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
          console.log(`è·³è¿‡ç©ºè¡Œ ${i+1}`);
          continue; // è·³è¿‡ç©ºè¡Œ
        }
        
        // æ•°æ®é‡‡æ ·ï¼šåªå¤„ç†ç¬¦åˆé‡‡æ ·ç‡çš„è¡Œ
        if (samplingCounter % samplingRate !== 0) {
          samplingCounter++;
          continue;
        }
        samplingCounter++;
        
        const values = line.split(separator)
          .map(v => v.trim().replace(/\r/g, ''))
          .filter(v => v.length > 0); // è¿‡æ»¤æ‰ç©ºçš„å€¼
        
        // è¯¦ç»†è°ƒè¯•å‰å‡ è¡Œ
        if (processedLines < 3) {
          console.log(`è°ƒè¯•ç¬¬${i+1}è¡Œ(é‡‡æ ·åç¬¬${processedLines+1}è¡Œ):`);
          console.log('- åŸå§‹è¡Œ:', line);
          console.log('- åŸå§‹åˆ†å‰²æ•°é‡:', line.split(separator).length);
          console.log('- è¿‡æ»¤åvalues.length:', values.length);
          console.log('- headers.length:', headers.length);
          console.log('- values:', values);
        }
        
        if (values.length < headers.length) {
          if (processedLines < 3) {
            console.log(`ç¬¬${i+1}è¡Œåˆ—æ•°ä¸åŒ¹é…ï¼Œè·³è¿‡`);
          }
          continue;
        }
        
        processedLines++;
        
        // è°ƒè¯•å‰å‡ è¡Œæ•°æ®
        if (processedLines <= 3) {
          console.log(`å¤„ç†ç¬¬${processedLines}è¡Œæ•°æ®:`, values);
          console.log(`æ—¶é—´æˆ³å€¼: "${values[timeIndex >= 0 ? timeIndex : 0]}"`);
          if (gsrIndex >= 0) console.log(`GSRå€¼: "${values[gsrIndex]}"`);
          if (ppgIndex >= 0) console.log(`PPGå€¼: "${values[ppgIndex]}"`);
        }
        
        // è§£ææ—¶é—´æˆ³ - æ”¯æŒå®Œæ•´æ—¥æœŸæ—¶é—´æ ¼å¼
        const timeStr = values[timeIndex >= 0 ? timeIndex : 0];
        let totalSeconds;
        
        if (timeStr.includes('/') && timeStr.includes(':')) {
          // å®Œæ•´æ—¥æœŸæ—¶é—´æ ¼å¼: 2025/09/08 19:37:30.318
          try {
            const dateObj = new Date(timeStr);
            if (!isNaN(dateObj.getTime())) {
              totalSeconds = dateObj.getTime() / 1000; // è½¬æ¢ä¸ºUnixæ—¶é—´æˆ³(ç§’)
            } else {
              throw new Error('Invalid date');
            }
          } catch (e) {
            if (processedLines <= 3) {
              console.log(`æ—¥æœŸè§£æå¤±è´¥: "${timeStr}" -> ${e.message}`);
            }
            continue;
          }
        } else if (timeStr.includes(':')) {
          // ç®€å•æ—¶é—´æ ¼å¼: 37:30.3 æˆ– 00:37:30.3
          const timeParts = timeStr.split(':');
          if (timeParts.length === 2) {
            // MM:SS.mmm æ ¼å¼
            totalSeconds = parseInt(timeParts[0]) * 60 + parseFloat(timeParts[1]);
          } else if (timeParts.length === 3) {
            // HH:MM:SS.mmm æ ¼å¼
            totalSeconds = parseInt(timeParts[0]) * 3600 + parseInt(timeParts[1]) * 60 + parseFloat(timeParts[2]);
          } else {
            totalSeconds = parseFloat(timeStr);
          }
        } else {
          // çº¯æ•°å­—æ ¼å¼
          totalSeconds = parseFloat(timeStr);
        }
        
        if (isNaN(totalSeconds)) {
          if (processedLines <= 3) {
            console.log(`æ—¶é—´è§£æå¤±è´¥: "${timeStr}" -> NaN`);
          }
          continue; // è·³è¿‡æ— æ•ˆæ—¶é—´
        }
        
        validTimeCount++;
        
        if (startTime === null) {
          startTime = totalSeconds;
          console.log('å¼€å§‹æ—¶é—´(Unixæ—¶é—´æˆ³):', startTime, 'æ—¥æœŸ:', new Date(startTime * 1000).toISOString());
        }
        
        // ç›¸å¯¹æ—¶é—´ï¼ˆä»0å¼€å§‹ï¼‰
        const relativeTime = totalSeconds - startTime;
        
        // è°ƒè¯•å‰å‡ è¡Œçš„æ—¶é—´è½¬æ¢
        if (processedLines <= 3) {
          console.log(`ç¬¬${processedLines}è¡Œæ—¶é—´è½¬æ¢:`, {
            åŸå§‹æ—¶é—´: timeStr,
            ç»å¯¹æ—¶é—´æˆ³: totalSeconds,
            ç›¸å¯¹æ—¶é—´: relativeTime
          });
        }
        
        // è§£æGSRæ•°æ®
        if (gsrIndex !== -1 && values[gsrIndex]) {
          const gsrValue = parseFloat(values[gsrIndex]);
          if (!isNaN(gsrValue)) {
            gsrTimeSeries.push([gsrValue]);
            gsrTimeStamps.push(relativeTime);
            validGSRCount++;
          } else if (processedLines <= 3) {
            console.log(`GSRè§£æå¤±è´¥: "${values[gsrIndex]}" -> NaN`);
          }
        }
        
        // è§£æPPGæ•°æ®
        if (ppgIndex !== -1 && values[ppgIndex]) {
          const ppgValue = parseFloat(values[ppgIndex]);
          if (!isNaN(ppgValue)) {
            ppgTimeSeries.push([ppgValue]);
            ppgTimeStamps.push(relativeTime);
            validPPGCount++;
          } else if (processedLines <= 3) {
            console.log(`PPGè§£æå¤±è´¥: "${values[ppgIndex]}" -> NaN`);
          }
        }
      }
      
      // åˆ›å»ºç¬¦åˆLSLæ ‡å‡†çš„XDFæ ¼å¼æ•°æ®
      const xdfData = {
        "info": {
          "version": "1.0",
          "created": new Date().toISOString(),
          "software": "EmotionAnalysisApp_GSR_Extension",
          "session_id": `physio_session_${Date.now()}`
        },
        "streams": []
      };

      // æ·»åŠ GSRæµ - ç¬¦åˆLSLæ ‡å‡†
      if (gsrTimeSeries.length > 0) {
        xdfData.streams.push({
          "info": {
            "name": "Shimmer_GSR",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": gsrTimeSeries.length > 1 ? Math.round(1 / (gsrTimeStamps[1] - gsrTimeStamps[0])) : 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "GSR_Conductance",
                "unit": "microsiemens",
                "type": "GSR",
                "description": "Galvanic Skin Response - Skin Conductance"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["GSR"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": gsrTimeSeries,
          "time_stamps": gsrTimeStamps
        });
      }

      // æ·»åŠ PPGæµ - ç¬¦åˆLSLæ ‡å‡†
      if (ppgTimeSeries.length > 0) {
        xdfData.streams.push({
          "info": {
            "name": "Shimmer_PPG",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": ppgTimeSeries.length > 1 ? Math.round(1 / (ppgTimeStamps[1] - ppgTimeStamps[0])) : 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "PPG_A13",
                "unit": "millivolts",
                "type": "PPG",
                "description": "Photoplethysmography - Heart Rate Signal"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["PPG"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": ppgTimeSeries,
          "time_stamps": ppgTimeStamps
        });
      }
      
      console.log(`CSVè½¬XDFæˆåŠŸ: GSR ${gsrTimeSeries.length}ç‚¹, PPG ${ppgTimeSeries.length}ç‚¹`);
      console.log('è¯¦ç»†ç»Ÿè®¡:');
      console.log('- æ€»æ•°æ®è¡Œæ•°:', lines.length - dataStartIndex);
      console.log('- é‡‡æ ·ç‡:', samplingRate + ':1');
      console.log('- å¤„ç†çš„è¡Œæ•°:', processedLines);
      console.log('- æœ‰æ•ˆæ—¶é—´æˆ³:', validTimeCount);
      console.log('- æœ‰æ•ˆGSRæ•°æ®:', validGSRCount);
      console.log('- æœ‰æ•ˆPPGæ•°æ®:', validPPGCount);
      if (samplingRate > 1) {
        console.log('- æ•°æ®å‹ç¼©ç‡:', `${((processedLines / (lines.length - dataStartIndex)) * 100).toFixed(1)}%`);
      }
      
      if (gsrTimeSeries.length === 0 && ppgTimeSeries.length === 0) {
        console.warn('è­¦å‘Šï¼šæ²¡æœ‰è§£æåˆ°ä»»ä½•æ•°æ®ï¼Œè¯·æ£€æŸ¥ï¼š');
        console.warn('1. æ•°æ®æ˜¯å¦ä»ç¬¬', dataStartIndex + 1, 'è¡Œå¼€å§‹');
        console.warn('2. æ—¶é—´æˆ³æ ¼å¼æ˜¯å¦ä¸º MM:SS.mmm');
        console.warn('3. GSR/PPGæ•°æ®æ˜¯å¦ä¸ºæœ‰æ•ˆæ•°å­—');
        
        // æ˜¾ç¤ºå‰å‡ è¡ŒåŸå§‹æ•°æ®ç”¨äºè°ƒè¯•
        console.warn('å‰3è¡ŒåŸå§‹æ•°æ®:');
        for (let i = dataStartIndex; i < Math.min(dataStartIndex + 3, lines.length); i++) {
          console.warn(`ç¬¬${i+1}è¡Œ:`, lines[i]);
        }
      }
      
      return xdfData;
    }

    // XDFè§£æå‡½æ•°
    function parseXDFData(xdfData) {
      try {
        const data = typeof xdfData === 'string' ? JSON.parse(xdfData) : xdfData;
        
        const gsrData = [];
        const ppgData = [];
        
        if (data.streams) {
          for (const stream of data.streams) {
            if (stream.info.name === 'Shimmer_GSR' && stream.time_series) {
              // ä½¿ç”¨time_stampså­—æ®µæˆ–è®¡ç®—æ—¶é—´
              const timeStamps = stream.time_stamps;
              const sampleRate = stream.info.nominal_srate || 50;
              
              stream.time_series.forEach((sample, index) => {
                const time = timeStamps ? timeStamps[index] : (index / sampleRate);
                const value = Array.isArray(sample) ? sample[0] : sample;
                if (Number.isFinite(value)) {
                  gsrData.push({ time, gsr: value });
                }
              });
            }
            
            if (stream.info.name === 'Shimmer_PPG' && stream.time_series) {
              const timeStamps = stream.time_stamps;
              const sampleRate = stream.info.nominal_srate || 50;
              
              stream.time_series.forEach((sample, index) => {
                const time = timeStamps ? timeStamps[index] : (index / sampleRate);
                const value = Array.isArray(sample) ? sample[0] : sample;
                if (Number.isFinite(value)) {
                  ppgData.push({ time, ppg: value });
                }
              });
            }
          }
        }
        
        console.log(`XDFè§£æç»“æœ: GSR ${gsrData.length}ç‚¹, PPG ${ppgData.length}ç‚¹`);
        return { gsr: gsrData, ppg: ppgData };
      } catch (error) {
        throw new Error('XDFæ•°æ®è§£æå¤±è´¥: ' + error.message);
      }
    }

    // å°†ç”Ÿç†ä¿¡å·å’Œå¼‚å¸¸æ ‡è®°æ•°æ®è½¬æ¢ä¸ºXDFæ ¼å¼
    function convertPhysiologicalToXDF(gsrData, ppgData) {
      const hasGSR = gsrData && gsrData.length > 0;
      const hasPPG = ppgData && ppgData.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      
      const xdfData = {
        "info": {
          "version": "1.0",
          "created": new Date().toISOString(),
          "software": "EmotionAnalysisApp_Manual_Annotation",
          "source": hasGSR || hasPPG ? "Shimmer_Sensor_With_Manual_Annotation" : "Manual_Annotation_Only",
          "description": hasAnomalies ? 
            `${hasGSR || hasPPG ? 'GSR and PPG data from Shimmer sensor with' : 'Only'} manual anomaly annotations` :
            "GSR and PPG data from Shimmer wearable sensor"
        },
        "streams": []
      };

      console.log(`ğŸ“¦ åˆ›å»ºXDFæ•°æ®åŒ…: GSR=${hasGSR}, PPG=${hasPPG}, å¼‚å¸¸æ ‡è®°=${hasAnomalies}`);

      // GSRæ•°æ®æµ
      if (hasGSR) {
        const gsrStream = {
          "info": {
            "name": "Shimmer_GSR",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": 50, // å‡è®¾50Hzé‡‡æ ·ç‡
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "GSR_Conductance",
                "unit": "microsiemens",
                "type": "GSR",
                "description": "Galvanic Skin Response - Skin Conductance"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["GSR"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": gsrData.map(d => [d.gsr]),
          "time_stamps": gsrData.map(d => d.time)
        };
        xdfData.streams.push(gsrStream);
      }

      // PPGæ•°æ®æµ
      if (hasPPG) {
        const ppgStream = {
          "info": {
            "name": "Shimmer_PPG",
            "type": "Physiological", 
            "channel_count": 1,
            "nominal_srate": 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "PPG_A13",
                "unit": "millivolts",
                "type": "PPG",
                "description": "Photoplethysmography - Heart Rate Signal"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["PPG"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor", 
                "serial": "A923"
              }
            }
          },
          "time_series": ppgData.map(d => [d.ppg]),
          "time_stamps": ppgData.map(d => d.time)
        };
        xdfData.streams.push(ppgStream);
      }

      // æ‰‹åŠ¨å¼‚å¸¸æ ‡è®°æ•°æ®æµ
      if (manualAnomalyMarks && manualAnomalyMarks.length > 0) {
        const anomalyStream = {
          "info": {
            "name": "ManualAnomalyMarks",
            "type": "Annotations",
            "channel_count": 2,
            "nominal_srate": 0, // äº‹ä»¶æµï¼Œéå‘¨æœŸé‡‡æ ·
            "channel_format": "float32",
            "source_id": "EmotionAnalysisApp_Manual",
            "channels": [
              {
                "label": "AnomalyFlag",
                "unit": "binary",
                "type": "Marker",
                "description": "Manual anomaly detection flag (1=anomaly, 0=normal)"
              },
              {
                "label": "ValenceValue",
                "unit": "normalized",
                "type": "Emotion",
                "description": "Valence value at anomaly point (-1 to 1)"
              }
            ],
            "manufacturer": "EmotionAnalysisApp",
            "caps": ["ManualAnnotation"],
            "desc": {
              "device": {
                "name": "Manual Annotation Tool",
                "type": "software_annotation",
                "version": "1.0"
              }
            }
          },
          "time_series": manualAnomalyMarks.map(mark => [1, mark.valence]), // å¼‚å¸¸æ ‡è®°=1ï¼Œvalenceå€¼
          "time_stamps": manualAnomalyMarks.map(mark => mark.time)
        };
        xdfData.streams.push(anomalyStream);
      }

      return xdfData;
    }

    // å¯¼å‡ºXDFæ–‡ä»¶
    function exportPhysiologicalXDF(xdfData, filename = 'physiological_data.xdf') {
      const blob = new Blob([JSON.stringify(xdfData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // XDF æ ¼å¼å¤„ç†å™¨ç±»
    class XDFFormatter {
      constructor() {
        this.startTime = Date.now();
      }

      // å¯¼å‡ºä¸º XDF æ ¼å¼
      exportToXDF(dataLog, emotionDetectionEnabled, emotionNames) {
        if (dataLog.length === 0) {
          throw new Error('No data to export');
        }

        // åˆ›å»ºç¬¦åˆLabRecorderæ ‡å‡†çš„XDFæ ¼å¼
        const xdfData = {
          info: {
            version: [1, 0], // LabRecorderæœŸæœ›çš„ç‰ˆæœ¬æ ¼å¼
            created: new Date().toISOString(),
            software: 'EmotionAnalysisApp',
            hostname: window.location.hostname || 'localhost',
            session_id: `emotion_session_${this.startTime}`
          },
          streams: []
        };

        // VAæ•°æ®æµ - åŒ…å«æ‰€æœ‰æ•°æ®ç‚¹ï¼ŒåŒ…æ‹¬æ— äººè„¸çš„
        const vaStream = {
          info: {
            name: 'EmotionAnalysis_VA',
            type: 'Emotion',
            channel_count: 3,
            nominal_srate: 0.0, // LabRecorderæœŸæœ›æµ®ç‚¹æ•°
            channel_format: 'float32',
            source_id: `EmotionVA_${this.startTime}`,
            uid: this.generateUID(),
            created_at: (Date.now() / 1000.0), // Unixæ—¶é—´æˆ³
            hostname: window.location.hostname || 'localhost',
            // LabRecorderå…¼å®¹çš„é€šé“æè¿°æ ¼å¼
            desc: {
              acquisition: {
                manufacturer: 'EmotionAnalysisApp',
                model: 'VA_Analyzer_v1.0'
              },
              channels: {
                channel: [
                  {
                    label: 'Valence',
                    unit: 'normalized',
                    type: 'VA'
                  },
                  {
                    label: 'Arousal', 
                    unit: 'normalized',
                    type: 'VA'
                  },
                  {
                    label: 'FaceDetected',
                    unit: 'boolean',
                    type: 'Marker'
                  }
                ]
              }
            }
          },
          time_series: [],
          time_stamps: []
        };

        // æƒ…ç»ªæ•°æ®æµ - åªåŒ…å«æœ‰äººè„¸ä¸”æœ‰æƒ…ç»ªæ•°æ®çš„ç‚¹
        let emotionStream = null;
        if (emotionDetectionEnabled && dataLog.some(d => d.emotions)) {
          emotionStream = {
            info: {
              name: 'EmotionAnalysis_Emotions',
              type: 'Emotion',
              channel_count: 7,
              nominal_srate: 0.0,
              channel_format: 'float32',
              source_id: `Emotions_${this.startTime}`,
              uid: this.generateUID(),
              created_at: (Date.now() / 1000.0),
              hostname: window.location.hostname || 'localhost',
              desc: {
                acquisition: {
                  manufacturer: 'EmotionAnalysisApp',
                  model: 'Emotion_Analyzer_v1.0'
                },
                channels: {
                  channel: emotionNames.map(name => ({
                    label: name,
                    unit: 'probability',
                    type: 'Emotion'
                  }))
                }
              }
            },
            time_series: [],
            time_stamps: []
          };
        }

        // å¡«å……æ‰€æœ‰æ•°æ®ç‚¹ï¼Œç¡®ä¿æ—¶é—´æˆ³æ˜¯ç›¸å¯¹äºç¬¬ä¸€ä¸ªæ•°æ®ç‚¹çš„
        const baseTime = dataLog.length > 0 ? dataLog[0].time : 0;
        
        dataLog.forEach(entry => {
          const relativeTime = (entry.time || 0) - baseTime;
          
          // VAæ•°æ®æµï¼šåŒ…å«æ‰€æœ‰æ•°æ®ç‚¹
          vaStream.time_series.push([
            isFinite(entry.valence) ? entry.valence : 0,  // æ— äººè„¸æ—¶ä¸º0
            isFinite(entry.arousal) ? entry.arousal : 0,  // æ— äººè„¸æ—¶ä¸º0  
            entry.face ? 1.0 : 0.0   // äººè„¸æ£€æµ‹çŠ¶æ€
          ]);
          vaStream.time_stamps.push(relativeTime);

          // æƒ…ç»ªæ•°æ®æµï¼šåªåŒ…å«æœ‰äººè„¸ä¸”æœ‰æƒ…ç»ªæ•°æ®çš„ç‚¹
          if (emotionStream && entry.face && entry.emotions) {
            const emotionArray = emotionNames.map(name => 
              entry.emotions[name] || 0.0
            );
            emotionStream.time_series.push(emotionArray);
            emotionStream.time_stamps.push(relativeTime);
          }
        });

        xdfData.streams.push(vaStream);
        if (emotionStream) {
          xdfData.streams.push(emotionStream);
        }

        // æ‰‹åŠ¨å¼‚å¸¸æ ‡è®°æ•°æ®æµ
        if (typeof manualAnomalyMarks !== 'undefined' && manualAnomalyMarks.length > 0) {
          console.log(`ğŸ“¤ å‡†å¤‡å¯¼å‡ºå¼‚å¸¸æ ‡è®°æ•°æ®æµï¼ŒåŒ…å« ${manualAnomalyMarks.length} ä¸ªæ ‡è®°:`, manualAnomalyMarks);
          
          const anomalyStream = {
            info: {
              name: 'ManualAnomalyMarks',
              type: 'Annotations',
              channel_count: 2,
              nominal_srate: 0.0,
              channel_format: 'float32',
              source_id: `AnomalyMarks_${this.startTime}`,
              uid: this.generateUID(),
              created_at: (Date.now() / 1000.0),
              hostname: window.location.hostname || 'localhost',
              desc: {
                acquisition: {
                  manufacturer: 'EmotionAnalysisApp',
                  model: 'Manual_Annotation_Tool_v1.0'
                },
                channels: {
                  channel: [
                    {
                      label: 'AnomalyFlag',
                      unit: 'binary',
                      type: 'Marker'
                    },
                    {
                      label: 'ValenceValue',
                      unit: 'normalized',
                      type: 'Emotion'
                    }
                  ]
                }
              }
            },
            time_series: [],
            time_stamps: []
          };

          // æ·»åŠ å¼‚å¸¸æ ‡è®°æ•°æ®
          manualAnomalyMarks.forEach(mark => {
            anomalyStream.time_series.push([1, mark.valence]); // å¼‚å¸¸æ ‡è®°=1ï¼Œvalenceå€¼
            anomalyStream.time_stamps.push(mark.time);
          });

          xdfData.streams.push(anomalyStream);
          console.log(`ğŸ“¦ XDFå¯¼å‡ºåŒ…å« ${manualAnomalyMarks.length} ä¸ªå¼‚å¸¸æ ‡è®°`);
        }

      return xdfData;
    }

    // ç”ŸæˆLSLæ ‡å‡†çš„UID
      generateUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }      // ä» XDF æ ¼å¼å¯¼å…¥
      importFromXDF(xdfData) {
        try {
          const newDataLog = [];
          
          // æ‰¾åˆ°VAå’Œæƒ…ç»ªæ•°æ®æµ
          const vaStream = xdfData.streams.find(s => s.info.name === 'EmotionAnalysis_VA');
          const emotionStream = xdfData.streams.find(s => s.info.name === 'EmotionAnalysis_Emotions');
          const anomalyStream = xdfData.streams.find(s => s.info.name === 'ManualAnomalyMarks');

          if (!vaStream) {
            throw new Error('No VA data stream found in XDF file');
          }

          console.log(`ğŸ“¥ XDFå¯¼å…¥æ£€æµ‹åˆ°çš„æ•°æ®æµ:`, {
            VAæ•°æ®æµ: !!vaStream,
            æƒ…ç»ªæ•°æ®æµ: !!emotionStream,
            å¼‚å¸¸æ ‡è®°æµ: !!anomalyStream
          });

          // é‡å»ºæ‰€æœ‰æ•°æ®ç‚¹ï¼ˆåŒ…æ‹¬æ— äººè„¸çš„ï¼‰
          vaStream.time_series.forEach((vaData, index) => {
            const timestamp = vaStream.time_stamps[index];
            const faceDetected = vaData.length > 2 ? vaData[2] > 0.5 : true; // å‘åå…¼å®¹
            
            const dataPoint = {
              time: timestamp,
              valence: faceDetected ? vaData[0] : NaN,
              arousal: faceDetected ? vaData[1] : NaN,
              face: faceDetected
            };

            // æ·»åŠ æƒ…ç»ªæ•°æ®ï¼ˆå¦‚æœæœ‰ä¸”æœ‰äººè„¸ï¼‰
            if (emotionStream && faceDetected) {
              // æŸ¥æ‰¾æœ€æ¥è¿‘æ—¶é—´æˆ³çš„æƒ…ç»ªæ•°æ®
              let closestEmotionIndex = -1;
              let minTimeDiff = Infinity;
              
              emotionStream.time_stamps.forEach((emotionTime, i) => {
                const timeDiff = Math.abs(emotionTime - timestamp);
                if (timeDiff < minTimeDiff) {
                  minTimeDiff = timeDiff;
                  closestEmotionIndex = i;
                }
              });

              if (closestEmotionIndex !== -1 && minTimeDiff < 0.1) { // 100mså®¹å·®
                const emotionData = emotionStream.time_series[closestEmotionIndex];
                const emotionNames = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise'];
                
                dataPoint.emotions = {};
                emotionNames.forEach((name, i) => {
                  dataPoint.emotions[name] = emotionData[i] || 0;
                });
                
                // è®¡ç®—ä¸»å¯¼æƒ…ç»ª
                let maxEmotion = 'Neutral';
                let maxValue = dataPoint.emotions.Neutral || 0;
                emotionNames.forEach(name => {
                  if (dataPoint.emotions[name] > maxValue) {
                    maxValue = dataPoint.emotions[name];
                    maxEmotion = name;
                  }
                });
                dataPoint.dominantEmotion = maxEmotion;
              }
            }

            newDataLog.push(dataPoint);
          });

          // å¤„ç†å¼‚å¸¸æ ‡è®°æ•°æ®æµ
          if (anomalyStream) {
            console.log(`ğŸ¯ å‘ç°å¼‚å¸¸æ ‡è®°æ•°æ®æµï¼ŒåŒ…å« ${anomalyStream.time_series.length} ä¸ªæ ‡è®°`);
            
            // æ¸…ç©ºç°æœ‰å¼‚å¸¸æ ‡è®°
            manualAnomalyMarks.splice(0, manualAnomalyMarks.length);
            
            // å¯¼å…¥å¼‚å¸¸æ ‡è®°
            anomalyStream.time_series.forEach((markData, index) => {
              const timestamp = anomalyStream.time_stamps[index];
              const valenceValue = markData[1]; // ç¬¬äºŒä¸ªé€šé“æ˜¯valenceå€¼
              
              manualAnomalyMarks.push({
                time: timestamp,
                valence: valenceValue,
                marked: true,
                markTime: Date.now()
              });
            });
            
            console.log(`âœ… å·²å¯¼å…¥ ${manualAnomalyMarks.length} ä¸ªå¼‚å¸¸æ ‡è®°:`, manualAnomalyMarks);
            
            // æ›´æ–°å¼‚å¸¸æ ‡è®°çŠ¶æ€æ˜¾ç¤º
            updateAnomalyMarkingStatus();
            
            // æ›´æ–°å›¾è¡¨ä¸­çš„å¼‚å¸¸æ ‡è®°
            updateChartAnomalyMarks();
          } else {
            console.log(`â„¹ï¸ XDFæ–‡ä»¶ä¸­æœªå‘ç°å¼‚å¸¸æ ‡è®°æ•°æ®æµ`);
          }

          return newDataLog;
        } catch (error) {
          console.error('Failed to import XDF data:', error);
          throw error;
        }
      }
    }

    // åˆ›å»ºXDFæ ¼å¼å¤„ç†å™¨å®ä¾‹
    const xdfFormatter = new XDFFormatter();

    // æƒ…ç»ªæ£€æµ‹åˆ‡æ¢
    function toggleEmotionDetection() {
      const container = document.getElementById('emotionChartContainer');
      if (emotionDetectionEnabled) {
        container.style.display = 'block';
      } else {
        container.style.display = 'none';
      }
    }

    document.getElementById('emotionToggle').addEventListener('change', (e) => {
      emotionDetectionEnabled = e.target.checked;
      window.emotionDetectionEnabled = emotionDetectionEnabled; // æ›´æ–°å…¨å±€å˜é‡
      toggleEmotionDetection();
    });

    // API é€‰æ‹©å™¨äº‹ä»¶ç›‘å¬
    document.getElementById('apiSelector').addEventListener('change', async (e) => {
      currentAPI = e.target.value;
      console.log(`åˆ‡æ¢åˆ° ${currentAPI} API`);
      
      if (currentAPI === 'deepface') {
        await checkDeepFaceAPI();
      } else {
        apiConnected = true; // MorphCast æ€»æ˜¯å¯ç”¨çš„ï¼ˆå¦‚æœæœ‰license keyï¼‰
        updateApiStatus('MorphCast å·²é€‰æ‹©');
      }
    });

    // æ£€æŸ¥ DeepFace API çŠ¶æ€
    async function checkDeepFaceAPI() {
      const statusSpan = document.getElementById('apiStatus');
      
      try {
        statusSpan.textContent = 'çŠ¶æ€: è¿æ¥ä¸­...';
        statusSpan.style.color = '#fbbf24';
        
        const response = await fetch(`${deepfaceApiUrl}/health`, {
          method: 'GET',
          timeout: 5000
        });
        
        if (response.ok) {
          apiConnected = true;
          updateApiStatus('DeepFace å·²è¿æ¥');
          console.log('DeepFace API è¿æ¥æˆåŠŸ');
        } else {
          throw new Error('API å“åº”é”™è¯¯');
        }
      } catch (error) {
        console.error('DeepFace API è¿æ¥å¤±è´¥:', error);
        apiConnected = false;
        updateApiStatus('DeepFace æœªè¿æ¥');
        
        // å¦‚æœè¿æ¥å¤±è´¥ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦å¯åŠ¨æœåŠ¡
        if (confirm('DeepFace API æœåŠ¡æœªå¯åŠ¨ã€‚\n\nç‚¹å‡»"ç¡®å®š"æŸ¥çœ‹å¯åŠ¨è¯´æ˜ï¼Œç‚¹å‡»"å–æ¶ˆ"åˆ‡æ¢å› MorphCastã€‚')) {
          showDeepFaceStartupHelp();
        } else {
          document.getElementById('apiSelector').value = 'morphcast';
          currentAPI = 'morphcast';
          apiConnected = true;
          updateApiStatus('MorphCast å·²é€‰æ‹©');
        }
      }
    }

    // æ›´æ–° API çŠ¶æ€æ˜¾ç¤º
    function updateApiStatus(message) {
      const statusSpan = document.getElementById('apiStatus');
      statusSpan.textContent = `çŠ¶æ€: ${message}`;
      
      if (message.includes('å·²è¿æ¥') || message.includes('å·²é€‰æ‹©')) {
        statusSpan.style.color = '#10b981';
      } else if (message.includes('è¿æ¥ä¸­')) {
        statusSpan.style.color = '#fbbf24';
      } else {
        statusSpan.style.color = '#ef4444';
      }
    }

    // æ˜¾ç¤º DeepFace å¯åŠ¨å¸®åŠ©
    function showDeepFaceStartupHelp() {
      alert(`DeepFace API æœåŠ¡å¯åŠ¨è¯´æ˜ï¼š

1. æ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥é¡¹ç›®ç›®å½•ï¼š
   cd c:\\MyWork\\RunMorphCast\\deepface-api

2. è¿è¡Œç®¡ç†è„šæœ¬ï¼š
   manage_python.bat

3. é€‰æ‹© "1. Install Python Environment"ï¼ˆé¦–æ¬¡ä½¿ç”¨ï¼‰
   ç„¶åé€‰æ‹© "2. Start Service"

4. ç­‰å¾…æœåŠ¡å¯åŠ¨åï¼Œåˆ·æ–°æœ¬é¡µé¢å³å¯ä½¿ç”¨ DeepFace API`);
    }

    // ç”Ÿç†ä¿¡å·å¯¼å…¥äº‹ä»¶ç›‘å¬å™¨
    
    // ç»Ÿä¸€æ–‡ä»¶å¯¼å…¥äº‹ä»¶ï¼ˆæ”¯æŒCSVå’ŒXDFï¼‰
    document.getElementById('physioFileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const fileExtension = file.name.toLowerCase().split('.').pop();
        let xdfData;
        
        if (fileExtension === 'csv') {
          // CSVå…ˆè½¬æ¢ä¸ºXDFæ ¼å¼
          console.log('æ£€æµ‹åˆ°CSVæ–‡ä»¶ï¼Œè½¬æ¢ä¸ºXDFæ ¼å¼...');
          xdfData = parseShimmerCSVToXDF(text);
        } else if (fileExtension === 'xdf' || fileExtension === 'json') {
          // ç›´æ¥è§£æXDF
          console.log('æ£€æµ‹åˆ°XDFæ–‡ä»¶ï¼Œç›´æ¥è§£æ...');
          xdfData = typeof text === 'string' ? JSON.parse(text) : text;
        } else {
          throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ã€‚è¯·é€‰æ‹© CSVã€XDF æˆ– JSON æ–‡ä»¶ã€‚');
        }
        
        // ä»XDFæ ¼å¼è§£ææ•°æ®ç”¨äºæ˜¾ç¤º
        const parsedData = parseXDFData(xdfData);
        
        // å­˜å‚¨æ•°æ®
        physiologicalData.gsr = parsedData.gsr || [];
        physiologicalData.ppg = parsedData.ppg || [];
        physiologicalData.startTime = Date.now();
        
        // å­˜å‚¨XDFæ ¼å¼æ•°æ®ç”¨äºå¯¼å‡º
        window.convertedPhysiologicalXDF = xdfData;
        
        // æ›´æ–°çŠ¶æ€
        document.getElementById('physiologicalStatus').textContent = 
          `å·²å¯¼å…¥: GSR ${physiologicalData.gsr.length}ç‚¹, PPG ${physiologicalData.ppg.length}ç‚¹`;
        
        // å¯ç”¨è½¬æ¢æŒ‰é’®
        document.getElementById('convertToXdfBtn').disabled = false;
        
        // æ›´æ–°å›¾è¡¨å¹¶è‡ªåŠ¨æ˜¾ç¤º
        if (physiologicalData.gsr.length > 0) {
          chart.updateGSRData(physiologicalData.gsr);
          chart.toggleGSRDisplay(true); // è‡ªåŠ¨æ˜¾ç¤ºGSR
        }
        if (physiologicalData.ppg.length > 0) {
          chart.updatePPGData(physiologicalData.ppg);
          chart.togglePPGDisplay(true); // è‡ªåŠ¨æ˜¾ç¤ºPPG
        }
        
        console.log(`${fileExtension.toUpperCase()}æ•°æ®å¤„ç†æˆåŠŸ:`, {
          gsrPoints: physiologicalData.gsr.length,
          ppgPoints: physiologicalData.ppg.length,
          xdfStreams: xdfData.streams.length
        });
        
      } catch (error) {
        alert(`æ–‡ä»¶å¯¼å…¥å¤±è´¥: ${error.message}`);
        console.error('æ–‡ä»¶è§£æé”™è¯¯:', error);
      }
    });

    // è½¬æ¢å¹¶å¯¼å‡ºXDFæŒ‰é’®
    document.getElementById('convertToXdfBtn').addEventListener('click', () => {
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯å¯¼å‡ºçš„æ•°æ®
      const hasGSR = physiologicalData.gsr && physiologicalData.gsr.length > 0;
      const hasPPG = physiologicalData.ppg && physiologicalData.ppg.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      const hasEmotionData = dataLog && dataLog.some(record => record.face && isFinite(record.valence));
      
      if (!hasGSR && !hasPPG && !hasAnomalies && !hasEmotionData) {
        alert('è¯·å…ˆå¯¼å…¥æ•°æ®æˆ–æ·»åŠ å¼‚å¸¸æ ‡è®°');
        return;
      }
      
      try {
        let xdfData;
        
        // å¦‚æœå·²ç»æœ‰è½¬æ¢å¥½çš„XDFæ•°æ®ï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦åˆ™é‡æ–°è½¬æ¢
        if (window.convertedPhysiologicalXDF) {
          xdfData = window.convertedPhysiologicalXDF;
          
          // å¦‚æœæœ‰æ–°çš„å¼‚å¸¸æ ‡è®°ï¼Œéœ€è¦æ›´æ–°XDFæ•°æ®
          if (manualAnomalyMarks && manualAnomalyMarks.length > 0) {
            xdfData = convertPhysiologicalToXDF(physiologicalData.gsr || [], physiologicalData.ppg || []);
          }
        } else {
          // ä»å½“å‰æ•°æ®é‡æ–°ç”ŸæˆXDFæ ¼å¼
          xdfData = convertPhysiologicalToXDF(physiologicalData.gsr || [], physiologicalData.ppg || []);
        }
        
        // ç›´æ¥å¯¼å‡ºXDFæ–‡ä»¶
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `physiological_data_${timestamp}.xdf`;
        
        exportPhysiologicalXDF(xdfData, filename);
        
        const anomalyCount = manualAnomalyMarks ? manualAnomalyMarks.length : 0;
        alert(`å¯¼å‡ºæˆåŠŸï¼\næ–‡ä»¶å: ${filename}\n- æ•°æ®æµ: ${xdfData.streams.length} ä¸ª\n- GSR: ${physiologicalData.gsr?.length || 0} æ•°æ®ç‚¹\n- PPG: ${physiologicalData.ppg?.length || 0} æ•°æ®ç‚¹\n- æ‰‹åŠ¨å¼‚å¸¸æ ‡è®°: ${anomalyCount} ä¸ª`);
        
        console.log('XDFæ–‡ä»¶å¯¼å‡ºæˆåŠŸ:', xdfData);
        
      } catch (error) {
        alert('XDFå¯¼å‡ºå¤±è´¥: ' + error.message);
        console.error('XDFå¯¼å‡ºé”™è¯¯:', error);
      }
    });

    // å…¨å±€å˜é‡å­˜å‚¨å¼‚å¸¸æ£€æµ‹ç»“æœ
    let netsDetector = null;
    let anomalyResults = null;
    let detectionCancelled = false; // æ£€æµ‹å–æ¶ˆæ ‡å¿—
    let edaPreprocessor = new EDAPreprocessor(); // EDAé¢„å¤„ç†å™¨
    let cleanedGSRData = null; // å­˜å‚¨æ¸…ç†åçš„GSRæ•°æ®

    // æ¸…é™¤å¼‚å¸¸æ£€æµ‹ç»“æœåŠŸèƒ½
    function clearAnomalyResults() {
      anomalyResults = null;
      cleanedGSRData = null; // é‡ç½®æ¸…ç†åçš„æ•°æ®
      netsDetector = null; // é‡ç½®æ£€æµ‹å™¨
      
      // æ¸…é™¤å›¾è¡¨ä¸Šçš„å¼‚å¸¸ç‚¹æ˜¾ç¤ºå’Œæ¸…ç†åæ•°æ®
      if (chart) {
        chart.clearAnomalies();
        clearCleanedData();
      }
    }

    // æ›´æ–°å›¾è¡¨æ˜¾ç¤ºå¼‚å¸¸ç‚¹çš„å‡½æ•°
    function updateChartWithAnomalies() {
      if (!anomalyResults || !chart) return;
      
      // é»˜è®¤æ˜¾ç¤ºå¼‚å¸¸ç‚¹ï¼Œä½¿ç”¨é»˜è®¤å¤§å°
      const pointSize = 8;
      
      // å‡†å¤‡å¼‚å¸¸ç‚¹æ•°æ® - ä½¿ç”¨æ¸…ç†åçš„æ•°æ®æˆ–åŸå§‹æ•°æ®
      const anomalyPoints = anomalyResults.anomalies.map(anomaly => ({
        x: physiologicalData.gsr[anomaly.index]?.time || anomaly.index,
        y: anomaly.value,
        score: anomaly.score,
        entropy: anomaly.entropy
      }));
      
      chart.showAnomalies(anomalyPoints, {
        color: '#ff4444',
        size: pointSize
      });
    }

    // â€”â€” è§†é¢‘æ–‡ä»¶é€‰æ‹©åŠŸèƒ½ â€”â€” //
    let videoSelected = false;
    
    // ç‚¹å‡»é€‰æ‹©è§†é¢‘æŒ‰é’®
    selectVideoBtn.onclick = () => videoInput.click();
    
    // å¤„ç†è§†é¢‘æ–‡ä»¶é€‰æ‹©
    videoInput.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      // éªŒè¯æ–‡ä»¶ç±»å‹
      if (!file.type.startsWith('video/')) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„è§†é¢‘æ–‡ä»¶');
        return;
      }
      
      // åˆ›å»ºæœ¬åœ°URL
      const videoURL = URL.createObjectURL(file);
      
      // è®¾ç½®è§†é¢‘æº
      video.src = videoURL;
      video.style.display = 'block';
      
      // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
      const fileSize = (file.size / 1024 / 1024).toFixed(2);
      videoInfo.textContent = `å·²é€‰æ‹©: ${file.name} (${fileSize}MB)`;
      
      // é‡ç½®çŠ¶æ€
      videoSelected = true;
      analyzed = false;
      dataLog = [];
      originalDataLog = [];
      chart.reset();
      analyzeBtn.disabled = false;
      analyzeBtn.textContent = 'â‘  Analyzeï¼ˆé¢„å¤„ç†ï¼‰';
      downloadBtn.disabled = true;
      statusEl.textContent = '';
      
      // é‡ç½®ç”Ÿç†ä¿¡å·æ•°æ®
      physiologicalData = { gsr: [], ppg: [], startTime: null };
      chart.clearPhysiologicalData();
      document.getElementById('physiologicalStatus').textContent = 'æœªå¯¼å…¥æ•°æ®';
      document.getElementById('convertToXdfBtn').disabled = true;
      
      // é‡ç½®æ•°æ®å¤„ç†çŠ¶æ€
      valenceOffset = 0;
      arousalOffset = 0;
      updateDataProcessingStatus();
      
      // é‡ç½®SDKçŠ¶æ€
      if (sdkInstance) {
        try {
          sdkInstance.stop();
        } catch (e) {
          console.warn('åœæ­¢æ—§SDKå®ä¾‹æ—¶å‡ºé”™:', e);
        }
        sdkInstance = null;
      }
      loaderStarted = false;
      
      console.log(`è§†é¢‘æ–‡ä»¶å·²é€‰æ‹©: ${file.name}, å¤§å°: ${fileSize}MB`);
    };

    // â€”â€” æ•°æ®ä¸çŠ¶æ€ â€”â€” //
    let dataLog = [];
    let originalDataLog = []; // ä¿å­˜åŸå§‹æ•°æ®ï¼Œç”¨äºé‡ç½®
    let analyzed = false;
    let loaderStarted = false;
    let lastFaceDetected = true;
    let lastCaptureTime = 0; // å…¨å±€å£°æ˜
    let currentFrameHasFace = false; // å½“å‰å¸§æ˜¯å¦æ£€æµ‹åˆ°è„¸éƒ¨
    let sdkInstance = null; // SDKå®ä¾‹ï¼Œç”¨äºåœæ­¢

    // æ•°æ®å¤„ç†çŠ¶æ€
    let valenceOffset = 0; // Valenceåç§»é‡
    let arousalOffset = 0; // Arousalåç§»é‡

    // Rate-of-Change å¤„ç†çŠ¶æ€
    let processedDataLog = []; // å¤„ç†åçš„æ•°æ®
    let derivativeDataLog = []; // å¯¼æ•°æ•°æ®
    let eventsLog = []; // æ£€æµ‹åˆ°çš„äº‹ä»¶
    let neurokitProcessed = false; // NeuroKitå¤„ç†çŠ¶æ€
    let anomalyDetected = false; // å¼‚å¸¸æ£€æµ‹çŠ¶æ€
    let cleanedGSRDataPanel = null; // é¢æ¿ä¸­çš„æ¸…ç†åGSRæ•°æ®
    let anomalyResultsPanel = null; // é¢æ¿ä¸­çš„å¼‚å¸¸æ£€æµ‹ç»“æœ
    let processingSteps = {
      step0: false, // åŸºç¡€æ•´ç†
      neurokit: false, // NeuroKité¢„å¤„ç†
      step1: false, // å»ä¼ªè¿¹
      step2: false, // æ ‡å‡†åŒ–
      step3: false, // å¯¼æ•°è®¡ç®—
      step4: false, // å¯¼æ•°åå¤„ç†
      step5: false, // äº‹ä»¶åˆ¤å®š
      nets: false   // å¼‚å¸¸æ£€æµ‹
    };
    let showDerivative = false; // æ˜¯å¦æ˜¾ç¤ºå¯¼æ•°æ›²çº¿
    let showEvents = false; // æ˜¯å¦æ˜¾ç¤ºäº‹ä»¶æ ‡è®°

    // =================== Rate-of-Change æ•°æ®å¤„ç†å‡½æ•° ===================
    
    // ä¸­å€¼æ»¤æ³¢å‡½æ•°
    function medianFilter(series, win = 5) {
      const half = Math.floor(win / 2);
      const out = series.map(v => v);
      for (let i = 0; i < series.length; i++) {
        const w = [];
        for (let k = i - half; k <= i + half; k++) {
          if (k >= 0 && k < series.length) {
            const v = series[k];
            if (Number.isFinite(v)) w.push(v);
          }
        }
        out[i] = w.length ? w.sort((a,b)=>a-b)[Math.floor(w.length/2)] : NaN;
      }
      return out;
    }

    // Z-scoreæ ‡å‡†åŒ–
    function zscore(arr) {
      const vals = arr.filter(Number.isFinite);
      if (vals.length === 0) return arr.map(() => NaN);
      const mu = vals.reduce((s,v)=>s+v,0)/vals.length;
      const sigma = Math.sqrt(vals.reduce((s,v)=>s+(v-mu)*(v-mu),0)/vals.length) || 1;
      return arr.map(v => Number.isFinite(v) ? (v - mu) / sigma : NaN);
    }

    // é²æ£’å¯¼æ•°ï¼ˆæ»‘åŠ¨çº¿æ€§å›å½’æ–œç‡ï¼‰
    function slopeByWindow(t, x, win = 9) {
      const half = Math.floor(win/2);
      const out = Array(x.length).fill(NaN);
      for (let i = 0; i < x.length; i++) {
        const L = Math.max(0, i - half), R = Math.min(x.length - 1, i + half);
        let n=0, sumT=0, sumX=0, sumTT=0, sumTX=0;
        for (let k = L; k <= R; k++) {
          const xi = x[k]; if (!Number.isFinite(xi)) continue;
          const ti = t[k];
          n++; sumT += ti; sumX += xi; sumTT += ti*ti; sumTX += ti*xi;
        }
        const denom = n * sumTT - sumT * sumT;
        if (n >= 2 && denom !== 0) out[i] = (n * sumTX - sumT * sumX) / denom;
      }
      return out;
    }

    // SGå¯¼æ•°ï¼ˆç®€åŒ–ç‰ˆï¼šæ»‘åŠ¨å¤šé¡¹å¼æ‹Ÿåˆï¼‰
    function sgDerivative(t, x, win = 15, poly = 3) {
      const half = Math.floor(win/2);
      const out = Array(x.length).fill(NaN);
      
      for (let i = 0; i < x.length; i++) {
        const L = Math.max(0, i - half), R = Math.min(x.length - 1, i + half);
        const T = [], Y = [];
        const t0 = t[i];
        
        for (let k = L; k <= R; k++) {
          if (!Number.isFinite(x[k])) continue;
          const dt = t[k] - t0;
          const row = [];
          for (let d = 0; d <= poly; d++) row.push(Math.pow(dt, d));
          T.push(row);
          Y.push(x[k]);
        }
        
        if (T.length < poly + 1) continue;
        
        try {
          if (typeof numeric !== 'undefined') {
            const TT = numeric.dot(numeric.transpose(T), T);
            const TY = numeric.dot(numeric.transpose(T), Y);
            const a = numeric.solve(TT, TY);
            out[i] = a[1]; // ä¸€é˜¶å¯¼æ•°ç³»æ•°
          } else {
            // å›é€€åˆ°ç®€å•å·®åˆ†
            if (i > 0 && i < x.length - 1 && Number.isFinite(x[i-1]) && Number.isFinite(x[i+1])) {
              out[i] = (x[i+1] - x[i-1]) / (t[i+1] - t[i-1]);
            }
          }
        } catch (e) {
          // å¦‚æœçŸ©é˜µæ±‚è§£å¤±è´¥ï¼Œå›é€€åˆ°ç®€å•å·®åˆ†
          if (i > 0 && i < x.length - 1 && Number.isFinite(x[i-1]) && Number.isFinite(x[i+1])) {
            out[i] = (x[i+1] - x[i-1]) / (t[i+1] - t[i-1]);
          }
        }
      }
      return out;
    }

    // ç§»åŠ¨å¹³å‡å¹³æ»‘
    function movingAverage(series, win = 3) {
      const half = Math.floor(win / 2);
      const out = Array(series.length).fill(NaN);
      for (let i = 0; i < series.length; i++) {
        let sum = 0, count = 0;
        for (let k = i - half; k <= i + half; k++) {
          if (k >= 0 && k < series.length && Number.isFinite(series[k])) {
            sum += series[k];
            count++;
          }
        }
        out[i] = count > 0 ? sum / count : NaN;
      }
      return out;
    }

    // äº‹ä»¶æ£€æµ‹
    function detectEvents(t, dxdt, up=0.12, dn=-0.12, minDur=0.8) {
      const events = [];
      let state = 0, startIdx = -1;
      
      for (let i = 0; i < dxdt.length; i++) {
        const v = dxdt[i];
        if (!Number.isFinite(v)) continue;

        if (state === 0) {
          if (v >= up) { state = 1; startIdx = i; }
          else if (v <= dn) { state = -1; startIdx = i; }
        } else if (state === 1) {
          if (v < up * 0.5) {
            const dur = t[i] - t[startIdx];
            if (dur >= minDur) events.push({type:'rise', t:t[startIdx], dur, idx: startIdx});
            state = 0; startIdx = -1;
          }
        } else if (state === -1) {
          if (v > dn * 0.5) {
            const dur = t[i] - t[startIdx];
            if (dur >= minDur) events.push({type:'fall', t:t[startIdx], dur, idx: startIdx});
            state = 0; startIdx = -1;
          }
        }
      }
      return events;
    }

    // æ›´æ–°å¤„ç†çŠ¶æ€æ˜¾ç¤º
    function updateProcessingStatus(step, status, message = '') {
      processingSteps[step] = status;
      const statusEl = document.getElementById(`${step}Status`) || document.getElementById(`${step}StatusPanel`);
      if (statusEl) {
        statusEl.textContent = status ? 'âœ“ å·²å®Œæˆ' : 'æœªå¤„ç†';
        statusEl.style.color = status ? '#4caf50' : '#888';
      }
      
      // æ”¯æŒNeuroKitå’ŒNETSçŠ¶æ€å…ƒç´ 
      if (step === 'neurokit') {
        const neurokitStatus = document.getElementById('neurokitStatus');
        if (neurokitStatus) {
          neurokitStatus.textContent = status ? 'âœ“ å·²å®Œæˆ' : 'æœªå¤„ç†';
          neurokitStatus.style.color = status ? '#4caf50' : '#888';
        }
      } else if (step === 'nets') {
        const netsStatus = document.getElementById('netsStatusPanel');
        if (netsStatus) {
          netsStatus.textContent = status ? 'âœ“ å·²å®Œæˆ' : 'æœªå¤„ç†';
          netsStatus.style.color = status ? '#ff6b6b' : '#888';
        }
      }
      
      const mainStatus = document.getElementById('processingStatus');
      if (mainStatus && message) {
        mainStatus.textContent = message;
      }
    }

    // é¢æ¿ä¸­çš„æ¸…ç†åæ•°æ®æ˜¾ç¤ºåŠŸèƒ½
    function updateChartWithCleanedData() {
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„æ¸…ç†åæ•°æ®ï¼ˆä¼˜å…ˆä½¿ç”¨é¢æ¿æ•°æ®ï¼‰
      const cleanedData = cleanedGSRDataPanel || cleanedGSRData;
      const dataSource = cleanedGSRDataPanel ? 'NeuroKit' : 'NETS';
      
      if (!chart || !cleanedData || !physiologicalData.gsr) {
        console.log('chartæˆ–æ¸…ç†åæ•°æ®æœªå‡†å¤‡å¥½');
        return;
      }
      
      try {
        // å‡†å¤‡æ¸…ç†åçš„æ•°æ®ç‚¹
        const cleanedPoints = cleanedData.map((value, idx) => {
          const originalPoint = physiologicalData.gsr[idx];
          return {
            x: originalPoint ? originalPoint.time : idx,
            y: value
          };
        });
        
        // æ ¹æ®æ•°æ®æºè®¾ç½®æ ·å¼
        const isNeuroKit = dataSource === 'NeuroKit';
        const cleanedDataset = {
          label: `GSR (${isNeuroKit ? 'NeuroKitæ¸…ç†' : 'NETSæ¸…ç†'})`,
          data: cleanedPoints,
          borderColor: isNeuroKit ? '#4caf50' : '#ff9800',
          backgroundColor: isNeuroKit ? 'rgba(76, 175, 80, 0.1)' : 'rgba(255, 152, 0, 0.1)',
          borderWidth: 1.5,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 3,
          yAxisID: 'y'
        };
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æ¸…ç†åçš„æ•°æ®é›†ï¼Œç§»é™¤æ—§çš„
        const existingIndices = [];
        chart.data.datasets.forEach((dataset, idx) => {
          if (dataset.label.includes('æ¸…ç†')) {
            existingIndices.push(idx);
          }
        });
        
        // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
        existingIndices.reverse().forEach(idx => {
          chart.data.datasets.splice(idx, 1);
        });
        
        // æ·»åŠ æ–°çš„æ¸…ç†åæ•°æ®é›†
        chart.data.datasets.push(cleanedDataset);
        
        chart.update();
        console.log(`æ˜¾ç¤º${dataSource}æ¸…ç†åçš„GSRæ•°æ®: ${cleanedPoints.length}ä¸ªç‚¹`);
      } catch (error) {
        console.error('æ˜¾ç¤ºæ¸…ç†åæ•°æ®å¤±è´¥:', error);
      }
    }

    // æ¸…é™¤æ¸…ç†åçš„æ•°æ®
    function clearCleanedData() {
      if (!chart) return;
      
      // æŸ¥æ‰¾æ‰€æœ‰æ¸…ç†åçš„æ•°æ®é›†
      const indicesToRemove = [];
      chart.data.datasets.forEach((dataset, index) => {
        if (dataset.label.includes('æ¸…ç†')) {
          indicesToRemove.push(index);
        }
      });
      
      // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
      indicesToRemove.reverse().forEach(index => {
        chart.data.datasets.splice(index, 1);
      });
      
      if (indicesToRemove.length > 0) {
        chart.update();
        console.log(`å·²æ¸…é™¤${indicesToRemove.length}ä¸ªæ¸…ç†åçš„æ•°æ®é›†`);
      }
    }

    // é¢æ¿ä¸­çš„å¼‚å¸¸ç‚¹æ˜¾ç¤ºåŠŸèƒ½
    function updateChartWithAnomaliesPanelData() {
      console.log('updateChartWithAnomaliesPanelData called');
      console.log('anomalyResultsPanel:', anomalyResultsPanel);
      console.log('chart:', chart);
      
      if (!anomalyResultsPanel || !chart) {
        console.log('anomalyResultsPanelæˆ–chartæœªå‡†å¤‡å¥½');
        return;
      }
      
      console.log('anomalyResultsPanel.anomalies:', anomalyResultsPanel.anomalies);
      console.log('anomalies count:', anomalyResultsPanel.anomalies ? anomalyResultsPanel.anomalies.length : 'N/A');
      
      try {
        // è·å–å½“å‰é€‰æ‹©çš„æ•°æ®æº
        const dataSource = document.getElementById('netsDataSourcePanel').value;
        let sourceData;
        let yAxisID = 'y-axis-default'; // é»˜è®¤åæ ‡ç³»
        
        console.log('æ•°æ®æº:', dataSource);
        
        if (dataSource === 'gsr') {
          sourceData = physiologicalData.gsr;
          yAxisID = 'y-axis-gsr';
        } else if (dataSource === 'valence') {
          sourceData = window.valenceData || [];
          yAxisID = 'y-axis-default'; // Valenceä½¿ç”¨é»˜è®¤åæ ‡ç³»
        }
        
        console.log('sourceData length:', sourceData ? sourceData.length : 'N/A');
        console.log('å¼‚å¸¸ç‚¹ç´¢å¼•:', anomalyResultsPanel.anomalies.map(a => a.index));
        
        // å‡†å¤‡å¼‚å¸¸ç‚¹æ•°æ® - æ ¹æ®æ•°æ®æºè·å–æ­£ç¡®çš„åæ ‡
        const anomalyPoints = anomalyResultsPanel.anomalies.map(anomaly => {
          let x, y;
          
          console.log(`å¤„ç†å¼‚å¸¸ç‚¹ç´¢å¼• ${anomaly.index}`);
          
          if (sourceData && sourceData[anomaly.index]) {
            x = sourceData[anomaly.index].time || anomaly.index;
            y = sourceData[anomaly.index].value || anomaly.value;
            console.log(`ä»sourceDataè·å–: x=${x}, y=${y}`);
          } else {
            x = anomaly.index;
            y = anomaly.value;
            console.log(`ä½¿ç”¨anomaly.value: x=${x}, y=${y}`);
          }
          
          console.log(`å¼‚å¸¸ç‚¹ ${anomaly.index}: x=${x}, y=${y}`);
          
          return {
            x: x,
            y: y,
            score: anomaly.score,
            entropy: anomaly.entropy
          };
        });
        
        console.log(`å‡†å¤‡æ˜¾ç¤º${anomalyPoints.length}ä¸ªå¼‚å¸¸ç‚¹ (æ•°æ®æº: ${dataSource}, Yè½´: ${yAxisID})`);
        
        // æ›´æ–°å¼‚å¸¸ç‚¹æ•°æ®é›†çš„Yè½´
        if (chart._datasets && chart._datasets[10]) {
          chart._datasets[10].yAxisID = yAxisID;
          console.log('å¼‚å¸¸ç‚¹æ•°æ®é›†Yè½´å·²è®¾ç½®ä¸º:', yAxisID);
        } else {
          console.error('å¼‚å¸¸ç‚¹æ•°æ®é›†ä¸å­˜åœ¨ chart._datasets[10]');
        }
        
        chart.showAnomalies(anomalyPoints, {
          color: '#ff6b6b',
          size: 6
        });
      } catch (error) {
        console.error('æ˜¾ç¤ºå¼‚å¸¸ç‚¹å¤±è´¥:', error);
      }
    }

    // MorphCast è‡ªå®šä¹‰å¸§æº - æ§åˆ¶å¤„ç†èŠ‚å¥
    const customSource = {
      crtImgData: null,
      resolver: null,
      shouldProcess: true, // æ–°å¢ï¼šæ§åˆ¶æ˜¯å¦å¤„ç†å¸§
      _stopped: false,     // æ·»åŠ åœæ­¢çŠ¶æ€
      analyzeFrame(imgData) {
        if (!this.shouldProcess || this._stopped) return; // è·³è¿‡ä¸éœ€è¦å¤„ç†çš„å¸§
        if (this.resolver) { this.resolver(imgData); this.resolver = null; }
        else { this.crtImgData = imgData; }
      },
      getFrame() {
        if (this._stopped) return Promise.reject(new Error('Source stopped'));
        if (this.crtImgData) { const p = Promise.resolve(this.crtImgData); this.crtImgData = null; return p; }
        return new Promise(res => this.resolver = res);
      },
      start() { 
        this._stopped = false; 
        console.log('è‡ªå®šä¹‰å¸§æºå·²å¯åŠ¨');
      },
      stop() { 
        this._stopped = true; 
        this.shouldProcess = false;
        if (this.resolver) { 
          this.resolver = null; // æ¸…ç†æœªå®Œæˆçš„Promise
        }
        console.log('è‡ªå®šä¹‰å¸§æºå·²åœæ­¢');
      },
      get stopped() { return this._stopped; }
    };

    async function ensureLoader() {
      if (loaderStarted) return;
      loaderStarted = true;

      // ä¼˜å…ˆé¡ºåºï¼šå†™æ­»å¸¸é‡ -> URL ?key= -> localStorage('mc_license')
      const licKey = (LICENSE_KEY && LICENSE_KEY.trim()) || new URLSearchParams(location.search).get('key') || localStorage.getItem('mc_license') || '';
      let builder = CY.loader();
      if (licKey) builder = builder.licenseKey(licKey);
      else console.warn('æœªæä¾› MorphCast license keyï¼ŒSDK å¯èƒ½æ— æ³•åˆå§‹åŒ– (E07)ã€‚å¯åœ¨ LICENSE_KEY å¡«å…¥ï¼Œæˆ–ç”¨ ?key= / localStorage è®¾ç½®ã€‚');

      await builder
        .addModule(CY.modules().FACE_DETECTOR.name) // å…ˆåŠ æ£€æµ‹å™¨
        .addModule(CY.modules().FACE_AROUSAL_VALENCE.name, { smoothness: 0.7 })
        .addModule(CY.modules().FACE_EMOTION.name, { smoothness: 0.4 }) // æ·»åŠ æƒ…ç»ªæ£€æµ‹
        .source(customSource)
        .load()
        .catch((e) => { console.error('SDK åˆå§‹åŒ–å¤±è´¥', e); throw e; })
        .then((result) => { 
          sdkInstance = result; // ä¿å­˜SDKå®ä¾‹
          window.currentCYInstance = result; // ä¹Ÿä¿å­˜åˆ°å…¨å±€å˜é‡ç”¨äºé‡æ–°åˆå§‹åŒ–
          return result.start(); 
        });

      // ä¿®æ­£ FACE_DETECTOR äº‹ä»¶ç›‘å¬å™¨
      window.addEventListener(CY.modules().FACE_DETECTOR.eventName, evt => {
        const detail = evt.detail || {};
        
        // æ ¹æ®æ–‡æ¡£ï¼Œç›´æ¥ä½¿ç”¨ totalFaces å­—æ®µï¼ˆèŒƒå›´ [0,6]ï¼‰
        const totalFaces = detail.totalFaces || 0;
        currentFrameHasFace = totalFaces > 0;
        
        // è°ƒè¯•è¾“å‡ºï¼šæ˜¾ç¤ºæ£€æµ‹ç»“æœ
        console.log(`Face Detection: ${totalFaces} faces detected at time ${(lastCaptureTime || video.currentTime).toFixed(2)}s`);
        
        // æ— è®ºæœ‰æ— è„¸éƒ¨ï¼Œéƒ½è®°å½•ä¸€ä¸ªæ•°æ®ç‚¹ï¼ˆç”¨äºæ ‡è®°æ— è„¸åŒºåŸŸï¼‰
        const t = lastCaptureTime || video.currentTime;
        if (!currentFrameHasFace) {
          // æ— è„¸æ—¶ç›´æ¥è®°å½•ï¼ˆVAäº‹ä»¶ä¸ä¼šè§¦å‘ï¼‰
          dataLog.push({ 
            time: t, 
            arousal: NaN, 
            valence: NaN, 
            face: false
          });
        }
      });

      // VA è¾“å‡ºï¼šåªæœ‰æ£€æµ‹åˆ°è„¸éƒ¨æ—¶æ‰ä¼šè§¦å‘
      window.addEventListener(CY.modules().FACE_AROUSAL_VALENCE.eventName, evt => {
        const out = evt.detail.output;
        const t = lastCaptureTime || video.currentTime;
        
        // è°ƒè¯•è¾“å‡ºï¼šæ˜¾ç¤ºVAæ£€æµ‹ç»“æœ
        console.log(`VA Detection: arousal=${out.arousal.toFixed(3)}, valence=${out.valence.toFixed(3)} at time ${t.toFixed(2)}s`);
        
        // æŸ¥æ‰¾æˆ–åˆ›å»ºå½“å‰æ—¶é—´çš„æ•°æ®è®°å½•
        let dataRecord = dataLog.find(r => Math.abs(r.time - t) < 0.01);
        if (!dataRecord) {
          dataRecord = { 
            time: t, 
            arousal: out.arousal, 
            valence: out.valence, 
            face: true,
            emotions: {},
            dominantEmotion: undefined
          };
          dataLog.push(dataRecord);
        } else {
          dataRecord.arousal = out.arousal;
          dataRecord.valence = out.valence;
          dataRecord.face = true;
        }
      });

      // æƒ…ç»ªæ£€æµ‹è¾“å‡º
      window.addEventListener(CY.modules().FACE_EMOTION.eventName, evt => {
        if (!emotionDetectionEnabled) return;
        
        const out = evt.detail.output;
        const t = lastCaptureTime || video.currentTime;
        
        // è°ƒè¯•è¾“å‡ºï¼šæ˜¾ç¤ºæƒ…ç»ªæ£€æµ‹ç»“æœ
        console.log(`Emotion Detection at time ${t.toFixed(2)}s:`, out);
        
        // æŸ¥æ‰¾æˆ–åˆ›å»ºå½“å‰æ—¶é—´çš„æ•°æ®è®°å½•
        let dataRecord = dataLog.find(r => Math.abs(r.time - t) < 0.01);
        if (!dataRecord) {
          dataRecord = { 
            time: t, 
            arousal: NaN, 
            valence: NaN, 
            face: true,
            emotions: out.emotion,
            dominantEmotion: out.dominantEmotion
          };
          dataLog.push(dataRecord);
        } else {
          dataRecord.emotions = out.emotion;
          dataRecord.dominantEmotion = out.dominantEmotion;
          dataRecord.face = true;
        }
      });
    }

    // è·å–ç”¨æˆ·é…ç½®çš„æ£€æµ‹åŒºåŸŸ
    function getDetectionRegion() {
      const overlay = document.getElementById('regionOverlay');
      
      // å¦‚æœåŒºåŸŸæ£€æµ‹æœªå¯ç”¨ï¼Œè¿”å›å…¨å±
      if (overlay.style.display === 'none' || overlay.style.display === '') {
        return {
          x: 0,
          y: 0,
          width: video.videoWidth,
          height: video.videoHeight
        };
      }
      
      // ä»è¦†ç›–å±‚è·å–åŒºåŸŸä¿¡æ¯
      const scaleX = video.videoWidth / video.clientWidth;
      const scaleY = video.videoHeight / video.clientHeight;
      
      // ç›´æ¥ä»styleå±æ€§è·å–ä½ç½®å’Œå°ºå¯¸
      const overlayLeft = parseInt(overlay.style.left) || 0;
      const overlayTop = parseInt(overlay.style.top) || 0;
      const overlayWidth = parseInt(overlay.style.width) || 0;
      const overlayHeight = parseInt(overlay.style.height) || 0;
      
      const region = {
        x: Math.floor(overlayLeft * scaleX),
        y: Math.floor(overlayTop * scaleY),
        width: Math.floor(overlayWidth * scaleX),
        height: Math.floor(overlayHeight * scaleY)
      };
      
      // è¾¹ç•Œæ£€æŸ¥
      region.x = Math.max(0, Math.min(region.x, video.videoWidth - 1));
      region.y = Math.max(0, Math.min(region.y, video.videoHeight - 1));
      region.width = Math.max(1, Math.min(region.width, video.videoWidth - region.x));
      region.height = Math.max(1, Math.min(region.height, video.videoHeight - region.y));
      
      return region;
    }

    // åŒºåŸŸæ£€æµ‹åŠŸèƒ½
    let regionEnabled = false;

    function toggleRegion() {
      // å¦‚æœå·²ç»åˆ†æè¿‡ï¼Œæˆ–è€…SDKå·²ç»åˆå§‹åŒ–ï¼Œåˆ™åˆ·æ–°é¡µé¢
      if (analyzed || loaderStarted || sdkInstance) {
        console.log('æ£€æµ‹åˆ°SDKçŠ¶æ€ï¼Œåˆ·æ–°é¡µé¢ä»¥é‡ç½®...');
        location.reload();
        return;
      }
      
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      const btn = document.getElementById('toggleRegion');
      const info = document.getElementById('regionInfo');
      
      regionEnabled = !regionEnabled;
      
      if (regionEnabled) {
        // å¯ç”¨åŒºåŸŸæ£€æµ‹
        btn.textContent = 'ç¦ç”¨åŒºåŸŸæ£€æµ‹';
        info.textContent = 'æ‹–æ‹½çº¢æ¡†ç§»åŠ¨ä½ç½®ï¼Œæ‹–æ‹½å³ä¸‹è§’çº¢ç‚¹è°ƒæ•´å¤§å°';
        info.style.color = '#4caf50';
        
        // ç¡®ä¿è§†é¢‘å·²åŠ è½½
        if (!video.videoWidth || !video.videoHeight) {
          alert('è¯·ç­‰å¾…è§†é¢‘åŠ è½½å®Œæˆåå†å¯ç”¨åŒºåŸŸæ£€æµ‹');
          regionEnabled = false;
          btn.textContent = 'å¯ç”¨åŒºåŸŸæ£€æµ‹';
          info.textContent = 'ç‚¹å‡»å¯ç”¨åå¯åœ¨è§†é¢‘ä¸Šæ‹–æ‹½é€‰æ‹©æ£€æµ‹åŒºåŸŸ';
          info.style.color = '#ccc';
          return;
        }
        
        // æ˜¾ç¤ºé»˜è®¤åŒºåŸŸï¼ˆè§†é¢‘ä¸­å¿ƒ50%x60%ï¼‰
        const videoRect = video.getBoundingClientRect();
        const defaultWidth = Math.floor(videoRect.width * 0.5);
        const defaultHeight = Math.floor(videoRect.height * 0.6);
        const defaultLeft = Math.floor(videoRect.width * 0.25);
        const defaultTop = Math.floor(videoRect.height * 0.1);
        
        overlay.style.display = 'block';
        overlay.style.left = defaultLeft + 'px';
        overlay.style.top = defaultTop + 'px';
        overlay.style.width = defaultWidth + 'px';
        overlay.style.height = defaultHeight + 'px';
        overlay.style.pointerEvents = 'auto';
        overlay.style.cursor = 'move';
        
        handle.style.display = 'block';
        handle.style.left = (defaultLeft + defaultWidth - 6) + 'px';
        handle.style.top = (defaultTop + defaultHeight - 6) + 'px';
        handle.style.cursor = 'se-resize';
        
        // è¾“å‡ºåˆå§‹åŒºåŸŸä¿¡æ¯
        setTimeout(() => {
          const region = getDetectionRegion();
          console.log('åŒºåŸŸæ£€æµ‹å·²å¯ç”¨ï¼Œåˆå§‹åŒºåŸŸ:');
          console.log(`  è§†é¢‘å°ºå¯¸: ${video.videoWidth}x${video.videoHeight}`);
          console.log(`  æ£€æµ‹åŒºåŸŸ: ${region.x}x${region.y} ${region.width}x${region.height}`);
          console.log(`  è¦†ç›–ç‡: ${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}%`);
          
          info.textContent = `æ£€æµ‹åŒºåŸŸ: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% è¦†ç›–)`;
        }, 100);
        
      } else {
        // ç¦ç”¨åŒºåŸŸæ£€æµ‹
        btn.textContent = 'å¯ç”¨åŒºåŸŸæ£€æµ‹';
        info.textContent = 'ç‚¹å‡»å¯ç”¨åå¯åœ¨è§†é¢‘ä¸Šæ‹–æ‹½é€‰æ‹©æ£€æµ‹åŒºåŸŸ';
        info.style.color = '#ccc';
        
        overlay.style.display = 'none';
        handle.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        
        console.log('åŒºåŸŸæ£€æµ‹å·²ç¦ç”¨ï¼Œå°†ä½¿ç”¨å…¨å±æ£€æµ‹');
      }
    }

    // åˆå§‹åŒ–åŒºåŸŸæ‹–æ‹½åŠŸèƒ½
    function initRegionDragHandlers() {
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      
      let isDraggingOverlay = false;
      let isDraggingHandle = false;
      let startX, startY, startLeft, startTop, startWidth, startHeight;
      
      // è¦†ç›–å±‚æ‹–æ‹½ï¼ˆç§»åŠ¨ä½ç½®ï¼‰
      overlay.addEventListener('mousedown', (e) => {
        if (!regionEnabled) return;
        
        isDraggingOverlay = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(overlay.style.left) || 0;
        startTop = parseInt(overlay.style.top) || 0;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      // æ‹–æ‹½æ§åˆ¶ç‚¹ï¼ˆè°ƒæ•´å¤§å°ï¼‰
      handle.addEventListener('mousedown', (e) => {
        if (!regionEnabled) return;
        
        isDraggingHandle = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(overlay.style.width) || 0;
        startHeight = parseInt(overlay.style.height) || 0;
        startLeft = parseInt(overlay.style.left) || 0;
        startTop = parseInt(overlay.style.top) || 0;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
      document.addEventListener('mousemove', (e) => {
        if (!regionEnabled) return;
        
        const videoRect = video.getBoundingClientRect();
        
        if (isDraggingOverlay) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          let newLeft = startLeft + deltaX;
          let newTop = startTop + deltaY;
          
          // è¾¹ç•Œé™åˆ¶
          const overlayWidth = parseInt(overlay.style.width) || 0;
          const overlayHeight = parseInt(overlay.style.height) || 0;
          
          newLeft = Math.max(0, Math.min(newLeft, videoRect.width - overlayWidth));
          newTop = Math.max(0, Math.min(newTop, videoRect.height - overlayHeight));
          
          overlay.style.left = newLeft + 'px';
          overlay.style.top = newTop + 'px';
          
          // æ›´æ–°æ‹–æ‹½æ§åˆ¶ç‚¹ä½ç½®
          updateHandlePosition();
          
          e.preventDefault();
        }
        
        if (isDraggingHandle) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          let newWidth = startWidth + deltaX;
          let newHeight = startHeight + deltaY;
          
          // æœ€å°å°ºå¯¸é™åˆ¶
          newWidth = Math.max(50, newWidth);
          newHeight = Math.max(50, newHeight);
          
          // è¾¹ç•Œé™åˆ¶
          const currentLeft = parseInt(overlay.style.left) || 0;
          const currentTop = parseInt(overlay.style.top) || 0;
          
          newWidth = Math.min(newWidth, videoRect.width - currentLeft);
          newHeight = Math.min(newHeight, videoRect.height - currentTop);
          
          overlay.style.width = newWidth + 'px';
          overlay.style.height = newHeight + 'px';
          
          // æ›´æ–°æ‹–æ‹½æ§åˆ¶ç‚¹ä½ç½®
          updateHandlePosition();
          
          e.preventDefault();
        }
      });
      
      // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
      document.addEventListener('mouseup', () => {
        if (isDraggingOverlay || isDraggingHandle) {
          isDraggingOverlay = false;
          isDraggingHandle = false;
          
          // è¾“å‡ºå½“å‰åŒºåŸŸä¿¡æ¯
          logCurrentRegion();
        }
      });
      
      // æ›´æ–°æ‹–æ‹½æ§åˆ¶ç‚¹ä½ç½®
      function updateHandlePosition() {
        const overlayLeft = parseInt(overlay.style.left) || 0;
        const overlayTop = parseInt(overlay.style.top) || 0;
        const overlayWidth = parseInt(overlay.style.width) || 0;
        const overlayHeight = parseInt(overlay.style.height) || 0;
        
        handle.style.left = (overlayLeft + overlayWidth - 6) + 'px';
        handle.style.top = (overlayTop + overlayHeight - 6) + 'px';
      }
      
      // è¾“å‡ºå½“å‰åŒºåŸŸä¿¡æ¯
      function logCurrentRegion() {
        const region = getDetectionRegion();
        const videoRect = video.getBoundingClientRect();
        
        console.log('æ£€æµ‹åŒºåŸŸå·²æ›´æ–°:');
        console.log(`  æ˜¾ç¤ºåŒºåŸŸ: ${parseInt(overlay.style.left)}x${parseInt(overlay.style.top)} ${parseInt(overlay.style.width)}x${parseInt(overlay.style.height)}`);
        console.log(`  è§†é¢‘åæ ‡: ${region.x}x${region.y} ${region.width}x${region.height}`);
        console.log(`  è¦†ç›–ç‡: ${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}%`);
        
        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        const info = document.getElementById('regionInfo');
        info.textContent = `æ£€æµ‹åŒºåŸŸ: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% è¦†ç›–)`;
      }
    }

    function waitForVideoReady(v) {
      return new Promise(res => {
        if (v.videoWidth && v.videoHeight) return res();
        const tm = setInterval(() => {
          if (v.videoWidth && v.videoHeight) { clearInterval(tm); res(); }
        }, 100);
      });
    }

    // DeepFace API è°ƒç”¨å‡½æ•°
    async function analyzeFrameWithDeepFace(canvas) {
      try {
        // å°† canvas è½¬æ¢ä¸º base64
        const dataURL = canvas.toDataURL('image/jpeg', 0.8);
        
        // è°ƒç”¨ DeepFace API
        const response = await fetch(`${deepfaceApiUrl}/analyze`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            img: dataURL,
            enforce_detection: false
          })
        });
        
        if (!response.ok) {
          throw new Error(`DeepFace API é”™è¯¯: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.status === 'success' && result.face) {
          return {
            valence: result.valence_arousal.valence,
            arousal: result.valence_arousal.arousal,
            emotions: result.emotions,
            dominant_emotion: result.dominant_emotion,
            face: true
          };
        } else {
          console.warn('DeepFace åˆ†æå¤±è´¥:', result.message || 'æœªæ£€æµ‹åˆ°é¢éƒ¨');
          return { face: false };
        }
      } catch (error) {
        console.error('DeepFace API è°ƒç”¨å¤±è´¥:', error);
        return { face: false };
      }
    }

    // ç»Ÿä¸€çš„å¸§åˆ†æå‡½æ•°
    async function analyzeFrame(imgData, canvas) {
      if (currentAPI === 'deepface') {
        return await analyzeFrameWithDeepFace(canvas);
      } else {
        // ä½¿ç”¨ MorphCast
        customSource.analyzeFrame(imgData);
        return null; // MorphCast é€šè¿‡äº‹ä»¶å¼‚æ­¥è¿”å›ç»“æœ
      }
    }

    // â€”â€” é˜¶æ®µ 1ï¼šé¢„å¤„ç† â€”â€” //
    analyzeBtn.onclick = async () => {
      // æ£€æŸ¥æ˜¯å¦å·²é€‰æ‹©è§†é¢‘
      if (!videoSelected || !video.src) {
        alert('è¯·å…ˆé€‰æ‹©è§†é¢‘æ–‡ä»¶');
        return;
      }
      
      // æ£€æŸ¥ API è¿æ¥çŠ¶æ€
      if (!apiConnected) {
        alert(`${currentAPI === 'deepface' ? 'DeepFace' : 'MorphCast'} API æœªè¿æ¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡çŠ¶æ€`);
        return;
      }
      
      // ç«‹å³ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
      analyzeBtn.disabled = true;
      analyzeBtn.textContent = 'å¤„ç†ä¸­...';
      
      // åªæœ‰ MorphCast éœ€è¦åŠ è½½ SDK
      if (currentAPI === 'morphcast') {
        await ensureLoader();
      }
      analyzed = false;
      dataLog = [];
      chart.reset();
      statusEl.textContent = 'Analyzing...';

      await waitForVideoReady(video);

      const oldRate = video.playbackRate;
      const oldControls = video.controls;
      const oldCurrentTime = video.currentTime;
      video.muted = true;
      video.controls = false;
      video.playbackRate = 1.0;

      // çœŸæ­£çš„æŒ‰å¸§æŠ“å–æ¨¡å¼ï¼šåŸºäºå¸§åºå·è®¡ç®—ç²¾ç¡®æ—¶é—´
      const duration = video.duration;
      const everyN = parseInt(frameIntervalInput.value) || 10; // ä»ç”¨æˆ·è¾“å…¥è·å–æŠ½å¸§é—´éš”ï¼Œé»˜è®¤10å¸§
      
      // å°è¯•è·å–è§†é¢‘çœŸå®å¸§ç‡ï¼Œå¦‚æœè·å–ä¸åˆ°åˆ™æŠ›å‡ºé”™è¯¯
      let fps = null;
      let fpsDetected = false;
      
      try {
        // æ–¹æ³•1ï¼šé€šè¿‡videoTracks APIè·å–å¸§ç‡
        if (video.videoTracks && video.videoTracks.length > 0) {
          const track = video.videoTracks[0];
          if (track.frameRate) {
            fps = track.frameRate;
            fpsDetected = true;
            console.log(`ä»videoTracksè·å–å¸§ç‡: ${fps}fps`);
          }
        }
        // æ–¹æ³•2ï¼šé€šè¿‡captureStream APIä¼°ç®—ï¼ˆå¤‡ç”¨ï¼‰
        if (!fpsDetected && video.captureStream) {
          try {
            const stream = video.captureStream();
            const videoTrack = stream.getVideoTracks()[0];
            const settings = videoTrack.getSettings();
            if (settings.frameRate) {
              fps = settings.frameRate;
              fpsDetected = true;
              console.log(`ä»captureStreamè·å–å¸§ç‡: ${fps}fps`);
            }
          } catch (e) {
            // å¿½ç•¥captureStreamé”™è¯¯
          }
        }
        // å¦‚æœéƒ½è·å–ä¸åˆ°ï¼ŒæŠ›å‡ºé”™è¯¯
        if (!fpsDetected) {
          throw new Error('æ— æ³•è·å–è§†é¢‘å¸§ç‡ï¼Œè¯·æ£€æŸ¥è§†é¢‘æ–‡ä»¶');
        }
      } catch (e) {
        console.error('è·å–è§†é¢‘å¸§ç‡å¤±è´¥:', e);
        alert('æ— æ³•è·å–è§†é¢‘å¸§ç‡ï¼Œåˆ†æå¯èƒ½ä¸å‡†ç¡®ã€‚å»ºè®®å°è¯•å…¶ä»–è§†é¢‘æ–‡ä»¶ã€‚');
        // ä½¿ç”¨ä¸€ä¸ªä¿å®ˆçš„é»˜è®¤å€¼ï¼Œä½†è¦æ˜ç¡®å‘ŠçŸ¥ç”¨æˆ·
        fps = 25;
        console.warn(`ä½¿ç”¨ä¿å®ˆé»˜è®¤å¸§ç‡: ${fps}fps`);
      }
      
      // è®¡ç®—è§†é¢‘æ€»å¸§æ•°å’Œè¦å¤„ç†çš„å¸§åºå·
      const totalVideoFrames = Math.floor(duration * fps);
      const frameNumbers = [];
      for (let frameNum = 0; frameNum < totalVideoFrames; frameNum += everyN) {
        frameNumbers.push(frameNum);
      }
      
      console.log(`å¼€å§‹é¢„å¤„ç†ï¼šè§†é¢‘æ—¶é•¿ ${duration.toFixed(1)}sï¼Œ${fps}fpsï¼Œæ€»å¸§æ•° ${totalVideoFrames}ï¼Œæ¯${everyN}å¸§æŠ“ä¸€å¸§ï¼Œéœ€å¤„ç† ${frameNumbers.length} å¸§`);
      console.log(`å¤„ç†å¸§åºå·: [${frameNumbers.slice(0, 5).join(', ')}${frameNumbers.length > 5 ? '...' : ''}]`);
      
      let frameCount = 0;
      const startTime = performance.now();

      // é¢„å¤„ç†å‡½æ•°ï¼šç›´æ¥è·³è½¬åˆ°æŒ‡å®šå¸§çš„ç²¾ç¡®æ—¶é—´
      const processFrame = (frameNumber) => {
        return new Promise((resolve) => {
          const exactTime = frameNumber / fps; // ç²¾ç¡®çš„å¸§æ—¶é—´æˆ³
          
          const onSeeked = async () => {
            video.removeEventListener('seeked', onSeeked);
            
            // æŠ“å–å½“å‰å¸§ï¼ˆä½¿ç”¨åŒºåŸŸæ£€æµ‹ï¼‰
            lastCaptureTime = exactTime; // ä½¿ç”¨è®¡ç®—å‡ºçš„ç²¾ç¡®æ—¶é—´ï¼Œä¸æ˜¯video.currentTime
            
            console.log(`ğŸ¯ Processing frame ${frameNumber} at time ${exactTime.toFixed(3)}s`);
            
            // æ¯æ¬¡éƒ½é‡æ–°è·å–åŒºåŸŸé…ç½®ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°çŠ¶æ€
            const region = getDetectionRegion();
            
            // æ¯æ¬¡éƒ½é‡æ–°è°ƒæ•´canvaså°ºå¯¸ä»¥åŒ¹é…å½“å‰åŒºåŸŸè®¾ç½®
            grabCanvas.width = region.width;
            grabCanvas.height = region.height;
            
            // æ¸…ç©ºcanvasç¡®ä¿å¹²å‡€ç»˜åˆ¶
            grabCtx.clearRect(0, 0, grabCanvas.width, grabCanvas.height);
            
            // åªç»˜åˆ¶æŒ‡å®šåŒºåŸŸ
            grabCtx.drawImage(
              video,                          // æºè§†é¢‘
              region.x,                       // æºxåæ ‡
              region.y,                       // æºyåæ ‡
              region.width,                   // æºå®½åº¦
              region.height,                  // æºé«˜åº¦
              0,                              // ç›®æ ‡xï¼ˆcanvaså·¦ä¸Šè§’ï¼‰
              0,                              // ç›®æ ‡yï¼ˆcanvaså·¦ä¸Šè§’ï¼‰
              region.width,                   // ç›®æ ‡å®½åº¦
              region.height                   // ç›®æ ‡é«˜åº¦
            );
            
            const imgData = grabCtx.getImageData(0, 0, grabCanvas.width, grabCanvas.height);
            
            // æ ¹æ®é€‰æ‹©çš„ API è¿›è¡Œåˆ†æ
            if (currentAPI === 'deepface') {
              const result = await analyzeFrame(imgData, grabCanvas);
              if (result && result.face) {
                // ç›´æ¥æ·»åŠ åˆ°æ•°æ®æ—¥å¿—ä¸­
                const dataPoint = {
                  time: exactTime,
                  valence: result.valence,
                  arousal: result.arousal,
                  face: true
                };
                
                // å¦‚æœå¯ç”¨äº†æƒ…ç»ªæ£€æµ‹ï¼Œæ·»åŠ æƒ…ç»ªæ•°æ®
                if (emotionDetectionEnabled && result.emotions) {
                  dataPoint.emotions = result.emotions;
                  dataPoint.dominantEmotion = result.dominant_emotion;
                  
                  // æ·»åŠ 7ç§åŸºç¡€æƒ…ç»ªæ•°æ®
                  Object.assign(dataPoint, result.emotions);
                }
                
                dataLog.push(dataPoint);
                console.log(`DeepFace ç»“æœ @${exactTime.toFixed(3)}s:`, result);
              } else {
                dataLog.push({ time: exactTime, face: false });
              }
            } else {
              // ä½¿ç”¨ MorphCast
              customSource.analyzeFrame(imgData);
            }
            
            frameCount++;
            const progress = ((frameCount / frameNumbers.length) * 100).toFixed(1);
            statusEl.textContent = `åˆ†æä¸­... ${progress}% (${frameCount}/${frameNumbers.length}) - å¸§${frameNumber}/${totalVideoFrames}@${exactTime.toFixed(3)}s [${fps}fps]`;
            
            resolve();
          };
          
          video.addEventListener('seeked', onSeeked);
          video.currentTime = exactTime;
        });
      };

      // é€å¸§å¤„ç†ï¼šæŒ‰å¸§åºå·é¡ºåºå¤„ç†
      try {
        for (const frameNumber of frameNumbers) {
          await processFrame(frameNumber);
          
          // ç»™SDKä¸€ç‚¹æ—¶é—´å¤„ç†ï¼ˆå¯é€‰ï¼Œé¿å…è¿‡å¿«ï¼‰
          await new Promise(resolve => setTimeout(resolve, 50));
        }

        // å¤„ç†å®Œæˆï¼Œæ•´ç†æ•°æ®
        dataLog.sort((a, b) => a.time - b.time);
        const clean = [];
        let prev = -Infinity;
        for (const r of dataLog) {
          const hasVA = isFinite(r.arousal) && isFinite(r.valence);
          const hasFaceInfo = typeof r.face === 'boolean';
          if (r.time >= prev && (hasVA || hasFaceInfo)) {
            clean.push(r);
            prev = r.time;
          }
        }
        dataLog = clean;

        // ä¿å­˜åŸå§‹æ•°æ®
        originalDataLog = dataLog.map(r => ({ ...r }));

        analyzed = true;
        statusEl.textContent = `åˆ†æå®Œæˆï¼å…± ${dataLog.length} ç‚¹ï¼Œç”¨æ—¶: ${((performance.now() - startTime) / 1000).toFixed(1)}s`;
        
        // æ›´æ–°å¯¼å‡ºæŒ‰é’®çŠ¶æ€
        updateEmotionXDFExportButtonState();
        
        // ä¿æŒåˆ†ææŒ‰é’®æ°¸ä¹…ç¦ç”¨ï¼Œé˜²æ­¢é‡å¤åˆ†æ
        analyzeBtn.disabled = true;
        analyzeBtn.textContent = 'å·²å®Œæˆåˆ†æ';

        // åœæ­¢è‡ªå®šä¹‰å¸§æºå’ŒSDKå®ä¾‹
        console.log('åœæ­¢å¸§æºå¤„ç†...');
        customSource.stop();
        
        // åœæ­¢SDKå®ä¾‹ï¼Œé‡Šæ”¾èµ„æº
        if (sdkInstance) {
          try {
            sdkInstance.stop();
            console.log('SDKå®ä¾‹å·²åœæ­¢');
          } catch (e) {
            console.warn('åœæ­¢SDKæ—¶å‡ºé”™:', e);
          }
          sdkInstance = null;
        }
        
        // é‡ç½®loaderçŠ¶æ€ï¼Œä»¥ä¾¿ä¸‹æ¬¡é‡æ–°åˆå§‹åŒ–
        loaderStarted = false;
        console.log('åˆ†æå®Œæˆï¼ŒSDKå·²å…³é—­');

        // åŠ è½½æ•°æ®åˆ°å›¾è¡¨
        loadAllDataToChart();

      } catch (error) {
        console.error('é¢„å¤„ç†å‡ºé”™:', error);
        statusEl.textContent = 'åˆ†æå¤±è´¥';
        // å³ä½¿å‡ºé”™ä¹Ÿä¿æŒæŒ‰é’®ç¦ç”¨ï¼Œé˜²æ­¢é‡å¤å°è¯•
        analyzeBtn.disabled = true;
        analyzeBtn.textContent = 'åˆ†æå¤±è´¥';
      } finally {
        // æ¢å¤è§†é¢‘çŠ¶æ€
        video.playbackRate = oldRate;
        video.controls = oldControls;
        video.muted = false;
        video.currentTime = oldCurrentTime;
      }
    };

    // â€”â€” å¯¼å‡º XDF â€”â€” //
    downloadBtn.onclick = () => {
      if (dataLog.length === 0) { alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®'); return; }
      
      console.log(`ğŸ“¤ å¼€å§‹å¯¼å‡ºæƒ…ç»ªXDFæ•°æ®...`);
      console.log(`ğŸ“Š å½“å‰çŠ¶æ€:`, {
        æ•°æ®ç‚¹æ•°é‡: dataLog.length,
        å¼‚å¸¸æ ‡è®°æ•°é‡: manualAnomalyMarks ? manualAnomalyMarks.length : 0,
        æƒ…ç»ªæ£€æµ‹å¯ç”¨: emotionDetectionEnabled
      });
      
      try {
        // ä½¿ç”¨XDFæ ¼å¼å¤„ç†å™¨å¯¼å‡º
        const xdfData = xdfFormatter.exportToXDF(dataLog, emotionDetectionEnabled, emotionNames);
        
        console.log(`âœ… XDFæ•°æ®ç”ŸæˆæˆåŠŸ:`, {
          æ•°æ®æµæ•°é‡: xdfData.streams.length,
          æ•°æ®æµåç§°: xdfData.streams.map(s => s.info.name)
        });
        
        const xdfContent = JSON.stringify(xdfData, null, 2);
        const blob = new Blob([xdfContent], { type: 'application/json;charset=utf-8;' });
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        const timestamp = new Date().toISOString().slice(0,16).replace(/[:-]/g,'');
        const filename = `emotion_analysis_${timestamp}.xdf`;
        a.download = filename;
        a.style.display = 'none';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        
        console.log(`XDFæ•°æ®å·²å¯¼å‡º: ${filename}`);
        statusEl.textContent += ` | XDFå·²å¯¼å‡ºï¼š${dataLog.length}ä¸ªæ•°æ®ç‚¹`;
        
      } catch (error) {
        console.error('XDF export failed:', error);
        alert('XDF å¯¼å‡ºå¤±è´¥ï¼š' + error.message);
      }
    };

    // â€”â€” å¯¼å…¥ XDF å›æ”¾ â€”â€” //
    importBtn.onclick = () => xdfInput.click();

    // â€”â€” åŒºåŸŸæ£€æµ‹åˆ‡æ¢ â€”â€” //
    const toggleBtn = document.getElementById('toggleRegion');
    toggleBtn.onclick = () => toggleRegion();

    // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
    document.addEventListener('keydown', (e) => {
      if (!regionEnabled) return;
      
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      const step = e.shiftKey ? 10 : 1; // Shifté”®åŠ é€Ÿç§»åŠ¨
      
      let currentLeft = parseInt(overlay.style.left) || 0;
      let currentTop = parseInt(overlay.style.top) || 0;
      let currentWidth = parseInt(overlay.style.width) || 0;
      let currentHeight = parseInt(overlay.style.height) || 0;
      
      const videoRect = video.getBoundingClientRect();
      
      switch(e.key) {
        case 'ArrowLeft':
          currentLeft = Math.max(0, currentLeft - step);
          overlay.style.left = currentLeft + 'px';
          e.preventDefault();
          break;
        case 'ArrowRight':
          currentLeft = Math.min(videoRect.width - currentWidth, currentLeft + step);
          overlay.style.left = currentLeft + 'px';
          e.preventDefault();
          break;
        case 'ArrowUp':
          currentTop = Math.max(0, currentTop - step);
          overlay.style.top = currentTop + 'px';
          e.preventDefault();
          break;
        case 'ArrowDown':
          currentTop = Math.min(videoRect.height - currentHeight, currentTop + step);
          overlay.style.top = currentTop + 'px';
          e.preventDefault();
          break;
        case '+':
        case '=':
          // æ”¾å¤§åŒºåŸŸ
          const newWidth = Math.min(videoRect.width - currentLeft, currentWidth + step * 5);
          const newHeight = Math.min(videoRect.height - currentTop, currentHeight + step * 5);
          overlay.style.width = newWidth + 'px';
          overlay.style.height = newHeight + 'px';
          e.preventDefault();
          break;
        case '-':
          // ç¼©å°åŒºåŸŸ
          const minSize = 50;
          overlay.style.width = Math.max(minSize, currentWidth - step * 5) + 'px';
          overlay.style.height = Math.max(minSize, currentHeight - step * 5) + 'px';
          e.preventDefault();
          break;
      }
      
      // æ›´æ–°æ‹–æ‹½æ§åˆ¶ç‚¹ä½ç½®
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', '+', '=', '-'].includes(e.key)) {
        const newLeft = parseInt(overlay.style.left) || 0;
        const newTop = parseInt(overlay.style.top) || 0;
        const newWidth = parseInt(overlay.style.width) || 0;
        const newHeight = parseInt(overlay.style.height) || 0;
        
        handle.style.left = (newLeft + newWidth - 6) + 'px';
        handle.style.top = (newTop + newHeight - 6) + 'px';
        
        // è¾“å‡ºåŒºåŸŸä¿¡æ¯
        const region = getDetectionRegion();
        const info = document.getElementById('regionInfo');
        info.textContent = `æ£€æµ‹åŒºåŸŸ: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% è¦†ç›–)`;
      }
    });

    // ç¡®ä¿æ•°æ®å®Œæ•´æ€§
    function loadAllDataToChart() {
      const valenceData = [];
      const arousalData = [];
      const noFaceData = [];

      for (const r of dataLog) {
        if (r.face) {
          // åªæœ‰å½“å€¼æ˜¯æœ‰é™æ•°å­—æ—¶æ‰æ·»åŠ åˆ°å¯¹åº”çš„æ•°æ®é›†
          if (isFinite(r.valence)) valenceData.push({ x: r.time, y: r.valence });
          if (isFinite(r.arousal)) arousalData.push({ x: r.time, y: r.arousal });
        } else {
          noFaceData.push({ x: r.time, y: 1 });
        }
      }

      chart._datasets[0].data = valenceData;
      chart._datasets[1].data = arousalData;
      chart._datasets[2].data = noFaceData;
      
      // åŒæ—¶æ›´æ–°GSRæ•°æ®
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0 && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
      }
      
      chart._chart.update();
      
      // åŠ è½½æƒ…ç»ªæ•°æ®åˆ°æƒ…ç»ªå›¾è¡¨
      if (emotionChart && emotionDetectionEnabled) {
        loadEmotionDataToChart();
      }
      
      // æ›´æ–°XDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
    }

    // åŠ è½½æƒ…ç»ªæ•°æ®åˆ°æƒ…ç»ªå›¾è¡¨
    function loadEmotionDataToChart() {
      // åˆå§‹åŒ–æ¯ä¸ªæƒ…ç»ªçš„æ•°æ®æ•°ç»„
      emotionNames.forEach((emotion, index) => {
        emotionChart.data.datasets[index].data = [];
      });

      // å¡«å……æƒ…ç»ªæ•°æ®
      for (const r of dataLog) {
        if (r.face && r.emotions) {
          emotionNames.forEach((emotion, index) => {
            if (r.emotions[emotion] !== undefined) {
              emotionChart.data.datasets[index].data.push({ 
                x: r.time, 
                y: r.emotions[emotion] 
              });
            }
          });
        }
      }

      // åŒæ­¥æ—¶é—´è½´èŒƒå›´
      const vaXAxis = chart._config.options.scales.xAxes[0];
      emotionChart.options.scales.xAxes[0].ticks.min = vaXAxis.ticks.min;
      emotionChart.options.scales.xAxes[0].ticks.max = vaXAxis.ticks.max;
      
      emotionChart.update();
    }

    // æ›´æ–°å½“å‰æƒ…ç»ªæ˜¾ç¤º
    function updateCurrentEmotionDisplay(currentTime) {
      // æŸ¥æ‰¾æœ€æ¥è¿‘å½“å‰æ—¶é—´çš„æƒ…ç»ªæ•°æ®
      let closestRecord = null;
      let minTimeDiff = Infinity;
      
      for (const record of dataLog) {
        if (record.face && record.emotions) {
          const timeDiff = Math.abs(record.time - currentTime);
          if (timeDiff < minTimeDiff) {
            minTimeDiff = timeDiff;
            closestRecord = record;
          }
        }
      }
      
      const currentEmotionDisplay = document.getElementById('currentEmotionDisplay');
      
      if (closestRecord && minTimeDiff < 0.5) { // 0.5ç§’å®¹å·®
        // æ˜¾ç¤ºä¸»å¯¼æƒ…ç»ª
        const dominantEmotion = closestRecord.dominantEmotion || 'Unknown';
        let emotionValue = 0;
        
        if (closestRecord.emotions && closestRecord.emotions[dominantEmotion]) {
          emotionValue = closestRecord.emotions[dominantEmotion];
          // DeepFaceè¿”å›0-100çš„å€¼ï¼Œç¡®ä¿æ˜¾ç¤ºä¸ºç™¾åˆ†æ¯”
          if (emotionValue > 1) {
            emotionValue = emotionValue; // å·²ç»æ˜¯0-100
          } else {
            emotionValue = emotionValue * 100; // å¦‚æœæ˜¯0-1ï¼Œè½¬æ¢ä¸º0-100
          }
        }
        
        currentEmotionDisplay.innerHTML = `
          <strong>${dominantEmotion}</strong> (${emotionValue.toFixed(1)}%)
        `;
      } else {
        currentEmotionDisplay.innerHTML = '<span class="muted">æ— æ•°æ®</span>';
      }
    }

    // æ•°æ®å¤„ç†å‡½æ•°
    function calculateDataMeans() {
      const valenceValues = [];
      const arousalValues = [];
      
      for (const r of dataLog) {
        if (r.face && isFinite(r.valence) && isFinite(r.arousal)) {
          valenceValues.push(r.valence);
          arousalValues.push(r.arousal);
        }
      }
      
      const valenceMean = valenceValues.length > 0 ? 
        valenceValues.reduce((sum, val) => sum + val, 0) / valenceValues.length : 0;
      const arousalMean = arousalValues.length > 0 ? 
        arousalValues.reduce((sum, val) => sum + val, 0) / arousalValues.length : 0;
        
      return { valenceMean, arousalMean };
    }

    function resetDataProcessing() {
      if (originalDataLog.length === 0) {
        alert('æ²¡æœ‰åŸå§‹æ•°æ®å¯æ¢å¤');
        return;
      }
      
      // æ¢å¤åŸå§‹æ•°æ®
      dataLog = originalDataLog.map(r => ({ ...r }));
      
      // é‡ç½®çŠ¶æ€
      valenceOffset = 0;
      arousalOffset = 0;
      
      loadAllDataToChart();
      updateDataProcessingStatus();
      
      console.log('æ•°æ®å¤„ç†å·²é‡ç½®åˆ°åŸå§‹çŠ¶æ€');
    }

    function updateDataProcessingStatus() {
      const statusEl = document.getElementById('dataProcessingStatus');
      statusEl.textContent = 'æ•°æ®å¤„ç†çŠ¶æ€ï¼šæ­£å¸¸æ˜¾ç¤º';
    }

    // åº”ç”¨è‡ªå®šä¹‰æ—¶é—´èŒƒå›´
    const applyWindowBtn = document.getElementById('applyWindow');
    applyWindowBtn.onclick = () => {
      const startInput = document.getElementById('windowStart');
      const endInput = document.getElementById('windowEnd');

      const start = parseFloat(startInput.value);
      const end = parseFloat(endInput.value);

      if (!isFinite(start) || !isFinite(end) || start >= end) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„èµ·ç‚¹å’Œç»ˆç‚¹æ—¶é—´');
        return;
      }

      // åŒæ—¶è®¾ç½®V/Aå›¾è¡¨å’Œæƒ…ç»ªå›¾è¡¨çš„æ—¶é—´èŒƒå›´
      chart.setViewRange(start, end);
      
      // åŒæ­¥è®¾ç½®æƒ…ç»ªå›¾è¡¨çš„æ—¶é—´èŒƒå›´
      if (emotionChart && emotionDetectionEnabled) {
        emotionChart.options.scales.xAxes[0].ticks.min = start;
        emotionChart.options.scales.xAxes[0].ticks.max = end;
        emotionChart.update();
      }
    };

    // XDF å¯¼å…¥é€»è¾‘
    xdfInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const xdfData = JSON.parse(reader.result);
          
          // ä½¿ç”¨XDFæ ¼å¼å¤„ç†å™¨å¯¼å…¥æ•°æ®
          const importedData = xdfFormatter.importFromXDF(xdfData);
          
          // æ›´æ–°æ•°æ®
          dataLog = importedData;
          originalDataLog = importedData.map(r => ({ ...r }));
          processedDataLog = importedData.map(r => ({ ...r }));
          
          console.log('å¯¼å…¥çš„å‰5ä¸ªXDFæ•°æ®ç‚¹ï¼š', dataLog.slice(0, 5));
          
          // æ£€æŸ¥æ˜¯å¦åŒ…å«æƒ…ç»ªæ•°æ®
          const hasEmotionData = dataLog.some(r => r.emotions);
          if (hasEmotionData && !emotionDetectionEnabled) {
            emotionDetectionEnabled = true;
            document.getElementById('emotionToggle').checked = true;
            toggleEmotionDetection();
          }
          
          loadAllDataToChart();
          statusEl.textContent = `XDF å¯¼å…¥æˆåŠŸï¼š${dataLog.length} ç‚¹${hasEmotionData ? 'ï¼ˆåŒ…å«æƒ…ç»ªæ•°æ®ï¼‰' : ''}`;
          
          // æ˜¾ç¤ºRate-of-Changeå¤„ç†é¢æ¿
          document.getElementById('rocProcessingPanel').style.display = 'block';
          updateProcessingStatus('step0', false, 'XDFå·²å¯¼å…¥ï¼Œå¯å¼€å§‹æ•°æ®å¤„ç†');
          
        } catch (error) {
          console.error('XDF import failed:', error);
          alert('XDF å¯¼å…¥å¤±è´¥ï¼š' + error.message);
        }
      };
      reader.readAsText(file);
    };

    // ç‚¹å‡»æ ‡è®°ç‚¹è·³è½¬è§†é¢‘ + å¼‚å¸¸æ ‡è®°åŠŸèƒ½
    chartCanvas.addEventListener('click', (evt) => {
      console.log('ğŸ–±ï¸ å›¾è¡¨ç‚¹å‡»äº‹ä»¶è§¦å‘');
      console.log('ğŸ” äº‹ä»¶è¯¦æƒ…:', {
        ctrlKey: evt.ctrlKey,
        shiftKey: evt.shiftKey,
        button: evt.button,
        clientX: evt.clientX,
        clientY: evt.clientY
      });
      
      // å¼‚å¸¸æ ‡è®°æ¨¡å¼å¤„ç† - æ£€æµ‹Ctrl+ç‚¹å‡»
      if (evt.ctrlKey) {
        console.log('ğŸ¯ æ£€æµ‹åˆ°Ctrl+ç‚¹å‡»ï¼Œè¿›å…¥å¼‚å¸¸æ ‡è®°æ¨¡å¼');
        
        const t = chart.getTimeAtEvent(evt);
        console.log(`ğŸ“ ç‚¹å‡»ä½ç½®æ—¶é—´: ${t}`);
        
        if (t != null && isFinite(t)) {
          console.log(`ğŸ”„ æœç´¢æœ€è¿‘çš„valenceæ•°æ®ç‚¹ï¼Œå½“å‰æ•°æ®è®°å½•æ€»æ•°: ${dataLog.length}`);
          
          // æŸ¥æ‰¾æœ€æ¥è¿‘çš„valenceæ•°æ®ç‚¹
          let closestPoint = null;
          let minDistance = Infinity;
          let validPointsCount = 0;
          
          for (const record of dataLog) {
            if (record.face && isFinite(record.valence)) {
              validPointsCount++;
              const distance = Math.abs(record.time - t);
              if (distance < minDistance && distance < 1.0) { // 1ç§’å®¹å·®
                minDistance = distance;
                closestPoint = record;
              }
            }
          }
          
          console.log(`ğŸ“Š æœç´¢ç»“æœ: æœ‰æ•ˆvalenceæ•°æ®ç‚¹${validPointsCount}ä¸ª, æœ€è¿‘è·ç¦»${minDistance.toFixed(3)}s`);
          console.log(`ğŸ” æ‰¾åˆ°æœ€è¿‘çš„æ•°æ®ç‚¹:`, closestPoint);
          
          if (closestPoint) {
            if (evt.shiftKey) {
              // Ctrl + Shift + ç‚¹å‡» = ç§»é™¤æ ‡è®°
              console.log('ğŸ—‘ï¸ Ctrl+Shift+ç‚¹å‡» - å°è¯•ç§»é™¤å¼‚å¸¸æ ‡è®°');
              removeAnomalyMark(closestPoint.time);
            } else {
              // Ctrl + ç‚¹å‡» = æ·»åŠ æ ‡è®°
              console.log('â­ Ctrl+ç‚¹å‡» - å°è¯•æ·»åŠ å¼‚å¸¸æ ‡è®°');
              addAnomalyMark(closestPoint.time, closestPoint.valence);
            }
          } else {
            console.log('âŒ æœªæ‰¾åˆ°é™„è¿‘çš„æœ‰æ•ˆvalenceæ•°æ®ç‚¹');
            alert('æœªæ‰¾åˆ°é™„è¿‘çš„æœ‰æ•ˆvalenceæ•°æ®ç‚¹ï¼Œè¯·ç¡®ä¿æœ‰æƒ…ç»ªæ•°æ®');
          }
          
          evt.preventDefault();
          return;
        } else {
          console.log('âŒ æ— æ³•è·å–ç‚¹å‡»ä½ç½®çš„æ—¶é—´');
        }
      } else {
        console.log('ğŸ“ æ™®é€šç‚¹å‡» - æ‰§è¡Œæ—¶é—´è·³è½¬');
      }
      
      // åŸæœ‰çš„æ—¶é—´è·³è½¬åŠŸèƒ½
      const t = chart.getTimeAtEvent(evt);
      if (t == null || !isFinite(t)) {
        console.log('âŒ æ—¶é—´è·³è½¬å¤±è´¥: æ— æ•ˆæ—¶é—´');
        return;
      }
      
      console.log(`â° æ—¶é—´è·³è½¬åˆ°: ${t.toFixed(3)}s`);
      video.currentTime = Math.max(0, t);
      chart.updatePlaybackMarker(t);
    });

    // ä¿®å¤æ’­æ”¾æ—¶ Chart æ˜¾ç¤ºé—®é¢˜
    video.addEventListener('timeupdate', () => {
      const t = video.currentTime;
      chart.updatePlaybackMarker(t);
      
      // æ›´æ–°æƒ…ç»ªæ˜¾ç¤ºï¼ˆå¦‚æœæƒ…ç»ªæ£€æµ‹å¯ç”¨ï¼‰
      if (emotionDetectionEnabled) {
        updateCurrentEmotionDisplay(t);
      }
    });

    // æƒ…ç»ªå›¾è¡¨ç‚¹å‡»è·³è½¬è§†é¢‘æ—¶é—´
    document.addEventListener('DOMContentLoaded', () => {
      console.log('ğŸš€ é¡µé¢DOMContentLoadedäº‹ä»¶è§¦å‘');
      console.log('ğŸ”§ å¼€å§‹åˆå§‹åŒ–å¼‚å¸¸æ ‡è®°åŠŸèƒ½');
      
      // åˆå§‹åŒ–å¼‚å¸¸æ ‡è®°çŠ¶æ€æ˜¾ç¤º
      updateAnomalyMarkingStatus();
      
      // åˆå§‹åŒ–XDFå¯¼å‡ºæŒ‰é’®çŠ¶æ€
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
      
      // åˆå§‹åŒ– API çŠ¶æ€
      apiConnected = true; // MorphCast é»˜è®¤å¯ç”¨
      updateApiStatus('MorphCast å·²é€‰æ‹©');
      
      // åˆå§‹åŒ–åŒºåŸŸæ‹–æ‹½åŠŸèƒ½
      initRegionDragHandlers();
      
      console.log('ğŸ¯ å¼‚å¸¸æ ‡è®°åŠŸèƒ½å·²åˆå§‹åŒ–å®Œæˆ');
      
      const emotionCanvas = document.getElementById('emotionChart');
      if (emotionCanvas) {
        emotionCanvas.addEventListener('click', (evt) => {
          if (!emotionChart || !emotionDetectionEnabled) return;
          
          // è·å–ç‚¹å‡»ä½ç½®çš„æ—¶é—´
          const canvasPosition = Chart.helpers.getRelativePosition(evt, emotionChart);
          const dataX = emotionChart.scales['x-axis-0'].getValueForPixel(canvasPosition.x);
          
          if (dataX != null && isFinite(dataX)) {
            video.currentTime = Math.max(0, dataX);
            chart.updatePlaybackMarker(dataX);
            updateCurrentEmotionDisplay(dataX);
          }
        });
      }
    });

    // =================== Rate-of-Change å¤„ç†æ­¥éª¤äº‹ä»¶ç›‘å¬å™¨ ===================
    
    // æ­¥éª¤0: åŸºç¡€æ•´ç†
    document.getElementById('sortDataBtn').addEventListener('click', () => {
      if (originalDataLog.length === 0) {
        alert('è¯·å…ˆå¯¼å…¥CSVæ•°æ®');
        return;
      }
      
      // æ—¶é—´å¯¹é½å’Œå»é‡
      processedDataLog.sort((a, b) => a.time - b.time);
      const uniqueData = [];
      let lastTime = -Infinity;
      
      for (const record of processedDataLog) {
        if (record.time > lastTime + 0.001) { // 1mså®¹å·®
          uniqueData.push({ ...record });
          lastTime = record.time;
        }
      }
      
      processedDataLog = uniqueData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      updateProcessingStatus('step0', true, `æ—¶é—´å¯¹é½å®Œæˆï¼Œä¿ç•™${processedDataLog.length}ä¸ªæ•°æ®ç‚¹`);
    });
    
    document.getElementById('resampleBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œæ—¶é—´å¯¹é½');
        return;
      }
      
      // é‡é‡‡æ ·åˆ°5Hz (200msé—´éš”)
      const startTime = processedDataLog[0].time;
      const endTime = processedDataLog[processedDataLog.length - 1].time;
      const interval = 0.2; // 200ms
      const newData = [];
      
      for (let t = startTime; t <= endTime; t += interval) {
        // æ‰¾åˆ°æœ€è¿‘çš„æœ‰æ•ˆæ•°æ®ç‚¹è¿›è¡Œæ’å€¼
        let beforeIdx = -1, afterIdx = -1;
        
        for (let i = 0; i < processedDataLog.length; i++) {
          if (processedDataLog[i].face && processedDataLog[i].time <= t) {
            beforeIdx = i;
          }
          if (processedDataLog[i].face && processedDataLog[i].time >= t && afterIdx === -1) {
            afterIdx = i;
            break;
          }
        }
        
        if (beforeIdx !== -1 && afterIdx !== -1 && beforeIdx !== afterIdx) {
          const before = processedDataLog[beforeIdx];
          const after = processedDataLog[afterIdx];
          const ratio = (t - before.time) / (after.time - before.time);
          
          newData.push({
            time: t,
            valence: before.valence + ratio * (after.valence - before.valence),
            arousal: before.arousal + ratio * (after.arousal - before.arousal),
            face: true
          });
        } else if (beforeIdx !== -1) {
          const record = processedDataLog[beforeIdx];
          if (Math.abs(record.time - t) < 0.1) { // 100mså®¹å·®
            newData.push({ ...record, time: t });
          }
        }
      }
      
      processedDataLog = newData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      updateProcessingStatus('step0', true, `é‡é‡‡æ ·å®Œæˆï¼Œ${newData.length}ä¸ªæ•°æ®ç‚¹@5Hz`);
    });

    // 50Hzé‡é‡‡æ ·
    document.getElementById('resample50HzBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œæ—¶é—´å¯¹é½');
        return;
      }
      
      // é‡é‡‡æ ·åˆ°50Hz (20msé—´éš”)
      const startTime = processedDataLog[0].time;
      const endTime = processedDataLog[processedDataLog.length - 1].time;
      const interval = 0.02; // 20ms = 50Hz
      const newData = [];
      
      console.log(`ğŸ”„ å¼€å§‹50Hzé‡é‡‡æ ·: ${startTime.toFixed(3)}s åˆ° ${endTime.toFixed(3)}s, é—´éš”=${interval}s`);
      
      for (let t = startTime; t <= endTime; t += interval) {
        // æ‰¾åˆ°æœ€è¿‘çš„æœ‰æ•ˆæ•°æ®ç‚¹è¿›è¡Œæ’å€¼
        let beforeIdx = -1, afterIdx = -1;
        
        for (let i = 0; i < processedDataLog.length; i++) {
          if (processedDataLog[i].face && processedDataLog[i].time <= t) {
            beforeIdx = i;
          }
          if (processedDataLog[i].face && processedDataLog[i].time >= t && afterIdx === -1) {
            afterIdx = i;
            break;
          }
        }
        
        if (beforeIdx !== -1 && afterIdx !== -1 && beforeIdx !== afterIdx) {
          // çº¿æ€§æ’å€¼
          const before = processedDataLog[beforeIdx];
          const after = processedDataLog[afterIdx];
          const ratio = (t - before.time) / (after.time - before.time);
          
          const newRecord = {
            time: t,
            valence: before.valence + ratio * (after.valence - before.valence),
            arousal: before.arousal + ratio * (after.arousal - before.arousal),
            face: true
          };
          
          // å¦‚æœæœ‰GSRæ•°æ®ï¼Œä¹Ÿè¿›è¡Œæ’å€¼
          if (before.gsr !== undefined && after.gsr !== undefined) {
            newRecord.gsr = before.gsr + ratio * (after.gsr - before.gsr);
          }
          
          // å¦‚æœæœ‰PPGæ•°æ®ï¼Œä¹Ÿè¿›è¡Œæ’å€¼
          if (before.ppg !== undefined && after.ppg !== undefined) {
            newRecord.ppg = before.ppg + ratio * (after.ppg - before.ppg);
          }
          
          newData.push(newRecord);
        } else if (beforeIdx !== -1) {
          const record = processedDataLog[beforeIdx];
          if (Math.abs(record.time - t) < 0.01) { // 10mså®¹å·®
            newData.push({ ...record, time: t });
          }
        }
      }
      
      processedDataLog = newData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      console.log(`âœ… 50Hzé‡é‡‡æ ·å®Œæˆ: ${newData.length}ä¸ªæ•°æ®ç‚¹`);
      updateProcessingStatus('step0', true, `50Hzé‡é‡‡æ ·å®Œæˆï¼Œ${newData.length}ä¸ªæ•°æ®ç‚¹@50Hz`);
    });

    // NeuroKit GSRé¢„å¤„ç†
    document.getElementById('neurokitProcessBtn').addEventListener('click', async () => {
      if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
        alert('è¯·å…ˆå¯¼å…¥åŒ…å«GSRæ•°æ®çš„æ–‡ä»¶');
        return;
      }

      const method = document.getElementById('neurokitMethod').value || 'neurokit';
      const progressDiv = document.getElementById('neurokitProgress');
      const statusSpan = document.getElementById('neurokitStatus');
      const btn = document.getElementById('neurokitProcessBtn');
      
      try {
        btn.disabled = true;
        progressDiv.style.display = 'block';
        progressDiv.textContent = 'å¼€å§‹NeuroKité¢„å¤„ç†...';
        
        const rawGSRValues = physiologicalData.gsr.map(item => item.gsr);
        const samplingRate = physiologicalData.gsr.length > 1 ? 
          1 / (physiologicalData.gsr[1].time - physiologicalData.gsr[0].time) : 50;

        const progressCallback = (info) => {
          progressDiv.textContent = info.message;
        };

        cleanedGSRDataPanel = await edaPreprocessor.clean(rawGSRValues, samplingRate, method, progressCallback);
        
        // ç›´æ¥æ›¿æ¢physiologicalDataä¸­çš„GSRæ•°æ®
        for (let i = 0; i < Math.min(physiologicalData.gsr.length, cleanedGSRDataPanel.length); i++) {
          physiologicalData.gsr[i].gsr = cleanedGSRDataPanel[i];
        }
        
        // é‡æ–°åŠ è½½å›¾è¡¨æ•°æ®ä»¥æ˜¾ç¤ºæ¸…ç†åçš„æ•°æ®
        loadAllDataToChart();
        
        progressDiv.style.display = 'none';
        updateProcessingStatus('neurokit', true, `NeuroKitå¤„ç†å®Œæˆ: ${method}æ–¹æ³•, å·²æ›¿æ¢åŸGSRæ•°æ®`);
        neurokitProcessed = true;

      } catch (error) {
        progressDiv.style.display = 'none';
        progressDiv.textContent = '';
        alert('NeuroKitå¤„ç†å¤±è´¥: ' + error.message);
        console.error('NeuroKitå¤„ç†é”™è¯¯:', error);
      } finally {
        btn.disabled = false;
      }
    });
    
    // å¼‚å¸¸æ£€æµ‹äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('runAnomalyDetectionBtn').addEventListener('click', async () => {
      const dataSource = document.getElementById('anomalyDataSource').value;
      const contamination = parseFloat(document.getElementById('contaminationRate').value) || 0.1;
      
      const statusEl = document.getElementById('anomalyDetectionStatus');
      const resultsEl = document.getElementById('anomalyDetectionResults');
      const runBtn = document.getElementById('runAnomalyDetectionBtn');
      const toggleBtn = document.getElementById('toggleAnomalyDisplay');
      
      try {
        runBtn.disabled = true;
        statusEl.textContent = 'æ­£åœ¨è¿è¡ŒIsolation Forestæ£€æµ‹...';
        statusEl.style.color = '#fbbf24';
        resultsEl.style.display = 'none';
        
        // è¿è¡Œå¼‚å¸¸æ£€æµ‹
        const results = await isolationForestDetector.runDetection(dataSource, contamination);
        
        // æ˜¾ç¤ºç»“æœ
        const anomalyCount = results.anomalies.length;
        const anomalyPercentage = ((anomalyCount / results.totalPoints) * 100).toFixed(1);
        
        document.getElementById('anomalyCount').textContent = anomalyCount;
        document.getElementById('totalPoints').textContent = results.totalPoints;
        document.getElementById('anomalyPercentage').textContent = anomalyPercentage + '%';
        
        statusEl.textContent = `æ£€æµ‹å®Œæˆ - ${results.sourceInfo}`;
        statusEl.style.color = '#4caf50';
        resultsEl.style.display = 'block';
        toggleBtn.disabled = false;
        toggleBtn.textContent = 'æ˜¾ç¤ºå¼‚å¸¸ç‚¹';
        
        // å¯ç”¨åŒºé—´æ˜¾ç¤ºæŒ‰é’®
        document.getElementById('toggleIntervalDisplay').disabled = false;
        document.getElementById('recalculateIntervals').disabled = false;
        
        // è‡ªåŠ¨æ˜¾ç¤ºå¼‚å¸¸ç‚¹
        isolationForestDetector.showAnomalies();
        toggleBtn.textContent = 'éšè—å¼‚å¸¸ç‚¹';
        
        // ğŸ” æ–°å¢ï¼šå¼‚å¸¸åŒºé—´æ£€æµ‹
        if (results.anomalies.length > 0) {
          console.log('ğŸ” å¼€å§‹å¼‚å¸¸åŒºé—´æ£€æµ‹...');
          
          // ä»UIè·å–åŒºé—´æ£€æµ‹å‚æ•°
          const intervalConfig = {
            maxGap: parseFloat(document.getElementById('maxGapParam').value) || 2.0,
            minDuration: parseFloat(document.getElementById('minDurationParam').value) || 1.0
          };
          
          console.log(`åŒºé—´å‚æ•°: æœ€å¤§é—´éš”=${intervalConfig.maxGap}s, æœ€å°æ—¶é•¿=${intervalConfig.minDuration}s`);
          
          // æ£€æµ‹å¼‚å¸¸åŒºé—´
          const intervals = anomalyIntervalDetector.detectIntervals(results.anomalies, intervalConfig);
          
          // åº”ç”¨å‰å‘åç§»åˆ°å¼‚å¸¸åŒºé—´
          const forwardOffset = parseFloat(document.getElementById('forwardOffsetParam').value) || 0.0;
          let displayIntervals = intervals;
          
          // ç»Ÿä¸€ä½¿ç”¨ startTime å’Œ endTime å±æ€§
          if (forwardOffset > 0) {
            displayIntervals = intervals.map(interval => {
              const duration = interval.endTime - interval.startTime;
              const offset = duration * forwardOffset;
              const newStart = Math.max(0, interval.startTime - offset);
              const newEnd = Math.max(0, interval.endTime - offset);
              return {
                ...interval,
                startTime: newStart,
                endTime: newEnd,
                originalStart: interval.startTime,
                originalEnd: interval.endTime,
                offset: offset
              };
            });
            console.log(`âª åº”ç”¨å‰å‘åç§» ${(forwardOffset * 100).toFixed(0)}%:`, displayIntervals);
          } else {
            // ä¸åšåç§»ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®
            displayIntervals = intervals;
          }
          
          // æ˜¾ç¤ºå¼‚å¸¸åŒºé—´
          if (displayIntervals.length > 0) {
            if (chart && typeof chart.showAnomalyIntervals === 'function') {
              // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
              console.log(`ğŸ” æ˜¾ç¤ºåŒºé—´è¯¦æƒ… (åç§»${(forwardOffset * 100).toFixed(0)}%):`, 
                displayIntervals.slice(0, 3).map(i => {
                  const hasOriginal = i.originalStart !== undefined && i.originalEnd !== undefined;
                  return {
                    original: hasOriginal ? `${i.originalStart.toFixed(1)}s-${i.originalEnd.toFixed(1)}s` : `æ— åŸå§‹æ•°æ®`,
                    display: `${i.startTime.toFixed(1)}s-${i.endTime.toFixed(1)}s`,
                    offset: i.offset ? i.offset.toFixed(1) + 's' : 'æ— åç§»'
                  };
                })
              );
              chart.showAnomalyIntervals(displayIntervals);
              console.log(`âœ¨ åœ¨å›¾è¡¨ä¸Šæ˜¾ç¤ºäº† ${displayIntervals.length} ä¸ªå¼‚å¸¸åŒºé—´`);
            } else {
              console.warn('å›¾è¡¨ä¸æ”¯æŒæ˜¾ç¤ºå¼‚å¸¸åŒºé—´åŠŸèƒ½');
            }
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const offsetText = forwardOffset > 0 ? ` âª${(forwardOffset * 100).toFixed(0)}%åç§»` : '';
            statusEl.textContent = `æ£€æµ‹å®Œæˆ - ${results.sourceInfo} (ğŸ”¶${displayIntervals.length}ä¸ªåŒºé—´${offsetText})`;
            
            // ä¿å­˜åŒºé—´ç»“æœï¼ˆä¿å­˜åŸå§‹åŒºé—´å’Œæ˜¾ç¤ºåŒºé—´ï¼‰
            results.intervals = intervals;
            results.displayIntervals = displayIntervals;
          } else {
            console.log('æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„å¼‚å¸¸åŒºé—´');
          }
        }
        
        // ä¿å­˜æ£€æµ‹ç»“æœ
        anomalyDetectionResults = results;
        
        console.log(`å¼‚å¸¸æ£€æµ‹å®Œæˆï¼š${dataSource}æ•°æ®ï¼Œ${anomalyCount}/${results.totalPoints}å¼‚å¸¸ç‚¹ (${anomalyPercentage}%)`);
        
      } catch (error) {
        statusEl.textContent = 'æ£€æµ‹å¤±è´¥: ' + error.message;
        statusEl.style.color = '#ef4444';
        resultsEl.style.display = 'none';
        
        // é‡ç½®æŒ‰é’®çŠ¶æ€
        document.getElementById('toggleIntervalDisplay').disabled = true;
        document.getElementById('toggleIntervalDisplay').textContent = 'ğŸ”¶ æ˜¾ç¤ºå¼‚å¸¸åŒºé—´';
        document.getElementById('toggleIntervalDisplay').style.background = '#8b5cf6';
        document.getElementById('recalculateIntervals').disabled = true;
        
        console.error('å¼‚å¸¸æ£€æµ‹é”™è¯¯:', error);
      } finally {
        runBtn.disabled = false;
      }
    });

    // æ˜¾ç¤º/éšè—å¼‚å¸¸ç‚¹æŒ‰é’®
    document.getElementById('toggleAnomalyDisplay').addEventListener('click', () => {
      const btn = document.getElementById('toggleAnomalyDisplay');
      
      isolationForestDetector.toggleAnomalies();
      
      btn.textContent = showingAnomalies ? 'éšè—å¼‚å¸¸ç‚¹' : 'æ˜¾ç¤ºå¼‚å¸¸ç‚¹';
    });

    // æ˜¾ç¤º/éšè—å¼‚å¸¸åŒºé—´æŒ‰é’®
    let showingIntervals = false;
    document.getElementById('toggleIntervalDisplay').addEventListener('click', () => {
      const btn = document.getElementById('toggleIntervalDisplay');
      
      if (!anomalyDetectionResults || !anomalyDetectionResults.intervals) {
        alert('è¯·å…ˆè¿è¡Œå¼‚å¸¸æ£€æµ‹å¹¶ç”ŸæˆåŒºé—´');
        return;
      }
      
      if (!chart || typeof chart.showAnomalyIntervals !== 'function') {
        alert('å½“å‰å›¾è¡¨ä¸æ”¯æŒå¼‚å¸¸åŒºé—´æ˜¾ç¤º');
        return;
      }
      
      showingIntervals = !showingIntervals;
      
      if (showingIntervals) {
        const intervalsToShow = anomalyDetectionResults.displayIntervals || anomalyDetectionResults.intervals;
        chart.showAnomalyIntervals(intervalsToShow);
        btn.textContent = 'ğŸ”¶ éšè—å¼‚å¸¸åŒºé—´';
        btn.style.background = '#7c3aed';
        console.log(`ğŸ¨ æ˜¾ç¤º ${intervalsToShow.length} ä¸ªå¼‚å¸¸åŒºé—´`);
      } else {
        chart.hideAnomalyIntervals();
        btn.textContent = 'ğŸ”¶ æ˜¾ç¤ºå¼‚å¸¸åŒºé—´';
        btn.style.background = '#8b5cf6';
        console.log('ğŸ—‘ï¸ éšè—å¼‚å¸¸åŒºé—´');
      }
    });

    // é‡æ–°è®¡ç®—å¼‚å¸¸åŒºé—´æŒ‰é’®
    document.getElementById('recalculateIntervals').addEventListener('click', () => {
      if (!anomalyDetectionResults || !anomalyDetectionResults.anomalies) {
        alert('è¯·å…ˆè¿è¡Œå¼‚å¸¸æ£€æµ‹');
        return;
      }

      const btn = document.getElementById('recalculateIntervals');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = 'ğŸ”„ è®¡ç®—ä¸­...';
        
        // ä»UIè·å–å½“å‰å‚æ•°
        const intervalConfig = {
          maxGap: parseFloat(document.getElementById('maxGapParam').value) || 2.0,
          minDuration: parseFloat(document.getElementById('minDurationParam').value) || 1.0
        };
        
        console.log(`ğŸ”„ é‡æ–°è®¡ç®—åŒºé—´ï¼Œå‚æ•°: æœ€å¤§é—´éš”=${intervalConfig.maxGap}s, æœ€å°æ—¶é•¿=${intervalConfig.minDuration}s`);
        
        // é‡æ–°æ£€æµ‹å¼‚å¸¸åŒºé—´
        const intervals = anomalyIntervalDetector.detectIntervals(anomalyDetectionResults.anomalies, intervalConfig);
        
        // åº”ç”¨å‰å‘åç§»
        const forwardOffset = parseFloat(document.getElementById('forwardOffsetParam').value) || 0.0;
        let displayIntervals = intervals;
        
        if (forwardOffset > 0) {
          displayIntervals = intervals.map(interval => {
            const duration = interval.end - interval.start;
            const offset = duration * forwardOffset;
            const newStart = Math.max(0, interval.start - offset);
            const newEnd = Math.max(0, interval.end - offset);
            return {
              ...interval,
              start: newStart,
              end: newEnd,
              startTime: newStart,  // å›¾è¡¨éœ€è¦çš„å±æ€§
              endTime: newEnd,      // å›¾è¡¨éœ€è¦çš„å±æ€§
              originalStart: interval.start,
              originalEnd: interval.end,
              offset: offset
            };
          });
          console.log(`âª é‡æ–°è®¡ç®—æ—¶åº”ç”¨å‰å‘åç§» ${(forwardOffset * 100).toFixed(0)}%:`, displayIntervals);
        } else {
          // å³ä½¿æ²¡æœ‰åç§»ï¼Œä¹Ÿè¦ç¡®ä¿æœ‰startTimeå’ŒendTimeå±æ€§
          displayIntervals = intervals.map(interval => ({
            ...interval,
            startTime: interval.start,
            endTime: interval.end
          }));
        }
        
        // æ›´æ–°ç»“æœ
        anomalyDetectionResults.intervals = intervals;
        anomalyDetectionResults.displayIntervals = displayIntervals;
        
        // å¦‚æœå½“å‰æ­£åœ¨æ˜¾ç¤ºåŒºé—´ï¼Œåˆ™æ›´æ–°æ˜¾ç¤º
        if (showingIntervals && chart && typeof chart.showAnomalyIntervals === 'function') {
          chart.hideAnomalyIntervals();
          chart.showAnomalyIntervals(displayIntervals);
        }
        
        // æ›´æ–°çŠ¶æ€
        const statusEl = document.getElementById('anomalyDetectionStatus');
        const offsetText = forwardOffset > 0 ? ` âª${(forwardOffset * 100).toFixed(0)}%åç§»` : '';
        statusEl.textContent = `æ£€æµ‹å®Œæˆ - ${anomalyDetectionResults.sourceInfo} (ğŸ”¶${displayIntervals.length}ä¸ªåŒºé—´${offsetText})`;
        
        console.log(`âœ… é‡æ–°è®¡ç®—å®Œæˆ: ${intervals.length} ä¸ªå¼‚å¸¸åŒºé—´`);
        
      } catch (error) {
        console.error('é‡æ–°è®¡ç®—åŒºé—´å¤±è´¥:', error);
        alert('é‡æ–°è®¡ç®—å¤±è´¥: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });
    
    // æ­¥éª¤1: å»ä¼ªè¿¹
    document.getElementById('medianFilterBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡ŒåŸºç¡€æ•´ç†');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('medianWindow').value) || 5;
      const valenceValues = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalValues = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const filteredValence = medianFilter(valenceValues, windowSize);
      const filteredArousal = medianFilter(arousalValues, windowSize);
      
      // å¤„ç†GSRæ•°æ®çš„å»ä¼ªè¿¹
      let gsrProcessedCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrValues = physiologicalData.gsr.map(item => item.gsr);
        const filteredGSR = medianFilter(gsrValues, windowSize);
        
        for (let i = 0; i < physiologicalData.gsr.length; i++) {
          physiologicalData.gsr[i].gsr = filteredGSR[i];
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„GSRæ•°æ®
        chart.updateGSRData(physiologicalData.gsr);
        gsrProcessedCount = physiologicalData.gsr.length;
      }
      
      for (let i = 0; i < processedDataLog.length; i++) {
        if (processedDataLog[i].face) {
          processedDataLog[i].valence = filteredValence[i];
          processedDataLog[i].arousal = filteredArousal[i];
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      const message = gsrProcessedCount > 0 ? 
        `ä¸­å€¼æ»¤æ³¢å®Œæˆï¼Œçª—å£=${windowSize}ï¼Œå¤„ç†VAå’ŒGSRæ•°æ®(${gsrProcessedCount}ç‚¹)` :
        `ä¸­å€¼æ»¤æ³¢å®Œæˆï¼Œçª—å£=${windowSize}`;
      updateProcessingStatus('step1', true, message);
    });
    
    document.getElementById('outlierClipBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡ŒåŸºç¡€æ•´ç†');
        return;
      }
      
      // å¼‚å¸¸å€¼æˆªæ–­ (winsorize)
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite).sort((a,b) => a-b);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite).sort((a,b) => a-b);
      
      const vP1 = valenceVals[Math.floor(valenceVals.length * 0.01)];
      const vP99 = valenceVals[Math.floor(valenceVals.length * 0.99)];
      const aP1 = arousalVals[Math.floor(arousalVals.length * 0.01)];
      const aP99 = arousalVals[Math.floor(arousalVals.length * 0.99)];
      
      let clippedCount = 0;
      for (const record of processedDataLog) {
        if (record.face) {
          if (record.valence < vP1) { record.valence = vP1; clippedCount++; }
          if (record.valence > vP99) { record.valence = vP99; clippedCount++; }
          if (record.arousal < aP1) { record.arousal = aP1; clippedCount++; }
          if (record.arousal > aP99) { record.arousal = aP99; clippedCount++; }
        }
      }
      
      // å¤„ç†GSRæ•°æ®çš„å¼‚å¸¸å€¼æˆªæ–­
      let gsrClippedCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite).sort((a,b) => a-b);
        const gsrP1 = gsrVals[Math.floor(gsrVals.length * 0.01)];
        const gsrP99 = gsrVals[Math.floor(gsrVals.length * 0.99)];
        
        for (const item of physiologicalData.gsr) {
          if (item.gsr < gsrP1) { item.gsr = gsrP1; gsrClippedCount++; }
          if (item.gsr > gsrP99) { item.gsr = gsrP99; gsrClippedCount++; }
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„GSRæ•°æ®
        chart.updateGSRData(physiologicalData.gsr);
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      const message = gsrClippedCount > 0 ? 
        `å¼‚å¸¸å€¼æˆªæ–­å®Œæˆï¼Œè°ƒæ•´VA ${clippedCount}ä¸ªå€¼ï¼ŒGSR ${gsrClippedCount}ä¸ªå€¼` :
        `å¼‚å¸¸å€¼æˆªæ–­å®Œæˆï¼Œè°ƒæ•´${clippedCount}ä¸ªå€¼`;
      updateProcessingStatus('step1', true, message);
    });
    
    // æ­¥éª¤2: æ ‡å‡†åŒ–
    document.getElementById('zeroMeanBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œå»ä¼ªè¿¹å¤„ç†');
        return;
      }
      
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite);
      
      const vMean = valenceVals.reduce((s,v) => s+v, 0) / valenceVals.length;
      const aMean = arousalVals.reduce((s,v) => s+v, 0) / arousalVals.length;
      
      // å¤„ç†GSRæ•°æ® - ä»physiologicalData.gsrä¸­è·å–
      let gsrMean = 0;
      let gsrCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrMean = gsrVals.length > 0 ? gsrVals.reduce((s,v) => s+v, 0) / gsrVals.length : 0;
        gsrCount = gsrVals.length;
        
        // åº”ç”¨é›¶å‡å€¼åŒ–åˆ°GSRæ•°æ®
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr -= gsrMean;
          }
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„GSRæ•°æ®
        if (chart && chart.updateGSRData) {
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // å¤„ç†PPGæ•°æ® - ä»physiologicalData.ppgä¸­è·å–
      let ppgMean = 0;
      let ppgCount = 0;
      if (physiologicalData.ppg && physiologicalData.ppg.length > 0) {
        const ppgVals = physiologicalData.ppg.map(item => item.ppg).filter(Number.isFinite);
        ppgMean = ppgVals.length > 0 ? ppgVals.reduce((s,v) => s+v, 0) / ppgVals.length : 0;
        ppgCount = ppgVals.length;
        
        // åº”ç”¨é›¶å‡å€¼åŒ–åˆ°PPGæ•°æ®
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg -= ppgMean;
          }
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„PPGæ•°æ®
        if (chart && chart.updatePPGData) {
          chart.updatePPGData(physiologicalData.ppg);
        }
      }
      
      console.log(`ğŸ”„ é›¶å‡å€¼åŒ–: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})ä¸ªæ•°æ®ç‚¹`);
      
      // å¤„ç†VAæ•°æ®
      for (const record of processedDataLog) {
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence -= vMean;
          record.arousal -= aMean;
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // å¼ºåˆ¶åˆ·æ–°GSRå’ŒPPGå›¾è¡¨æ˜¾ç¤º
      if (gsrCount > 0 && chart && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
        console.log(`ğŸ”„ å·²åˆ·æ–°GSRå›¾è¡¨æ˜¾ç¤ºï¼Œ${gsrCount}ä¸ªæ•°æ®ç‚¹`);
      }
      
      if (ppgCount > 0 && chart && chart.updatePPGData) {
        chart.updatePPGData(physiologicalData.ppg);
        console.log(`ğŸ”„ å·²åˆ·æ–°PPGå›¾è¡¨æ˜¾ç¤ºï¼Œ${ppgCount}ä¸ªæ•°æ®ç‚¹`);
      }
      
      const statusMsg = `é›¶å‡å€¼åŒ–å®Œæˆ - Vå‡å€¼=${vMean.toFixed(3)}, Aå‡å€¼=${aMean.toFixed(3)}` +
        (gsrCount > 0 ? `, GSRå‡å€¼=${gsrMean.toFixed(3)}` : '') +
        (ppgCount > 0 ? `, PPGå‡å€¼=${ppgMean.toFixed(3)}` : '');
      
      console.log(`âœ… ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });
    
    // å½’é›¶ç¼©æ”¾ (é›¶å‡å€¼åŒ– + ç¼©æ”¾åˆ°[-1,1])
    document.getElementById('zeroScaleBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œå»ä¼ªè¿¹å¤„ç†');
        return;
      }
      
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite);
      
      // 1. è®¡ç®—VAå‡å€¼
      const vMean = valenceVals.reduce((s,v) => s+v, 0) / valenceVals.length;
      const aMean = arousalVals.reduce((s,v) => s+v, 0) / arousalVals.length;
      
      // å¤„ç†GSRæ•°æ® - ä»physiologicalData.gsrä¸­è·å–
      let gsrMean = 0;
      let gsrCount = 0;
      let gsrNormVals = [];
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrMean = gsrVals.length > 0 ? gsrVals.reduce((s,v) => s+v, 0) / gsrVals.length : 0;
        gsrCount = gsrVals.length;
        
        // åº”ç”¨å‡å€¼åç§»åˆ°GSRæ•°æ®
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr -= gsrMean;
            gsrNormVals.push(item.gsr);
          }
        }
      }
      
      // å¤„ç†PPGæ•°æ® - ä»physiologicalData.ppgä¸­è·å–
      let ppgMean = 0;
      let ppgCount = 0;
      let ppgNormVals = [];
      if (physiologicalData.ppg && physiologicalData.ppg.length > 0) {
        const ppgVals = physiologicalData.ppg.map(item => item.ppg).filter(Number.isFinite);
        ppgMean = ppgVals.length > 0 ? ppgVals.reduce((s,v) => s+v, 0) / ppgVals.length : 0;
        ppgCount = ppgVals.length;
        
        // åº”ç”¨å‡å€¼åç§»åˆ°PPGæ•°æ®
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg -= ppgMean;
            ppgNormVals.push(item.ppg);
          }
        }
      }
      
      console.log(`ğŸ”„ å½’é›¶ç¼©æ”¾: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})ä¸ªæ•°æ®ç‚¹`);
      
      // 2. åº”ç”¨å‡å€¼åç§»åˆ°VAæ•°æ®
      let vVals = [];
      let aVals = [];
      
      for (const record of processedDataLog) {
        // å¤„ç†VAæ•°æ®
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence -= vMean;
          record.arousal -= aMean;
          vVals.push(record.valence);
          aVals.push(record.arousal);
        }
      }
      
      // 3. ç¼©æ”¾åˆ° [-1, 1] èŒƒå›´
      const vMax = vVals.length > 0 ? Math.max(...vVals.map(Math.abs)) : 0;
      const aMax = aVals.length > 0 ? Math.max(...aVals.map(Math.abs)) : 0;
      const gsrMax = gsrNormVals.length > 0 ? Math.max(...gsrNormVals.map(Math.abs)) : 0;
      const ppgMax = ppgNormVals.length > 0 ? Math.max(...ppgNormVals.map(Math.abs)) : 0;
      
      // ç¼©æ”¾VAæ•°æ®
      for (const record of processedDataLog) {
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          if (vMax > 0) record.valence /= vMax;
          if (aMax > 0) record.arousal /= aMax;
        }
      }
      
      // ç¼©æ”¾GSRæ•°æ®
      if (physiologicalData.gsr && gsrMax > 0) {
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr /= gsrMax;
          }
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„GSRæ•°æ®
        if (chart && chart.updateGSRData) {
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // ç¼©æ”¾PPGæ•°æ®
      if (physiologicalData.ppg && ppgMax > 0) {
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg /= ppgMax;
          }
        }
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„PPGæ•°æ®
        if (chart && chart.updatePPGData) {
          chart.updatePPGData(physiologicalData.ppg);
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // å¼ºåˆ¶åˆ·æ–°GSRå’ŒPPGå›¾è¡¨æ˜¾ç¤º - å·²ç»åœ¨ä¸Šé¢å¤„ç†äº†ï¼Œè¿™é‡Œæ— éœ€é‡å¤
      
      const statusMsg = `å½’é›¶ç¼©æ”¾å®Œæˆ - VA: Vå‡å€¼=${vMean.toFixed(3)}, Aå‡å€¼=${aMean.toFixed(3)}` +
        (gsrCount > 0 ? `, GSRå‡å€¼=${gsrMean.toFixed(3)}` : '') +
        (ppgCount > 0 ? `, PPGå‡å€¼=${ppgMean.toFixed(3)}` : '');
      
      console.log(`âœ… ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });
    
    document.getElementById('zScoreBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œå»ä¼ªè¿¹å¤„ç†');
        return;
      }
      
      // å¤„ç†VAæ•°æ®
      const valenceVals = processedDataLog.filter(r => r.face).map(r => r.valence).filter(Number.isFinite);
      const arousalVals = processedDataLog.filter(r => r.face).map(r => r.arousal).filter(Number.isFinite);
      
      console.log(`ğŸ” ValenceåŸå§‹æ•°æ®æ ·æœ¬: [${valenceVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      console.log(`ğŸ” ArousalåŸå§‹æ•°æ®æ ·æœ¬: [${arousalVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      
      const vZScored = zscore(valenceVals);
      const aZScored = zscore(arousalVals);
      
      console.log(`ğŸ” Valenceæ ‡å‡†åŒ–æ ·æœ¬: [${vZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      console.log(`ğŸ” Arousalæ ‡å‡†åŒ–æ ·æœ¬: [${aZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      
      // å¤„ç†GSRæ•°æ® - ä»physiologicalData.gsrä¸­è·å–
      let gsrZScored = [];
      let gsrCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrZScored = zscore(gsrVals);
        gsrCount = gsrVals.length;
        
        console.log(`ğŸ” GSRåŸå§‹æ•°æ®æ ·æœ¬: [${gsrVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        console.log(`ğŸ” GSRæ ‡å‡†åŒ–æ ·æœ¬: [${gsrZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        
        // åº”ç”¨Z-scoreåˆ°GSRæ•°æ®
        let gsrIdx = 0;
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            const originalValue = item.gsr;
            item.gsr = gsrZScored[gsrIdx++];
            
            // è°ƒè¯•å‰å‡ ä¸ªæ•°æ®ç‚¹çš„å˜åŒ–
            if (gsrIdx <= 3) {
              console.log(`ğŸ” GSRæ•°æ®ç‚¹${gsrIdx}: ${originalValue.toFixed(3)} -> ${item.gsr.toFixed(3)}`);
            }
          }
        }
        
        // éªŒè¯æ•°æ®æ˜¯å¦çœŸçš„è¢«ä¿®æ”¹äº†
        const afterVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        console.log(`ğŸ” GSRä¿®æ”¹åæ ·æœ¬: [${afterVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        console.log(`ğŸ” GSRä¿®æ”¹åç»Ÿè®¡: å‡å€¼=${(afterVals.reduce((s,v)=>s+v,0)/afterVals.length).toFixed(3)}, æ ‡å‡†å·®=${Math.sqrt(afterVals.reduce((s,v)=>s+Math.pow(v-afterVals.reduce((a,b)=>a+b,0)/afterVals.length,2),0)/afterVals.length).toFixed(3)}`);
        
        // æ›´æ–°å›¾è¡¨ä¸­çš„GSRæ•°æ®
        if (chart && chart.updateGSRData) {
          console.log(`ğŸ”„ è°ƒç”¨ chart.updateGSRData() æ›´æ–°å›¾è¡¨`);
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // PPGæ•°æ®ä¸éœ€è¦å¤„ç†
      let ppgCount = 0;
      
      console.log(`ğŸ”„ Z-Scoreæ ‡å‡†åŒ–: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})ä¸ªæ•°æ®ç‚¹`);
      
      // åº”ç”¨VAæ•°æ®æ ‡å‡†åŒ–ç»“æœ
      let vIdx = 0, aIdx = 0;
      for (const record of processedDataLog) {
        // æ ‡å‡†åŒ–VAæ•°æ®
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence = vZScored[vIdx++];
          record.arousal = aZScored[aIdx++];
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // å¼ºåˆ¶åˆ·æ–°GSRå’ŒPPGå›¾è¡¨æ˜¾ç¤º
      if (gsrCount > 0 && chart && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
        console.log(`ğŸ”„ å·²åˆ·æ–°GSRå›¾è¡¨æ˜¾ç¤ºï¼Œ${gsrCount}ä¸ªæ•°æ®ç‚¹`);
      }
      
      // æ›´æ–°ä¸»Yè½´èŒƒå›´ä»¥é€‚åº”æ ‡å‡†åŒ–åçš„VAæ•°æ®
      if (chart && chart.updateMainAxisRange) {
        console.log(`ğŸ”„ è°ƒç”¨ chart.updateMainAxisRange() æ›´æ–°ä¸»Yè½´`);
        chart.updateMainAxisRange(processedDataLog, processedDataLog);
      }
      
      // PPGæ•°æ®ä¸éœ€è¦å¤„ç†ï¼Œè·³è¿‡
      
      const statusMsg = `Z-Scoreæ ‡å‡†åŒ–å®Œæˆ (VA: ${valenceVals.length}, GSR: ${gsrCount}ä¸ªæ•°æ®ç‚¹)`;
      console.log(`âœ… ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });

    // åˆ›å»ºæ—¶é—´å¯¹é½å¤„ç†å™¨å®ä¾‹
    const timeAlignmentProcessor = new TimeAlignmentProcessor();

    // æ—¶é—´å¯¹é½æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('alignDataBtn').addEventListener('click', async () => {
      // æ£€æŸ¥æ•°æ®å¯ç”¨æ€§
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œå‰ç½®æ•°æ®å¤„ç†ï¼ˆå¦‚é‡é‡‡æ ·ã€æ»¤æ³¢ç­‰ï¼‰');
        return;
      }
      
      if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
        alert('è¯·å…ˆå¯¼å…¥GSRæ•°æ®');
        return;
      }
      
      const btn = document.getElementById('alignDataBtn');
      const statusEl = document.getElementById('step2Status');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = 'å¯¹é½ä¸­...';
        statusEl.textContent = 'æ­£åœ¨è¿›è¡Œæ—¶é—´å¯¹é½...';
        statusEl.style.color = '#fbbf24';
        
        // è·å–ç”¨æˆ·é…ç½®
        const config = {
          maxLagSeconds: parseFloat(document.getElementById('maxLagSeconds').value) || 5.0
        };
        
        // å‡†å¤‡æ•°æ® - ä½¿ç”¨ç»è¿‡å¤„ç†çš„æ•°æ®
        const valenceData = processedDataLog.filter(r => r.face && isFinite(r.valence));
        const gsrData = physiologicalData.gsr.filter(item => isFinite(item.gsr));
        
        console.log(`ğŸš€ å¼€å§‹äº’ç›¸å…³æ—¶é—´å¯¹é½`);
        console.log(`ğŸ“Š è¾“å…¥æ•°æ®: Valence ${valenceData.length}ç‚¹, GSR ${gsrData.length}ç‚¹`);
        console.log(`ğŸ“Š æ•°æ®æ¥æº: ä½¿ç”¨ç»è¿‡å¤„ç†çš„æ•°æ® (processedDataLog + physiologicalData.gsr)`);
        
        // æ‰§è¡Œå¯¹é½
        const alignmentResult = await timeAlignmentProcessor.alignData(valenceData, gsrData, config);
        
        // æ›´æ–°å¤„ç†åçš„æ•°æ®
        processedDataLog = alignmentResult.alignedValence;
        dataLog = processedDataLog.map(r => ({ ...r }));
        physiologicalData.gsr = alignmentResult.alignedGSR;
        
        // æ›´æ–°å›¾è¡¨
        loadAllDataToChart();
        
        // æ˜¾ç¤ºç»“æœ
        const report = timeAlignmentProcessor.generateAlignmentReport();
        console.log(report);
        
        const summaryMsg = `äº’ç›¸å…³æ—¶é—´å¯¹é½å®Œæˆ | åç§»: ${alignmentResult.lagSeconds.toFixed(2)}s | ç½®ä¿¡åº¦: ${alignmentResult.confidence.toFixed(3)}`;
        statusEl.textContent = summaryMsg;
        statusEl.style.color = '#4caf50';
        
        updateProcessingStatus('step2', true, summaryMsg);
        
        console.log('âœ… æ—¶é—´å¯¹é½å®Œæˆï¼Œå·²æ›´æ–° processedDataLog å’Œ physiologicalData.gsr');
        
      } catch (error) {
        console.error('æ—¶é—´å¯¹é½å¤±è´¥:', error);
        statusEl.textContent = 'å¯¹é½å¤±è´¥: ' + error.message;
        statusEl.style.color = '#ef4444';
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });



    // æ˜¾ç¤ºè¯¦ç»†åˆ†ææŒ‰é’®
    document.getElementById('showAlignmentDetails').addEventListener('click', () => {
      const report = timeAlignmentProcessor.generateAlignmentReport();
      if (report === 'æ²¡æœ‰å¯¹é½ç»“æœ') {
        alert('è¯·å…ˆæ‰§è¡Œæ—¶é—´å¯¹é½');
      } else {
        console.log('ğŸ“Š è¯¦ç»†å¯¹é½åˆ†ææŠ¥å‘Š:');
        console.log(report);
        alert('è¯¦ç»†æŠ¥å‘Šå·²è¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œè¯·æŒ‰F12æŸ¥çœ‹');
      }
    });
    
    // æ­¥éª¤3: å¯¼æ•°è®¡ç®—
    document.getElementById('sgDerivativeBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œæ ‡å‡†åŒ–å¤„ç†');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('sgWindow').value) || 15;
      const timeArray = processedDataLog.map(r => r.time);
      const valenceArray = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalArray = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const vDerivative = sgDerivative(timeArray, valenceArray, windowSize);
      const aDerivative = sgDerivative(timeArray, arousalArray, windowSize);
      
      derivativeDataLog = processedDataLog.map((r, i) => ({
        time: r.time,
        valence_dt: vDerivative[i],
        arousal_dt: aDerivative[i],
        face: r.face
      }));
      
      // ç«‹å³æ˜¾ç¤ºå¯¼æ•°æ›²çº¿
      chart.updateDerivativeData(derivativeDataLog);
      chart.toggleDerivativeDisplay(true);
      showDerivative = true;
      document.getElementById('showDerivativeBtn').textContent = 'éšè—å¯¼æ•°æ›²çº¿';
      
      updateProcessingStatus('step3', true, `SGå¯¼æ•°è®¡ç®—å®Œæˆï¼Œçª—å£=${windowSize}`);
    });
    
    document.getElementById('slopeDerivativeBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('è¯·å…ˆè¿›è¡Œæ ‡å‡†åŒ–å¤„ç†');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('slopeWindow').value) || 9;
      const timeArray = processedDataLog.map(r => r.time);
      const valenceArray = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalArray = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const vDerivative = slopeByWindow(timeArray, valenceArray, windowSize);
      const aDerivative = slopeByWindow(timeArray, arousalArray, windowSize);
      
      derivativeDataLog = processedDataLog.map((r, i) => ({
        time: r.time,
        valence_dt: vDerivative[i],
        arousal_dt: aDerivative[i],
        face: r.face
      }));
      
      // ç«‹å³æ˜¾ç¤ºå¯¼æ•°æ›²çº¿
      chart.updateDerivativeData(derivativeDataLog);
      chart.toggleDerivativeDisplay(true);
      showDerivative = true;
      document.getElementById('showDerivativeBtn').textContent = 'éšè—å¯¼æ•°æ›²çº¿';
      
      updateProcessingStatus('step3', true, `é²æ£’æ–œç‡è®¡ç®—å®Œæˆï¼Œçª—å£=${windowSize}`);
    });
    
    // æ­¥éª¤4: å¯¼æ•°åå¤„ç†
    document.getElementById('smoothDerivativeBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('è¯·å…ˆè®¡ç®—å¯¼æ•°');
        return;
      }
      
      const vDerivativeSmoothed = movingAverage(derivativeDataLog.map(r => r.valence_dt), 3);
      const aDerivativeSmoothed = movingAverage(derivativeDataLog.map(r => r.arousal_dt), 3);
      
      for (let i = 0; i < derivativeDataLog.length; i++) {
        derivativeDataLog[i].valence_dt = vDerivativeSmoothed[i];
        derivativeDataLog[i].arousal_dt = aDerivativeSmoothed[i];
      }
      
      // æ›´æ–°å¯¼æ•°æ˜¾ç¤º
      chart.updateDerivativeData(derivativeDataLog);
      
      updateProcessingStatus('step4', true, 'å¯¼æ•°å¹³æ»‘å®Œæˆ(3ç‚¹ç§»åŠ¨å¹³å‡)');
    });
    
    document.getElementById('normalizeDerivativeBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('è¯·å…ˆè®¡ç®—å¯¼æ•°');
        return;
      }
      
      const vDtVals = derivativeDataLog.filter(r => r.face).map(r => r.valence_dt).filter(Number.isFinite);
      const aDtVals = derivativeDataLog.filter(r => r.face).map(r => r.arousal_dt).filter(Number.isFinite);
      
      const vDtNormalized = zscore(vDtVals);
      const aDtNormalized = zscore(aDtVals);
      
      let vIdx = 0, aIdx = 0;
      for (const record of derivativeDataLog) {
        if (record.face && Number.isFinite(record.valence_dt) && Number.isFinite(record.arousal_dt)) {
          record.valence_dt = vDtNormalized[vIdx++];
          record.arousal_dt = aDtNormalized[aIdx++];
        }
      }
      
      // æ›´æ–°å¯¼æ•°æ˜¾ç¤º
      chart.updateDerivativeData(derivativeDataLog);
      
      updateProcessingStatus('step4', true, 'å¯¼æ•°æ ‡å‡†åŒ–å®Œæˆ');
    });
    
    // æ­¥éª¤5: äº‹ä»¶æ£€æµ‹
    document.getElementById('detectEventsBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('è¯·å…ˆè®¡ç®—å¯¼æ•°');
        return;
      }
      
      // ä»ç”¨æˆ·è¾“å…¥è·å–é˜ˆå€¼
      const upThreshold = parseFloat(document.getElementById('upThreshold').value) || 0.12;
      const downThreshold = parseFloat(document.getElementById('downThreshold').value) || -0.12;
      const minDuration = parseFloat(document.getElementById('minDuration').value) || 0.8;
      
      // éªŒè¯é˜ˆå€¼çš„åˆç†æ€§
      if (upThreshold <= 0) {
        alert('ä¸Šå‡é˜ˆå€¼å¿…é¡»å¤§äº0');
        return;
      }
      if (downThreshold >= 0) {
        alert('ä¸‹é™é˜ˆå€¼å¿…é¡»å°äº0');
        return;
      }
      if (upThreshold <= Math.abs(downThreshold)) {
        if (!confirm(`å½“å‰è®¾ç½®ï¼šä¸Šå‡é˜ˆå€¼=${upThreshold}, ä¸‹é™é˜ˆå€¼=${downThreshold}\n\nå»ºè®®ä¸Šå‡é˜ˆå€¼çš„ç»å¯¹å€¼å¤§äºä¸‹é™é˜ˆå€¼çš„ç»å¯¹å€¼ï¼Œä»¥æ›´å¥½åœ°æ•æ‰æƒ…ç»ªå˜åŒ–ç‰¹æ€§ã€‚\n\næ˜¯å¦ç»§ç»­ä½¿ç”¨å½“å‰è®¾ç½®ï¼Ÿ`)) {
          return;
        }
      }
      
      const timeArray = derivativeDataLog.map(r => r.time);
      const vDtArray = derivativeDataLog.map(r => r.valence_dt);
      const aDtArray = derivativeDataLog.map(r => r.arousal_dt);
      
      const vEvents = detectEvents(timeArray, vDtArray, upThreshold, downThreshold, minDuration);
      const aEvents = detectEvents(timeArray, aDtArray, upThreshold, downThreshold, minDuration);
      
      eventsLog = [
        ...vEvents.map(e => ({ ...e, type: `valence_${e.type}` })),
        //todo æš‚æ—¶åªåŸºäºvè¯•è¯•
        // ...aEvents.map(e => ({ ...e, type: `arousal_${e.type}` }))
      ].sort((a, b) => a.t - b.t);
      
      // ç«‹å³æ˜¾ç¤ºäº‹ä»¶æ ‡è®°
      chart.updateEventData(eventsLog, processedDataLog);
      chart.toggleEventDisplay(true);
      showEvents = true;
      document.getElementById('showEventsBtn').style.display = 'inline-block';
      document.getElementById('showEventsBtn').textContent = 'éšè—äº‹ä»¶æ ‡è®°';
      
      updateProcessingStatus('step5', true, `äº‹ä»¶æ£€æµ‹å®Œæˆï¼š${eventsLog.length}ä¸ªäº‹ä»¶ (ä¸Šå‡>${upThreshold}, ä¸‹é™<${downThreshold}, æŒç»­>${minDuration}s)`);
      console.log('æ£€æµ‹åˆ°çš„äº‹ä»¶:', eventsLog);
      console.log(`ä½¿ç”¨é˜ˆå€¼: ä¸Šå‡=${upThreshold}, ä¸‹é™=${downThreshold}, æœ€å°æŒç»­=${minDuration}s`);
    });

    // æ§åˆ¶æŒ‰é’®
    document.getElementById('resetProcessingBtn').addEventListener('click', () => {
      processedDataLog = originalDataLog.map(r => ({ ...r }));
      dataLog = processedDataLog.map(r => ({ ...r }));
      derivativeDataLog = [];
      eventsLog = [];
      
      // é‡ç½®NeuroKitå’Œå¼‚å¸¸æ£€æµ‹çŠ¶æ€
      neurokitProcessed = false;
      anomalyDetected = false;
      cleanedGSRDataPanel = null;
      anomalyResultsPanel = null;
      
      // æ¸…é™¤å¼‚å¸¸æ£€æµ‹ç»“æœ
      anomalyDetectionResults = null;
      showingAnomalies = false;
      showingIntervals = false;
      if (isolationForestDetector) {
        isolationForestDetector.results = null;
        isolationForestDetector.hideAnomalies();
      }
      
      // æ¸…é™¤å›¾è¡¨ä¸Šçš„MLå¼‚å¸¸ç‚¹å’Œå¼‚å¸¸åŒºé—´
      if (chart) {
        chart.hideMLAnomalies();
        if (typeof chart.hideAnomalyIntervals === 'function') {
          chart.hideAnomalyIntervals();
        }
      }
      
      // é‡ç½®å¼‚å¸¸æ£€æµ‹UI
      document.getElementById('anomalyDetectionStatus').textContent = 'æœªè¿è¡Œæ£€æµ‹';
      document.getElementById('anomalyDetectionStatus').style.color = '#888';
      document.getElementById('anomalyDetectionResults').style.display = 'none';
      document.getElementById('toggleAnomalyDisplay').disabled = true;
      document.getElementById('toggleAnomalyDisplay').textContent = 'æ˜¾ç¤ºå¼‚å¸¸ç‚¹';
      document.getElementById('toggleIntervalDisplay').disabled = true;
      document.getElementById('toggleIntervalDisplay').textContent = 'ğŸ”¶ æ˜¾ç¤ºå¼‚å¸¸åŒºé—´';
      document.getElementById('toggleIntervalDisplay').style.background = '#8b5cf6';
      document.getElementById('recalculateIntervals').disabled = true;
      
      // éšè—å¯¼æ•°æ›²çº¿
      chart.toggleDerivativeDisplay(false);
      showDerivative = false;
      document.getElementById('showDerivativeBtn').textContent = 'æ˜¾ç¤ºå¯¼æ•°æ›²çº¿';
      
      // éšè—äº‹ä»¶æ ‡è®°
      chart.toggleEventDisplay(false);
      showEvents = false;
      document.getElementById('showEventsBtn').style.display = 'none';
      document.getElementById('showEventsBtn').textContent = 'æ˜¾ç¤ºäº‹ä»¶æ ‡è®°';
      
      // æ¸…é™¤å¼‚å¸¸ç‚¹å’Œæ¸…ç†åæ•°æ®
      chart.clearAnomalies();
      clearCleanedData();
      
      Object.keys(processingSteps).forEach(step => {
        updateProcessingStatus(step, false);
      });
      
      loadAllDataToChart();
      updateProcessingStatus('step0', false, 'å¤„ç†å·²é‡ç½®ï¼Œå¯é‡æ–°å¼€å§‹');
    });
    
    document.getElementById('showDerivativeBtn').addEventListener('click', () => {
      showDerivative = !showDerivative;
      
      if (derivativeDataLog.length > 0) {
        chart.toggleDerivativeDisplay(showDerivative);
        
        const derivativeValenceData = derivativeDataLog
          .filter(r => r.face && Number.isFinite(r.valence_dt))
          .map(r => ({ x: r.time, y: r.valence_dt }));
        const derivativeArousalData = derivativeDataLog
          .filter(r => r.face && Number.isFinite(r.arousal_dt))
          .map(r => ({ x: r.time, y: r.arousal_dt }));
        
        console.log(`å¯¼æ•°æ˜¾ç¤º${showDerivative ? 'å¼€å¯' : 'å…³é—­'}ï¼šVå¯¼æ•°${derivativeValenceData.length}ç‚¹ï¼ŒAå¯¼æ•°${derivativeArousalData.length}ç‚¹`);
      } else {
        alert('è¯·å…ˆè®¡ç®—å¯¼æ•°æ•°æ®');
        showDerivative = false;
      }
      
      document.getElementById('showDerivativeBtn').textContent = 
        showDerivative ? 'éšè—å¯¼æ•°æ›²çº¿' : 'æ˜¾ç¤ºå¯¼æ•°æ›²çº¿';
    });
    
    // äº‹ä»¶æ˜¾ç¤ºæ§åˆ¶
    document.getElementById('showEventsBtn').addEventListener('click', () => {
      showEvents = !showEvents;
      
      if (eventsLog.length > 0) {
        chart.toggleEventDisplay(showEvents);
        console.log(`äº‹ä»¶æ ‡è®°${showEvents ? 'æ˜¾ç¤º' : 'éšè—'}ï¼šå…±${eventsLog.length}ä¸ªäº‹ä»¶`);
      } else {
        alert('è¯·å…ˆæ£€æµ‹äº‹ä»¶');
        showEvents = false;
      }
      
      document.getElementById('showEventsBtn').textContent = 
        showEvents ? 'éšè—äº‹ä»¶æ ‡è®°' : 'æ˜¾ç¤ºäº‹ä»¶æ ‡è®°';
    });
    
    document.getElementById('exportProcessedBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('æ²¡æœ‰å¤„ç†åçš„æ•°æ®å¯å¯¼å‡º');
        return;
      }
      
      // æ„å»ºåŒ…å«å¯¼æ•°å’Œäº‹ä»¶çš„CSV
      let header = ['time', 'valence', 'arousal', 'face'];
      if (derivativeDataLog.length > 0) {
        header.push('valence_dt', 'arousal_dt');
      }
      
      const rows = processedDataLog.map((r, i) => {
        let row = [
          r.time.toFixed(3),
          Number.isFinite(r.valence) ? r.valence.toFixed(4) : '',
          Number.isFinite(r.arousal) ? r.arousal.toFixed(4) : '',
          r.face ? '1' : '0'
        ];
        
        if (derivativeDataLog.length > 0 && derivativeDataLog[i]) {
          row.push(
            Number.isFinite(derivativeDataLog[i].valence_dt) ? derivativeDataLog[i].valence_dt.toFixed(4) : '',
            Number.isFinite(derivativeDataLog[i].arousal_dt) ? derivativeDataLog[i].arousal_dt.toFixed(4) : ''
          );
        }
        
        return row.join(',');
      });
      
      rows.unshift(header.join(','));
      
      // æ·»åŠ äº‹ä»¶ä¿¡æ¯ä½œä¸ºæ³¨é‡Š
      if (eventsLog.length > 0) {
        rows.push('');
        rows.push('# Events:');
        eventsLog.forEach(event => {
          rows.push(`# ${event.type},${event.t.toFixed(3)},${event.dur.toFixed(3)}`);
        });
      }
      
      const csvContent = rows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = 'processed_va_data.csv';
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    });

  </script>

</body>
</html>
