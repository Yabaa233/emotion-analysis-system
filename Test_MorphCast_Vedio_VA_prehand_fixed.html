<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Valence/Arousal + 7 Emotions — Analyze → XDF → Playback</title>
  <style>
    body { background:#222; color:#fff; font-family:sans-serif; padding:1em; }
    .row { margin: 1em 0; }
    .muted { color: #888; margin-left: 1em; }
    button { margin-right: 0.5em; }
    canvas { box-shadow: 0 0 12px; }
    video { display:block; margin-bottom:8px; width:100%; max-width:720px; background:#000; }
    canvas { background:#333; max-width:100%; height:400px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; align-items:center; }
    button { padding:0.5em 1em; font-size:14px; border:0; border-radius:6px; background:#444; color:#fff; cursor:pointer; }
    button:hover { background:#555; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { opacity:.75; font-size:12px; }
    
    /* 新增控制面板样式 */
    input[type="checkbox"] { transform: scale(1.2); margin-right: 3px; }
    input[type="number"] { padding: 4px 8px; border: 1px solid #666; border-radius: 4px; background: #222; color: #fff; }
    input[type="number"]:focus { border-color: #888; outline: none; }
    label { cursor: pointer; user-select: none; }
  </style>
</head>
<body>
  <h2>🎥 生理数据分析回放</h2>

  <div class="row">
    <button id="selectVideoBtn">📁 选择视频文件</button>
    <input id="videoInput" type="file" accept="video/*" style="display:none">
    <span id="videoInfo" class="muted">请先选择视频文件</span>
  </div>

  <div style="position: relative; display: inline-block;">
    <video id="video" controls crossorigin="anonymous" style="display:none;">
      <!-- 视频源将通过JavaScript动态设置 -->
    </video>
    
    <!-- 检测区域覆盖层 -->
    <div id="regionOverlay" style="
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      border: 2px solid #ff0000;
      background: rgba(255,0,0,0.1);
      display: none;
      z-index: 10;
    "></div>
    
    <!-- 拖拽控制点 -->
    <div id="dragHandle" style="
      position: absolute;
      width: 12px;
      height: 12px;
      background: #ff0000;
      border: 2px solid #fff;
      cursor: se-resize;
      display: none;
      z-index: 11;
    "></div>
  </div>

  <div class="row">
    <button id="analyzeBtn" disabled>① Analyze（预处理）</button>
    <button id="downloadBtn" disabled>⬇️ 导出 XDF</button>
    <button id="importBtn">📂 导入 XDF 回放</button>
    <input id="xdfInput" type="file" accept=".xdf" style="display:none">
    <label for="frameInterval" style="margin-left: 20px;">每N帧抽一帧:</label>
    <input id="frameInterval" type="number" min="1" max="300" value="10" style="width:60px;">
    <span id="status" class="muted"></span>
  </div>

  <div class="row">
    <button id="toggleRegion">启用区域检测</button>
    <span id="regionInfo" style="margin-left: 20px; color: #ccc;">点击启用后可在视频上拖拽选择检测区域</span>
  </div>

  <div class="row" id="zoomRow">
    <label for="windowStart">起点时间：</label>
    <input id="windowStart" type="number" min="0" step="0.1" placeholder="秒" style="width:120px" value="0">
    <label for="windowEnd">终点时间：</label>
    <input id="windowEnd" type="number" min="0" step="0.1" placeholder="秒" style="width:120px" value="30">
    <button id="applyWindow">应用</button>
  </div>

  <!-- 数据显示控制面板 -->
  <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin: 10px 0;">
    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
      
      <!-- 检测模式控制 -->
      <div style="display: flex; gap: 15px; align-items: center; border-right: 1px solid #555; padding-right: 15px;">
        <!-- API 选择器 -->
        <div style="display: flex; gap: 10px; align-items: center; border-right: 1px solid #666; padding-right: 12px;">
          <label style="color: #ccc; font-size: 12px;">情绪检测API:</label>
          <select id="apiSelector" style="background: #444; color: #fff; border: 1px solid #666; border-radius: 4px; padding: 2px 6px; font-size: 12px;">
            <option value="morphcast">MorphCast (云端)</option>
            <option value="deepface">DeepFace (本地)</option>
          </select>
          <span id="apiStatus" style="font-size: 11px; color: #888;">状态: 未连接</span>
        </div>
        
        <label style="display: flex; align-items: center; gap: 5px; color: #ccc;">
          <input type="checkbox" id="emotionToggle" checked>
          <span>启用7类情绪检测</span>
        </label>
      </div>
    </div>
    
    <!-- 状态显示 -->
    <div style="margin-top: 8px; font-size: 12px; color: #888;">
      <span id="dataProcessingStatus">数据处理状态：正常显示</span>
    </div>
  </div>

  <!-- 生理信号数据导入区域 -->
  <div class="row" style="margin-top: 10px; padding: 15px; border: 1px solid #444; border-radius: 5px;">
    <h3 style="color: #ccc; margin: 0 0 10px 0;">📊 生理信号数据导入</h3>
    
    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
      <!-- 文件导入 -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">导入生理信号数据</label>
        <input type="file" id="physioFileInput" accept=".csv,.xdf,.json" style="color: #ccc; background: #333; border: 1px solid #555; padding: 5px; border-radius: 3px;">
      </div>
      
      <!-- 采样配置 -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">数据采样</label>
        <div style="display: flex; gap: 5px; align-items: center;">
          <label style="color: #aaa; font-size: 11px;">最大点数:</label>
          <input type="number" id="maxDataPoints" value="20000" min="100" max="50000" step="100" style="width: 80px; padding: 2px 4px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px; font-size: 11px;">
        </div>
      </div>
      
      <!-- 数据状态 -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">数据状态</label>
        <span id="physiologicalStatus" style="color: #888; font-size: 12px;">未导入数据</span>
      </div>
      
      <!-- 转换导出 -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <label style="color: #ccc; font-size: 12px;">数据处理</label>
        <button id="convertToXdfBtn" disabled style="padding: 6px 12px; font-size: 12px; background: #4caf50; border: none; border-radius: 4px; color: white; cursor: pointer;">转换并导出XDF</button>
      </div>
      
      <!-- 异常标记状态 -->
      <div style="display: flex; flex-direction: column; gap: 5px;">
        <span id="anomalyMarkingStatus" style="color: #4caf50; font-size: 12px; font-weight: bold;">🎯 Ctrl+点击VA图表标记异常点 (0个标记)</span>
      </div>
    </div>
  </div>

  <canvas id="chart" style="width: 100%; max-width: 100%;"></canvas>
  
  <!-- Rate-of-Change 数据后处理控制面板 -->
  <div id="rocProcessingPanel" style="display: none; margin-top: 20px; background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #444;">
    <h3 style="color: #fff; margin-bottom: 15px;">📊 Rate-of-Change 数据后处理流程</h3>
    
    <!-- 步骤0: 基础整理 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">0️⃣ 基础整理</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="sortDataBtn">时间对齐/去重</button>
        <button id="resampleBtn">重采样(5Hz)</button>
        <button id="resample50HzBtn">重采样(50Hz)</button>
        <span id="step0Status" class="muted">未处理</span>
      </div>
    </div>

    <!-- 步骤0.5: NeuroKit GSR预处理 -->
    <div class="row" style="background: #2d5016; padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px solid #4caf50;">
      <h4 style="color: #4caf50; margin: 0 0 10px 0;">🧠 NeuroKit GSR预处理</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <select id="neurokitMethod" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
          <option value="neurokit">NeuroKit2官方</option>
          <option value="biosppy">BioSPPy兼容</option>
          <option value="cvxeda">cvxEDA分解</option>
          <option value="none">跳过预处理</option>
        </select>
        <button id="neurokitProcessBtn" style="background: #4caf50; color: #fff;">NeuroKit处理GSR</button>
        <span id="neurokitStatus" class="muted">未处理</span>
        <div id="neurokitProgress" style="display: none; color: #4caf50; font-size: 12px;"></div>
      </div>
    </div>
    
    <!-- 异常检测区域 -->
    <div class="row" style="margin-top: 15px; padding: 15px; border: 1px solid #6366f1; border-radius: 5px; background: #1a1a2e;">
      <h3 style="color: #a78bfa; margin: 0 0 15px 0;">🤖 机器学习异常检测 (Isolation Forest)</h3>
      
      <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 10px;">
        <!-- 数据源选择 -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">数据源</label>
          <select id="anomalyDataSource" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
            <option value="gsr">皮电数据 (GSR)</option>
            <option value="valence">效价数据 (Valence)</option>
            <option value="combined">🔗 联合数据 (GSR + Valence)</option>
          </select>
        </div>
        
        <!-- 污染率设置 -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">异常比例</label>
          <select id="contaminationRate" style="background: #444; color: #fff; border: 1px solid #666; padding: 5px; border-radius: 3px;">
            <option value="0.05">5% (严格)</option>
            <option value="0.10" selected>10% (标准)</option>
            <option value="0.15">15% (宽松)</option>
            <option value="0.20">20% (非常宽松)</option>
          </select>
        </div>
        
        <!-- 区间检测参数 -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">🔶 区间参数</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">最大间隔:</label>
            <input id="maxGapParam" type="number" value="2.0" min="0.1" max="10" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">秒</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">最小时长:</label>
            <input id="minDurationParam" type="number" value="1.0" min="0.1" max="30" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">秒</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 11px; min-width: 50px;">前向偏移:</label>
            <input id="forwardOffsetParam" type="number" value="0.0" min="0.0" max="1.0" step="0.1" style="width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 3px; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">比例</span>
          </div>
        </div>
        
        <!-- 操作按钮 -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">操作</label>
          <button id="runAnomalyDetectionBtn" style="padding: 6px 12px; font-size: 12px; background: #6366f1; border: none; border-radius: 4px; color: white;">运行检测</button>
        </div>
        
        <!-- 显示控制 -->
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <label style="color: #ccc; font-size: 12px;">显示</label>
          <button id="toggleAnomalyDisplay" disabled style="padding: 6px 12px; font-size: 12px; background: #ef4444; border: none; border-radius: 4px; color: white;">显示异常点</button>
          <button id="toggleIntervalDisplay" disabled style="padding: 6px 12px; font-size: 12px; background: #8b5cf6; border: none; border-radius: 4px; color: white;">🔶 显示异常区间</button>
          <button id="recalculateIntervals" disabled style="padding: 6px 12px; font-size: 12px; background: #f59e0b; border: none; border-radius: 4px; color: white;">🔄 重新计算区间</button>
        </div>
      </div>
      
      <!-- 状态和进度 -->
      <div id="anomalyDetectionStatus" style="margin-top: 8px; font-size: 12px; color: #888;">
        未运行检测
      </div>
      
      <!-- 检测结果 -->
      <div id="anomalyDetectionResults" style="display: none; margin-top: 10px; padding: 8px; background: rgba(99, 102, 241, 0.1); border-radius: 4px;">
        <div style="color: #a78bfa; font-size: 12px;">
          检测完成：<span id="anomalyCount">0</span> 个异常点 / <span id="totalPoints">0</span> 个数据点 
          (<span id="anomalyPercentage">0%</span>)
        </div>
      </div>
    </div>
    
    <!-- 步骤1: 去伪迹/去尖峰 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">1️⃣ 去伪迹/去尖峰</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">中值滤波窗口:</label>
        <input id="medianWindow" type="number" min="3" max="15" step="2" value="5" style="width:60px;">
        <button id="medianFilterBtn">应用中值滤波</button>
        <button id="outlierClipBtn">异常值截断</button>
        <span id="step1Status" class="muted">未处理</span>
      </div>
    </div>
    
    <!-- 步骤2: 基线与尺度 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">2️⃣ 基线与尺度标准化</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="zeroMeanBtn">零均值化</button>
        <button id="zeroScaleBtn">归零缩放</button>
        <button id="zScoreBtn">Z-Score标准化</button>
        
        <!-- 新增：时间对齐功能 -->
        <div style="display: flex; gap: 5px; align-items: center; margin-left: 15px; border-left: 1px solid #555; padding-left: 15px;">
          <label style="color: #ccc; font-size: 12px;">时间对齐:</label>
          <button id="alignDataBtn" style="padding: 4px 8px; font-size: 12px; background: #2196f3; border: none; border-radius: 3px; color: white;">互相关对齐VA-GSR</button>
        </div>
        
        <span id="step2Status" class="muted">未处理</span>
      </div>
      
      <!-- 对齐详细参数控制 -->
      <div id="alignmentControls" style="margin-top: 8px; padding: 8px; background: #2a2a2a; border-radius: 4px;">
        <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
          <div style="display: flex; gap: 5px; align-items: center;">
            <label style="color: #ccc; font-size: 11px;">最大延迟:</label>
            <input id="maxLagSeconds" type="number" min="0" max="30" step="0.1" value="5.0" style="width: 60px; padding: 2px 4px; background: #444; color: #fff; border: 1px solid #666; border-radius: 3px; font-size: 11px;">
            <span style="color: #888; font-size: 11px;">秒</span>
          </div>
          
          <button id="showAlignmentDetails" style="padding: 3px 6px; font-size: 11px; background: #666; border: none; border-radius: 3px; color: white;">详细分析</button>
        </div>
      </div>
    </div>
    
    <!-- 步骤3: 导数计算 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">3️⃣ 变化率计算</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">SG窗口:</label>
        <input id="sgWindow" type="number" min="7" max="31" step="2" value="15" style="width:60px;">
        <button id="sgDerivativeBtn">SG导数</button>
        <label style="color: #ccc;">斜率窗口:</label>
        <input id="slopeWindow" type="number" min="5" max="21" step="2" value="9" style="width:60px;">
        <button id="slopeDerivativeBtn">鲁棒斜率</button>
        <span id="step3Status" class="muted">未处理</span>
      </div>
    </div>
    
    <!-- 步骤4: 导数后处理 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">4️⃣ 导数后处理</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <button id="smoothDerivativeBtn">导数平滑(3点)</button>
        <button id="normalizeDerivativeBtn">导数标准化</button>
        <span id="step4Status" class="muted">未处理</span>
      </div>
    </div>
    
    <!-- 步骤5: 事件判定 -->
    <div class="row" style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
      <h4 style="color: #fff; margin: 0 0 10px 0;">5️⃣ 事件判定</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label style="color: #ccc;">上升阈值:</label>
        <input id="upThreshold" type="number" min="-2" max="2" step="0.01" value="0.12" style="width:80px;">
        <label style="color: #ccc;">下降阈值:</label>
        <input id="downThreshold" type="number" min="-2" max="2" step="0.01" value="-0.12" style="width:80px;">
        <label style="color: #ccc;">最小持续(s):</label>
        <input id="minDuration" type="number" min="0.1" max="5" step="0.1" value="0.8" style="width:80px;">
        <button id="detectEventsBtn">检测事件</button>
        <button id="showEventsBtn" style="display:none;">显示事件标记</button>
        <span id="step5Status" class="muted">未处理</span>
      </div>
    </div>

    <!-- 控制按钮 -->
    <div class="row" style="border-top: 1px solid #555; padding-top: 10px;">
      <button id="resetProcessingBtn" style="background: #d32f2f;">重置所有处理</button>
      <button id="showDerivativeBtn">显示/隐藏导数曲线</button>
      <button id="exportProcessedBtn">导出处理后数据</button>
      <span id="processingStatus" style="color: #4caf50; margin-left: 20px;">就绪</span>
    </div>
  
  <!-- 7类情绪显示区域 -->
  <div id="emotionChartContainer" style="margin-top: 20px;">
    <h3 style="color: #fff; margin-bottom: 10px;">🎭 7类情绪概率分布</h3>
    <canvas id="emotionChart" style="background:#333; max-width:100%; height:300px;"></canvas>
    
    <!-- 当前时间点的情绪详情 -->
    <div id="currentEmotionDetails" style="margin-top: 10px; padding: 10px; background: #333; border-radius: 5px;">
      <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
        <span id="currentEmotionDisplay" style="color: #fff; font-size: 16px; font-weight: bold;">--</span>
      </div>
    </div>
  </div>

  <!-- SDK + Chart.js + Numeric.js -->
  <script src="https://ai-sdk.morphcast.com/v1.16/ai-sdk.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

  <script type="module">
    import { VAChart } from './va-chart.js';

    // 方式C：在此写死 MorphCast License Key（优先使用）。留空则按 URL/localStorage 读取。
    const LICENSE_KEY = 'skb80c78744414c9ff1cfb03e980a675a55b6eea31e6cd';

    // EDA信号预处理类 - 基于NeuroKit方法
    class EDAPreprocessor {
      constructor() {
        this.apiUrl = 'http://localhost:8080'; // DeepFace API地址 (包含EDA处理功能)
        this.methods = {
          'neurokit': 'NeuroKit2官方方法',
          'biosppy': 'BioSPPy兼容方法', 
          'cvxeda': 'cvxEDA分解方法',
          'none': '无预处理'
        };
        this.fallbackEnabled = true; // 启用备用方法
      }

      // 主要的EDA清理函数 - 通过API调用
      async clean(edaSignal, samplingRate = 50, method = 'neurokit', progressCallback = null) {
        console.log(`EDA预处理开始: ${edaSignal.length}个数据点, 采样率=${samplingRate}Hz, 方法=${method}`);
        
        if (method === 'none') {
          if (progressCallback) progressCallback({ progress: 100, message: '跳过预处理' });
          return [...edaSignal];
        }

        try {
          // 尝试调用Python API
          if (progressCallback) progressCallback({ progress: 10, message: '连接NeuroKit2 API...' });
          
          const response = await fetch(`${this.apiUrl}/eda/clean`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              signal: edaSignal,
              sampling_rate: samplingRate,
              method: method
            }),
            timeout: 30000 // 30秒超时
          });

          if (progressCallback) progressCallback({ progress: 50, message: 'NeuroKit2处理中...' });

          if (!response.ok) {
            throw new Error(`API调用失败: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            if (progressCallback) progressCallback({ progress: 90, message: 'NeuroKit2处理完成' });
            
            console.log(`NeuroKit2预处理完成:`, result.data);
            console.log(`质量评分: ${result.data.quality_score}`);
            console.log(`使用方法: ${result.data.method_used}`);
            
            if (progressCallback) progressCallback({ progress: 100, message: `官方${result.data.method_used}预处理完成` });
            return result.data.cleaned_signal;
          } else {
            throw new Error(result.error || 'API返回错误状态');
          }

        } catch (error) {
          console.warn(`NeuroKit2 API调用失败: ${error.message}, 使用备用方法`);
          
          if (this.fallbackEnabled) {
            if (progressCallback) progressCallback({ progress: 60, message: 'API不可用，使用备用预处理...' });
            return await this.fallbackClean(edaSignal, samplingRate, method, progressCallback);
          } else {
            throw error;
          }
        }
      }

      // EDA信号分解 - 通过API调用
      async decompose(edaSignal, samplingRate = 50, progressCallback = null) {
        try {
          if (progressCallback) progressCallback({ progress: 10, message: '连接分解API...' });
          
          const response = await fetch(`${this.apiUrl}/eda/decompose`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              signal: edaSignal,
              sampling_rate: samplingRate
            }),
            timeout: 30000
          });

          if (progressCallback) progressCallback({ progress: 70, message: 'NeuroKit2分解中...' });

          if (!response.ok) {
            throw new Error(`分解API调用失败: ${response.status}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            if (progressCallback) progressCallback({ progress: 100, message: 'NeuroKit2分解完成' });
            console.log(`EDA信号分解完成:`, result.data);
            return result.data;
          } else {
            throw new Error(result.error || '分解API返回错误');
          }

        } catch (error) {
          console.warn(`分解API调用失败: ${error.message}`);
          if (progressCallback) progressCallback({ progress: 100, message: '分解失败' });
          throw error;
        }
      }

      // 检查API可用性
      async checkApiStatus() {
        try {
          const response = await fetch(`${this.apiUrl}/eda/info`, {
            method: 'GET',
            timeout: 5000
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('EDA API状态:', result);
            return result;
          } else {
            throw new Error(`API状态检查失败: ${response.status}`);
          }
        } catch (error) {
          console.warn(`NeuroKit2 API不可用: ${error.message}`);
          return { neurokit_available: false, error: error.message };
        }
      }

      // 备用的本地预处理方法
      async fallbackClean(edaSignal, samplingRate, method, progressCallback) {
        console.log('使用备用预处理方法（非官方NeuroKit2）');
        
        let cleanedSignal = [...edaSignal];
        
        try {
          // 步骤1: 去除明显异常值
          if (progressCallback) progressCallback({ progress: 70, message: '备用方法: 去除异常值...' });
          cleanedSignal = this.removeOutliers(cleanedSignal);
          
          // 步骤2: 中值滤波
          if (progressCallback) progressCallback({ progress: 80, message: '备用方法: 中值滤波...' });
          cleanedSignal = this.medianFilter(cleanedSignal, 5);
          
          // 步骤3: 简单低通滤波
          if (progressCallback) progressCallback({ progress: 90, message: '备用方法: 低通滤波...' });
          cleanedSignal = this.simpleMovingAverage(cleanedSignal, Math.max(3, Math.floor(samplingRate * 0.1)));
          
          if (progressCallback) progressCallback({ progress: 100, message: `备用预处理完成 (${method})` });
          
          console.log(`备用预处理完成: ${cleanedSignal.length}个数据点`);
          return cleanedSignal;
          
        } catch (error) {
          console.error('备用预处理也失败:', error);
          if (progressCallback) progressCallback({ progress: 100, message: '预处理失败' });
          return edaSignal; // 返回原始信号
        }
      }

      // 备用方法：去除异常值
      removeOutliers(data, threshold = 3) {
        const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
        const std = Math.sqrt(data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length);
        
        return data.map(val => {
          if (Math.abs(val - mean) > threshold * std) {
            return mean; // 用均值替换异常值
          }
          return val;
        });
      }

      // 备用方法：中值滤波
      medianFilter(data, windowSize = 5) {
        const filtered = [];
        const halfWindow = Math.floor(windowSize / 2);
        
        for (let i = 0; i < data.length; i++) {
          const window = [];
          
          const start = Math.max(0, i - halfWindow);
          const end = Math.min(data.length - 1, i + halfWindow);
          
          for (let j = start; j <= end; j++) {
            window.push(data[j]);
          }
          
          window.sort((a, b) => a - b);
          filtered[i] = window[Math.floor(window.length / 2)];
        }
        
        return filtered;
      }

      // 备用方法：简单移动平均
      simpleMovingAverage(data, windowSize = 5) {
        const smoothed = [];
        const halfWindow = Math.floor(windowSize / 2);
        
        for (let i = 0; i < data.length; i++) {
          let sum = 0;
          let count = 0;
          
          const start = Math.max(0, i - halfWindow);
          const end = Math.min(data.length - 1, i + halfWindow);
          
          for (let j = start; j <= end; j++) {
            sum += data[j];
            count++;
          }
          
          smoothed[i] = sum / count;
        }
        
        return smoothed;
      }
    }

    const video = document.getElementById('video');
    const selectVideoBtn = document.getElementById('selectVideoBtn');
    const videoInput = document.getElementById('videoInput');
    const videoInfo = document.getElementById('videoInfo');
    const chartCanvas = document.getElementById('chart');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const importBtn = document.getElementById('importBtn');
    const xdfInput = document.getElementById('xdfInput');
    const frameIntervalInput = document.getElementById('frameInterval');
    const statusEl = document.getElementById('status');

    // ===== 异常标记功能 =====
    let manualAnomalyMarks = [];

    // 添加异常标记
    function addAnomalyMark(time, valence) {
      console.log(`🎯 尝试添加异常标记: 时间=${time.toFixed(3)}s, valence=${valence.toFixed(3)}`);
      console.log(`📊 当前已有标记数量: ${manualAnomalyMarks.length}`);
      
      const existingIndex = manualAnomalyMarks.findIndex(mark => 
        Math.abs(mark.time - time) < 0.1
      );
      
      if (existingIndex === -1) {
        const newMark = {
          time: time,
          valence: valence,
          marked: true,
          markTime: Date.now()
        };
        
        manualAnomalyMarks.push(newMark);
        console.log(`✅ 成功添加异常标记:`, newMark);
        console.log(`📈 新的标记总数: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
      } else {
        console.log(`⚠️ 时间 ${time.toFixed(3)}s 已有异常标记，跳过添加`);
        console.log(`🔍 现有标记:`, manualAnomalyMarks[existingIndex]);
      }
    }

    // 移除异常标记
    function removeAnomalyMark(time) {
      console.log(`🗑️ 尝试移除异常标记: 时间=${time.toFixed(3)}s`);
      console.log(`📊 移除前标记数量: ${manualAnomalyMarks.length}`);
      console.log(`📋 当前所有标记的时间:`, manualAnomalyMarks.map(mark => mark.time.toFixed(3)));
      
      // 寻找匹配的标记
      let bestMatch = null;
      let bestDistance = Infinity;
      let bestIndex = -1;
      
      manualAnomalyMarks.forEach((mark, index) => {
        const distance = Math.abs(mark.time - time);
        console.log(`🔍 检查标记${index}: 时间=${mark.time.toFixed(3)}s, 距离=${distance.toFixed(3)}s`);
        
        if (distance < bestDistance) {
          bestDistance = distance;
          bestMatch = mark;
          bestIndex = index;
        }
      });
      
      console.log(`🎯 最佳匹配: 索引=${bestIndex}, 距离=${bestDistance.toFixed(3)}s, 阈值=0.1s`);
      
      if (bestIndex !== -1 && bestDistance < 0.1) {
        const removed = manualAnomalyMarks.splice(bestIndex, 1)[0];
        console.log(`✅ 成功移除异常标记:`, removed);
        console.log(`📉 新的标记总数: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
        return true;
      } else if (bestIndex !== -1 && bestDistance < 2.0) {
        // 如果在2秒范围内有标记，询问用户是否要移除
        const removed = manualAnomalyMarks.splice(bestIndex, 1)[0];
        console.log(`⚠️ 扩大范围移除异常标记 (距离${bestDistance.toFixed(3)}s):`, removed);
        console.log(`📉 新的标记总数: ${manualAnomalyMarks.length}`);
        
        updateAnomalyMarkingStatus();
        updateChartAnomalyMarks();
        return true;
      } else {
        console.log(`❌ 未找到可移除的标记: 最佳距离${bestDistance.toFixed(3)}s > 阈值2.0s`);
        console.log(`💡 提示: 请点击更接近现有异常标记的位置`);
        return false;
      }
    }

    // 更新状态显示
    function updateAnomalyMarkingStatus() {
      const status = document.getElementById('anomalyMarkingStatus');
      const count = manualAnomalyMarks.length;
      
      status.textContent = `🎯 Ctrl+点击VA图表标记异常点 (${count}个标记)`;
      status.style.color = count > 0 ? '#4caf50' : '#888';
      
      console.log(`📊 异常标记状态更新: ${count}个标记`);
      
      // 检查是否应该启用XDF导出按钮
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
    }

    // 更新XDF导出按钮状态
    function updateXDFExportButtonState() {
      const hasGSR = physiologicalData.gsr && physiologicalData.gsr.length > 0;
      const hasPPG = physiologicalData.ppg && physiologicalData.ppg.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      const hasEmotionData = dataLog && dataLog.some(record => record.face && isFinite(record.valence));
      
      const shouldEnable = hasGSR || hasPPG || hasAnomalies || hasEmotionData;
      
      const btnElement = document.getElementById('convertToXdfBtn');
      if (btnElement) {
        btnElement.disabled = !shouldEnable;
        
        console.log(`🔄 XDF导出按钮状态更新:`, {
          启用: shouldEnable,
          GSR数据: hasGSR,
          PPG数据: hasPPG,
          异常标记: hasAnomalies,
          情绪数据: hasEmotionData
        });
      }
    }

    // 更新情绪数据XDF导出按钮状态
    function updateEmotionXDFExportButtonState() {
      const hasEmotionData = dataLog && dataLog.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      
      const shouldEnable = hasEmotionData || hasAnomalies;
      
      const btnElement = document.getElementById('downloadBtn');
      if (btnElement) {
        btnElement.disabled = !shouldEnable;
        
        console.log(`🔄 情绪XDF导出按钮状态更新:`, {
          启用: shouldEnable,
          情绪数据: hasEmotionData,
          异常标记: hasAnomalies
        });
      }
    }

    // 更新图表中的异常标记显示
    function updateChartAnomalyMarks() {
      console.log(`🔄 更新图表异常标记显示, 标记数量: ${manualAnomalyMarks.length}`);
      console.log(`📋 当前异常标记列表:`, manualAnomalyMarks);
      
      if (typeof chart !== 'undefined') {
        console.log(`✅ chart对象存在, 类型: ${typeof chart}`);
        
        if (chart.updateAnomalyMarks) {
          console.log(`✅ chart.updateAnomalyMarks方法存在，调用更新`);
          chart.updateAnomalyMarks(manualAnomalyMarks);
        } else {
          console.log(`❌ chart.updateAnomalyMarks方法不存在`);
          console.log(`🔍 chart对象可用方法:`, Object.getOwnPropertyNames(chart));
        }
      } else {
        console.log(`❌ chart对象未定义`);
      }
    }

    // 隐藏抓帧画布（分析阶段用）
    const grabCanvas = document.createElement('canvas');
    const grabCtx = grabCanvas.getContext('2d', { willReadFrequently: true });

    const chart = new VAChart(chartCanvas);
    
    // 暴露chart实例为全局变量
    window.chart = chart;

    // 情绪检测状态
    let emotionDetectionEnabled = true; // 是否启用情绪检测
    let emotionChart = null; // 情绪图表实例
    const emotionNames = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise'];
    const emotionColors = ['#ff6b6b', '#8b5cf6', '#06b6d4', '#10b981', '#6b7280', '#3b82f6', '#f59e0b'];

    // API 管理
    let currentAPI = 'morphcast'; // 当前使用的API: 'morphcast' 或 'deepface'
    let deepfaceApiUrl = 'http://localhost:8080'; // DeepFace API 地址 (独立端口)
    let apiConnected = false; // API 连接状态

    // 生理信号数据存储
    let physiologicalData = {
      gsr: [],
      ppg: [],
      startTime: null
    };

    // 异常检测相关
    let anomalyDetectionResults = null;
    let showingAnomalies = false;

    // 时间对齐处理器类
    class TimeAlignmentProcessor {
      constructor() {
        this.alignmentResults = null;
      }

      // 互相关对齐方法
      async alignData(valenceData, gsrData, options = {}) {
        const config = {
          maxLagSeconds: options.maxLagSeconds || 5.0,
          ...options
        };

        console.log(`🔄 开始互相关时间对齐, 配置:`, config);
        console.log(`📊 输入数据: Valence ${valenceData.length}点, GSR ${gsrData.length}点`);

        return await this.crossCorrelationAlignment(valenceData, gsrData, config);
      }

      // Step 2: 互相关对齐
      async crossCorrelationAlignment(valenceData, gsrData, config) {
        console.log('🔍 执行互相关对齐...');

        // 1. 数据预处理和重采样到统一时间轴
        const { alignedValence, alignedGSR, timeAxis } = this.preprocessForCorrelation(valenceData, gsrData);
        
        if (alignedValence.length === 0 || alignedGSR.length === 0) {
          throw new Error('数据预处理失败：没有有效的重叠时间段');
        }

        console.log(`📈 预处理完成: 统一时间轴 ${timeAxis.length}点, 时间范围 ${timeAxis[0].toFixed(2)}s - ${timeAxis[timeAxis.length-1].toFixed(2)}s`);

        // 2. 计算互相关
        const maxLagSamples = Math.floor(config.maxLagSeconds / (timeAxis[1] - timeAxis[0]));
        const correlation = this.calculateCrossCorrelation(alignedValence, alignedGSR, maxLagSamples);
        
        // 3. 找到最佳滞后
        const bestLag = this.findBestLag(correlation, maxLagSamples);
        const lagSeconds = bestLag.lagSamples * (timeAxis[1] - timeAxis[0]);
        const confidence = bestLag.correlation;

        console.log(`🎯 互相关结果: 最佳滞后 ${lagSeconds.toFixed(3)}s (${bestLag.lagSamples}样本), 相关性 ${confidence.toFixed(3)}`);

        // 4. 应用时间偏移
        const alignedData = this.applyTimeOffset(valenceData, gsrData, lagSeconds);

        this.alignmentResults = {
          method: 'cross_correlation',
          lagSeconds: lagSeconds,
          confidence: confidence,
          correlation: correlation,
          alignedValence: alignedData.alignedValence,
          alignedGSR: alignedData.alignedGSR,
          diagnostics: {
            originalValenceLength: valenceData.length,
            originalGSRLength: gsrData.length,
            processedLength: timeAxis.length,
            maxLagSeconds: config.maxLagSeconds,
            samplingRate: 1 / (timeAxis[1] - timeAxis[0])
          }
        };

        return this.alignmentResults;
      }



      // 数据预处理：重采样到统一时间轴
      preprocessForCorrelation(valenceData, gsrData) {
        // 找到数据的重叠时间范围
        const valenceTimeRange = [valenceData[0].time, valenceData[valenceData.length - 1].time];
        const gsrTimeRange = [gsrData[0].time, gsrData[gsrData.length - 1].time];
        
        const startTime = Math.max(valenceTimeRange[0], gsrTimeRange[0]);
        const endTime = Math.min(valenceTimeRange[1], gsrTimeRange[1]);
        
        if (startTime >= endTime) {
          throw new Error('数据没有时间重叠');
        }

        // 创建统一的时间轴 (0.2s间隔 = 5Hz)
        const samplingInterval = 0.2;
        const timeAxis = [];
        for (let t = startTime; t <= endTime; t += samplingInterval) {
          timeAxis.push(t);
        }

        // 插值到统一时间轴
        const alignedValence = this.interpolateToTimeAxis(valenceData, timeAxis, 'valence');
        const alignedGSR = this.interpolateToTimeAxis(gsrData, timeAxis, 'gsr');

        return { alignedValence, alignedGSR, timeAxis };
      }

      // 线性插值到指定时间轴
      interpolateToTimeAxis(sourceData, targetTimeAxis, valueField) {
        const result = [];
        
        for (const targetTime of targetTimeAxis) {
          // 找到插值点
          let beforeIndex = -1;
          let afterIndex = -1;
          
          for (let i = 0; i < sourceData.length - 1; i++) {
            if (sourceData[i].time <= targetTime && sourceData[i + 1].time >= targetTime) {
              beforeIndex = i;
              afterIndex = i + 1;
              break;
            }
          }
          
          let interpolatedValue;
          
          if (beforeIndex !== -1 && afterIndex !== -1) {
            // 线性插值
            const before = sourceData[beforeIndex];
            const after = sourceData[afterIndex];
            const ratio = (targetTime - before.time) / (after.time - before.time);
            interpolatedValue = before[valueField] + ratio * (after[valueField] - before[valueField]);
          } else {
            // 使用最近邻
            let closestIndex = 0;
            let minDistance = Math.abs(sourceData[0].time - targetTime);
            
            for (let i = 1; i < sourceData.length; i++) {
              const distance = Math.abs(sourceData[i].time - targetTime);
              if (distance < minDistance) {
                minDistance = distance;
                closestIndex = i;
              }
            }
            
            interpolatedValue = sourceData[closestIndex][valueField];
          }
          
          result.push(interpolatedValue);
        }
        
        return result;
      }

      // 计算互相关
      calculateCrossCorrelation(signal1, signal2, maxLag) {
        const correlation = [];
        const length = Math.min(signal1.length, signal2.length);
        
        // 计算从 -maxLag 到 +maxLag 的相关性
        for (let lag = -maxLag; lag <= maxLag; lag++) {
          let sum = 0;
          let count = 0;
          
          const mean1 = signal1.reduce((a, b) => a + b, 0) / signal1.length;
          const mean2 = signal2.reduce((a, b) => a + b, 0) / signal2.length;
          
          let sum1Sq = 0, sum2Sq = 0, sumProduct = 0;
          
          for (let i = 0; i < length; i++) {
            const j = i + lag;
            if (j >= 0 && j < length) {
              const val1 = signal1[i] - mean1;
              const val2 = signal2[j] - mean2;
              
              sum1Sq += val1 * val1;
              sum2Sq += val2 * val2;
              sumProduct += val1 * val2;
              count++;
            }
          }
          
          const correlation_value = count > 0 ? sumProduct / Math.sqrt(sum1Sq * sum2Sq) : 0;
          correlation.push({ lag: lag, correlation: correlation_value });
        }
        
        return correlation;
      }

      // 找到最佳滞后
      findBestLag(correlation) {
        let bestResult = { lagSamples: 0, correlation: 0 };
        
        for (const result of correlation) {
          if (Math.abs(result.correlation) > Math.abs(bestResult.correlation)) {
            bestResult = { lagSamples: result.lag, correlation: result.correlation };
          }
        }
        
        return bestResult;
      }

      // 应用时间偏移
      applyTimeOffset(valenceData, gsrData, lagSeconds) {
        const alignedValence = valenceData.map(d => ({ ...d }));
        const alignedGSR = gsrData.map(d => ({ 
          ...d, 
          time: d.time - lagSeconds // GSR时间向前/向后偏移
        }));

        return { alignedValence, alignedGSR };
      }




      // 生成对齐报告
      generateAlignmentReport() {
        if (!this.alignmentResults) {
          return '没有对齐结果';
        }
        
        const result = this.alignmentResults;
        let report = `📊 时间对齐报告\n`;
        report += `方法: ${result.method}\n`;
        report += `时间偏移: ${result.lagSeconds.toFixed(3)}秒\n`;
        report += `相关性置信度: ${result.confidence.toFixed(3)}\n`;
        
        if (result.driftModel) {
          report += `\n🔧 漂移修正:\n`;
          report += `时钟偏差: ${((result.driftModel.scale - 1) * 100).toFixed(3)}%\n`;
          report += `拟合质量 R²: ${result.driftModel.r2.toFixed(3)}\n`;
        }
        
        report += `\n📈 诊断信息:\n`;
        report += `原始数据: VA ${result.diagnostics.originalValenceLength}点, GSR ${result.diagnostics.originalGSRLength}点\n`;
        report += `处理采样率: ${result.diagnostics.samplingRate.toFixed(1)}Hz\n`;
        
        return report;
      }
    }

    // Isolation Forest异常检测器类
    class IsolationForestDetector {
      constructor() {
        this.apiUrl = deepfaceApiUrl; // 使用DeepFace API地址
        this.results = null;
      }

      // 准备数据
      prepareData(dataSource) {
        let data = [];
        let timestamps = [];
        let sourceInfo = '';
        
        switch(dataSource) {
          case 'gsr':
            if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
              throw new Error('请先导入GSR数据');
            }
            
            for (const item of physiologicalData.gsr) {
              if (isFinite(item.gsr)) {
                data.push([item.gsr]); // 单维特征
                timestamps.push(item.time);
              }
            }
            // 检测GSR数据是否已标准化
            const gsrValues = data.map(d => d[0]);
            const gsrMean = gsrValues.reduce((a, b) => a + b, 0) / gsrValues.length;
            const isStandardized = Math.abs(gsrMean) < 0.1 && gsrValues.some(v => Math.abs(v) > 2);
            sourceInfo = `GSR数据${isStandardized ? '(已标准化)' : '(原始)'}：${data.length}个数据点`;
            break;
            
          case 'valence':
            if (!dataLog || dataLog.length === 0) {
              throw new Error('请先进行情绪分析');
            }
            
            for (const record of dataLog) {
              if (record.face && isFinite(record.valence)) {
                data.push([record.valence]); // 单维特征
                timestamps.push(record.time);
              }
            }
            // 检测Valence数据是否已标准化
            const valenceValues = data.map(d => d[0]);
            const valenceMean = valenceValues.reduce((a, b) => a + b, 0) / valenceValues.length;
            const isValenceStandardized = Math.abs(valenceMean) < 0.1 && valenceValues.some(v => Math.abs(v) > 2);
            sourceInfo = `Valence数据${isValenceStandardized ? '(已标准化)' : '(原始)'}：${data.length}个数据点`;
            break;
            
          case 'combined':
            console.log('🔄 准备联合异常检测数据 (GSR + Valence)');
            
            // 使用数据对齐方法
            const combinedData = this.alignAndCombineData();
            
            for (const item of combinedData) {
              if (isFinite(item.gsr) && isFinite(item.valence)) {
                data.push([item.gsr, item.valence]); // 二维特征向量
                timestamps.push(item.time);
              }
            }
            
            // 检测联合数据是否已标准化
            if (data.length > 0) {
              const gsrVals = data.map(d => d[0]);
              const valenceVals = data.map(d => d[1]);
              const gsrMean = gsrVals.reduce((a, b) => a + b, 0) / gsrVals.length;
              const valenceMean = valenceVals.reduce((a, b) => a + b, 0) / valenceVals.length;
              const gsrStd = Math.abs(gsrMean) < 0.1 && gsrVals.some(v => Math.abs(v) > 2);
              const valenceStd = Math.abs(valenceMean) < 0.1 && valenceVals.some(v => Math.abs(v) > 2);
              const statusText = (gsrStd && valenceStd) ? '(已标准化)' : 
                                 (gsrStd || valenceStd) ? '(部分标准化)' : '(原始)';
              sourceInfo = `联合数据${statusText}：${data.length}个数据点 (GSR + Valence)`;
            } else {
              sourceInfo = `联合数据：${data.length}个数据点 (GSR + Valence)`;
            }
            console.log(`✅ 联合数据准备完成: ${data.length}个二维特征向量`);
            break;
            
          default:
            throw new Error('未知的数据源');
        }
        
        if (data.length === 0) {
          throw new Error(`${dataSource} 数据为空`);
        }
        
        console.log(`准备异常检测数据：${sourceInfo}`);
        return { data, timestamps, sourceInfo };
      }

      // 运行Isolation Forest检测
      async runDetection(dataSource, contamination = 0.1) {
        try {
          const { data, timestamps, sourceInfo } = this.prepareData(dataSource);
          
          // 调用PyOD API
          const response = await fetch(`${this.apiUrl}/anomaly/isolation_forest`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              data: data,
              contamination: contamination,
              random_state: 42
            }),
            timeout: 30000
          });

          if (!response.ok) {
            throw new Error(`API调用失败: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.status === 'success') {
            // 处理返回结果
            const anomalyIndices = [];
            const anomalyScores = result.anomaly_scores || [];
            const predictions = result.predictions || [];
            
            predictions.forEach((pred, idx) => {
              if (pred === 1) { // 异常点
                anomalyIndices.push(idx);
              }
            });
            
            this.results = {
              dataSource: dataSource,
              contamination: contamination,
              totalPoints: data.length,
              anomalyIndices: anomalyIndices,
              anomalyScores: anomalyScores,
              timestamps: timestamps,
              data: data,
              anomalies: anomalyIndices.map(idx => ({
                index: idx,
                time: timestamps[idx],
                value: dataSource === 'combined' ? data[idx] : data[idx][0], // 联合数据保留完整数组
                score: anomalyScores[idx]
              })),
              sourceInfo: sourceInfo
            };
            
            console.log(`Isolation Forest异常检测完成:`, this.results);
            return this.results;
            
          } else {
            throw new Error(result.error || 'API返回错误状态');
          }

        } catch (error) {
          console.error(`Isolation Forest异常检测失败: ${error.message}`);
          throw error;
        }
      }

      // 显示异常点
      showAnomalies() {
        if (!this.results || !chart) return;
        
        // 准备异常点数据，处理联合数据的Y值
        const anomalyPoints = this.results.anomalies.map(anomaly => ({
          x: anomaly.time,
          y: this.getAnomalyYValue(anomaly),
          score: anomaly.score
        }));
        
        // 调试信息
        console.log(`准备显示异常点:`, {
          totalAnomalies: anomalyPoints.length,
          dataSource: this.results.dataSource,
          samplePoints: anomalyPoints.slice(0, 5),
          yRange: {
            min: Math.min(...anomalyPoints.map(p => p.y)),
            max: Math.max(...anomalyPoints.map(p => p.y))
          },
          xRange: {
            min: Math.min(...anomalyPoints.map(p => p.x)),
            max: Math.max(...anomalyPoints.map(p => p.x))
          }
        });
        
        // 根据数据源选择显示样式
        let options = {};
        
        switch(this.results.dataSource) {
          case 'gsr':
            options = {
              color: '#ff6b6b',
              size: 4, // GSR用更小的点，因为数据密集
              label: 'ML异常点(GSR)',
              dataSource: 'GSR'
            };
            break;
            
          case 'valence':
            options = {
              color: '#fbbf24',
              size: 6,
              label: 'ML异常点(Valence)',
              dataSource: 'VALENCE'
            };
            break;
            
          case 'combined':
            options = {
              color: '#8b5cf6', // 紫色表示联合检测
              size: 8,
              label: 'ML异常点(联合)',
              dataSource: 'COMBINED'
            };
            break;
            
          default:
            options = {
              color: '#ff6b6b',
              size: 6,
              label: 'ML异常点',
              dataSource: this.results.dataSource.toUpperCase()
            };
        }
        
        // 使用VAChart的方法显示异常点
        chart.showMLAnomalies(anomalyPoints, options);
        
        showingAnomalies = true;
        console.log(`显示 ${anomalyPoints.length} 个${options.dataSource}异常点`);
      }

      // 获取异常点的Y值显示位置
      getAnomalyYValue(anomaly) {
        const dataSource = this.results.dataSource;
        
        switch(dataSource) {
          case 'gsr':
          case 'valence':
            return anomaly.value;
            
          case 'combined':
            // 对于联合数据，优先显示在Valence位置
            // anomaly.value是二维数组 [gsr, valence]，我们取valence值
            if (Array.isArray(anomaly.value) && anomaly.value.length >= 2) {
              return anomaly.value[1]; // valence值
            }
            return 0;
            
          default:
            return anomaly.value;
        }
      }

      // 隐藏异常点
      hideAnomalies() {
        if (chart) {
          chart.hideMLAnomalies();
        }
        showingAnomalies = false;
        console.log('已隐藏异常点');
      }

      // 切换异常点显示
      toggleAnomalies() {
        if (showingAnomalies) {
          this.hideAnomalies();
        } else {
          this.showAnomalies();
        }
      }

      // 数据对齐和融合方法
      alignAndCombineData() {
        const gsrData = physiologicalData.gsr;
        const valenceData = dataLog.filter(record => record.face && isFinite(record.valence));
        
        if (!gsrData || gsrData.length === 0) {
          throw new Error('GSR数据为空，请先导入GSR数据');
        }
        if (!valenceData || valenceData.length === 0) {
          throw new Error('Valence数据为空，请先进行情绪分析');
        }
        
        console.log(`🔄 数据对齐开始: GSR ${gsrData.length}点, Valence ${valenceData.length}点`);
        
        const combinedData = [];
        const tolerance = 0.5; // 500ms时间容差
        
        // 策略：以GSR数据为基准，匹配最近的Valence数据
        for (const gsrPoint of gsrData) {
          let closestValence = null;
          let minTimeDiff = Infinity;
          
          for (const valencePoint of valenceData) {
            const timeDiff = Math.abs(valencePoint.time - gsrPoint.time);
            if (timeDiff < minTimeDiff && timeDiff <= tolerance) {
              minTimeDiff = timeDiff;
              closestValence = valencePoint;
            }
          }
          
          if (closestValence) {
            combinedData.push({
              time: gsrPoint.time,
              gsr: gsrPoint.gsr,
              valence: closestValence.valence,
              timeDiff: minTimeDiff
            });
          }
        }
        
        console.log(`✅ 数据对齐完成: ${combinedData.length}个有效数据点`);
        console.log(`📊 平均时间差: ${(combinedData.reduce((sum, p) => sum + p.timeDiff, 0) / combinedData.length).toFixed(3)}s`);
        
        return combinedData;
      }

      // 检查API状态
      async checkApiStatus() {
        try {
          const response = await fetch(`${this.apiUrl}/anomaly/info`, {
            method: 'GET',
            timeout: 5000
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('PyOD异常检测API状态:', result);
            return { available: true, info: result };
          } else {
            throw new Error(`API状态检查失败: ${response.status}`);
          }
        } catch (error) {
          console.warn(`PyOD异常检测API不可用: ${error.message}`);
          return { available: false, error: error.message };
        }
      }
    }

    // 异常区间检测器类
    class AnomalyIntervalDetector {
        constructor() {
            this.maxGap = 2.0;          // 最大聚类间隔（秒）
            this.minDuration = 1.0;     // 最小区间长度（秒）
        }

        // 检测异常区间
        detectIntervals(anomalies, options = {}) {
            const config = { ...this, ...options };
            
            if (!anomalies || anomalies.length === 0) {
                console.log('没有异常点数据，跳过区间检测');
                return [];
            }

            console.log(`🔍 开始异常区间检测 - 输入${anomalies.length}个异常点`);
            console.log(`参数: maxGap=${config.maxGap}s, minDuration=${config.minDuration}s`);

            // 1. 按时间排序
            const sortedAnomalies = [...anomalies].sort((a, b) => a.time - b.time);
            
            // 2. 聚类相近的异常点
            const clusters = this.clusterByTime(sortedAnomalies, config.maxGap);
            console.log(`聚类结果: ${clusters.length}个聚类`);
            
            // 3. 转换为时间区间
            const intervals = clusters.map(cluster => this.clusterToInterval(cluster, config));
            console.log(`初始区间: ${intervals.length}个，平均长度${intervals.length > 0 ? (intervals.reduce((sum, i) => sum + i.duration, 0) / intervals.length).toFixed(2) : 0}s`);
            
            // 4. 过滤短区间
            const validIntervals = intervals.filter(interval => {
                const isValid = interval.duration >= config.minDuration;
                if (!isValid) {
                    console.log(`过滤短区间: ${interval.startTime.toFixed(1)}s-${interval.endTime.toFixed(1)}s (${interval.duration.toFixed(1)}s < ${config.minDuration}s)`);
                }
                return isValid;
            });
            
            console.log(`✅ 区间检测完成: ${validIntervals.length}个有效区间`);
            console.log(`📈 处理效果: 原始${clusters.length}聚类 → 形成${intervals.length}区间 → 最终${validIntervals.length}有效区间`);
            this.logIntervalSummary(validIntervals);
            
            return validIntervals;
        }

        // 按时间聚类
        clusterByTime(anomalies, maxGap) {
            const clusters = [];
            let currentCluster = [anomalies[0]];
            
            for (let i = 1; i < anomalies.length; i++) {
                const prevTime = anomalies[i-1].time;
                const currTime = anomalies[i].time;
                const timeGap = currTime - prevTime;
                
                if (timeGap <= maxGap) {
                    currentCluster.push(anomalies[i]);
                } else {
                    clusters.push([...currentCluster]);
                    currentCluster = [anomalies[i]];
                }
            }
            
            clusters.push(currentCluster);
            return clusters;
        }

        // 将聚类转换为区间
        clusterToInterval(cluster, config) {
            const times = cluster.map(point => point.time);
            const scores = cluster.map(point => point.score || 0);
            const values = cluster.map(point => point.value);
            
            const startTime = Math.min(...times);
            const endTime = Math.max(...times);
            const duration = endTime - startTime;
            
            const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
            const maxScore = Math.max(...scores);
            const avgValue = values.reduce((sum, val) => sum + val, 0) / values.length;
            
            // 计算置信度（基于异常点密度和分数）
            const density = cluster.length / Math.max(duration, 0.1);
            const confidence = Math.min(1.0, (density * 0.3 + (Math.abs(avgScore) / 3.0) * 0.7));
            
            return {
                startTime: startTime,
                endTime: endTime,
                duration: duration,
                anomalyCount: cluster.length,
                avgScore: avgScore,
                maxScore: maxScore,
                avgValue: avgValue,
                confidence: confidence,
                type: this.classifyInterval(cluster, duration),
                originalPoints: cluster
            };
        }

        // 分类区间类型
        classifyInterval(cluster, duration) {
            if (duration < 1.0) return 'spike';        // 尖峰异常
            if (duration < 3.0) return 'brief';        // 短暂异常
            if (duration < 10.0) return 'short';       // 短期异常
            if (duration < 30.0) return 'medium';      // 中期异常
            return 'sustained';                        // 持续异常
        }

        // 合并相邻区间
        mergeAdjacentIntervals(intervals, mergeThreshold) {
            if (intervals.length <= 1) return intervals;
            
            intervals.sort((a, b) => a.startTime - b.startTime);
            
            const merged = [];
            let current = { ...intervals[0] };
            
            for (let i = 1; i < intervals.length; i++) {
                const next = intervals[i];
                const gap = next.startTime - current.endTime;
                
                if (gap <= mergeThreshold) {
                    // 合并区间
                    current = {
                        startTime: current.startTime,
                        endTime: next.endTime,
                        duration: next.endTime - current.startTime,
                        anomalyCount: current.anomalyCount + next.anomalyCount,
                        avgScore: (current.avgScore * current.anomalyCount + next.avgScore * next.anomalyCount) / 
                                 (current.anomalyCount + next.anomalyCount),
                        maxScore: Math.max(current.maxScore, next.maxScore),
                        avgValue: (current.avgValue * current.anomalyCount + next.avgValue * next.anomalyCount) / 
                                 (current.anomalyCount + next.anomalyCount),
                        confidence: Math.max(current.confidence, next.confidence),
                        type: 'merged',
                        originalPoints: [...current.originalPoints, ...next.originalPoints]
                    };
                    console.log(`合并区间: ${current.startTime.toFixed(1)}s-${current.endTime.toFixed(1)}s (间隔${gap.toFixed(1)}s)`);
                } else {
                    merged.push(current);
                    current = { ...next };
                }
            }
            
            merged.push(current);
            return merged;
        }

        // 输出区间汇总信息
        logIntervalSummary(intervals) {
            if (intervals.length === 0) {
                console.log('📊 区间汇总: 没有检测到有效的异常区间');
                return;
            }

            console.log('� 异常区间汇总:');
            intervals.forEach((interval, index) => {
                console.log(`  � 区间${index + 1}: ` +
                    `${interval.startTime.toFixed(1)}s-${interval.endTime.toFixed(1)}s ` +
                    `(${interval.duration.toFixed(1)}s, ${interval.anomalyCount}点, ` +
                    `置信度${(interval.confidence * 100).toFixed(0)}%)`);
            });

            // 统计信息
            const totalDuration = intervals.reduce((sum, interval) => sum + interval.duration, 0);
            const totalAnomalies = intervals.reduce((sum, interval) => sum + interval.anomalyCount, 0);
            const avgConfidence = intervals.reduce((sum, interval) => sum + interval.confidence, 0) / intervals.length;

            console.log(`📈 总体统计: ${intervals.length}个区间, 总时长${totalDuration.toFixed(1)}s, ` +
                `${totalAnomalies}个异常点, 平均置信度${(avgConfidence * 100).toFixed(0)}%`);
        }
    }

    // 创建异常检测器实例
    const isolationForestDetector = new IsolationForestDetector();
    const anomalyIntervalDetector = new AnomalyIntervalDetector();

    // 初始化情绪图表
    function initEmotionChart() {
      const emotionChartCanvas = document.getElementById('emotionChart');
      const ctx = emotionChartCanvas.getContext('2d');
      
      const datasets = emotionNames.map((name, index) => ({
        label: name,
        backgroundColor: emotionColors[index],
        borderColor: emotionColors[index],
        data: [],
        fill: false,
        lineTension: 0,
        pointRadius: 0,
        borderWidth: 2
      }));

      emotionChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: false,
          animation: { duration: 0 },
          legend: { 
            position: 'top', 
            labels: { fontColor: '#fff' },
            onClick: (e, legendItem) => {
              const index = legendItem.datasetIndex;
              const meta = emotionChart.getDatasetMeta(index);
              meta.hidden = meta.hidden === null ? !datasets[index].hidden : !meta.hidden;
              emotionChart.update();
            }
          },
          scales: {
            xAxes: [{
              type: 'linear',
              display: true,
              scaleLabel: { display: true, labelString: 'time (sec)', fontColor: '#fff' },
              ticks: { min: 0, suggestedMax: 300, stepSize: 2, fontColor: '#fff' },
              gridLines: {
                color: 'rgba(255,255,255,0.08)',
                zeroLineColor: 'rgba(255,255,255,0.35)',
                zeroLineWidth: 2
              }
            }],
            yAxes: [{
              display: true,
              scaleLabel: { display: true, labelString: 'Probability', fontColor: '#fff' },
              ticks: { min: 0, max: 1, stepSize: 0.2, fontColor: '#fff' },
              gridLines: {
                color: 'rgba(255,255,255,0.08)',
                zeroLineColor: 'rgba(255,255,255,0.35)',
                zeroLineWidth: 2
              }
            }]
          },
          tooltips: { mode: 'index', intersect: false }
        }
      });
      
      Chart.defaults.global.defaultFontColor = "#fff";
    }
    
    initEmotionChart();

    // 暴露全局变量供va-chart.js访问
    window.emotionChart = emotionChart;
    window.emotionDetectionEnabled = emotionDetectionEnabled;

    // CSV解析函数 - 直接转换为XDF格式
    function parseShimmerCSVToXDF(csvText) {
      const lines = csvText.trim().split('\n');
      
      // 处理可能的分隔符声明行
      let headerLineIndex = 0;
      let separator = '\t'; // 默认制表符分隔
      
      // 检查第一行是否是分隔符声明
      if (lines[0].includes('sep=')) {
        console.log('检测到分隔符声明:', lines[0]);
        // 提取分隔符
        const sepMatch = lines[0].match(/sep=(.)/);
        if (sepMatch) {
          separator = sepMatch[1];
          console.log('使用分隔符:', separator);
        }
        headerLineIndex = 1; // 跳过分隔符声明行
      }
      
      if (headerLineIndex >= lines.length) {
        throw new Error('CSV文件格式错误：没有找到标题行');
      }
      
      const headers = lines[headerLineIndex].split(separator)
        .map(h => h.trim().replace(/\r/g, ''))
        .filter(h => h.length > 0); // 过滤掉空的表头
      console.log('清理后的CSV Headers:', headers); // 调试信息
      
      // 查找相关列的索引
      const timeIndex = headers.findIndex(h => 
        h.includes('Timestamp') || 
        h.includes('timestamp') || 
        h.includes('TIME') || 
        h.includes('Time')
      );
      
      const gsrIndex = headers.findIndex(h => 
        h.includes('GSR_Skin_Conductance') || 
        (h.includes('GSR') && h.includes('Conductance'))
      );
      
      const ppgIndex = headers.findIndex(h => 
        h.includes('PPG') && h.includes('CAL')
      );
      
      console.log('Column indices - Time:', timeIndex, 'GSR:', gsrIndex, 'PPG:', ppgIndex);
      console.log('Time column name:', timeIndex >= 0 ? headers[timeIndex] : 'NOT FOUND');
      console.log('GSR column name:', gsrIndex >= 0 ? headers[gsrIndex] : 'NOT FOUND');
      console.log('PPG column name:', ppgIndex >= 0 ? headers[ppgIndex] : 'NOT FOUND');
      
      const gsrTimeSeries = [];
      const gsrTimeStamps = [];
      const ppgTimeSeries = [];
      const ppgTimeStamps = [];
      let startTime = null;
      
      // 从标题行后的下一行开始（跳过单位行）
      const dataStartIndex = headerLineIndex + 2;
      let processedLines = 0;
      let validTimeCount = 0;
      let validGSRCount = 0;
      let validPPGCount = 0;
      
      console.log('开始数据解析:');
      console.log('- headerLineIndex:', headerLineIndex);
      console.log('- dataStartIndex:', dataStartIndex);
      console.log('- 总行数:', lines.length);
      console.log('- 预期处理行数:', lines.length - dataStartIndex);
      console.log('- headers.length:', headers.length);
      
      // 数据采样设置 - 从UI获取配置
      const maxDataPointsInput = document.getElementById('maxDataPoints');
      const maxDataPoints = maxDataPointsInput ? parseInt(maxDataPointsInput.value) || 20000 : 20000;
      const totalDataLines = lines.length - dataStartIndex;
      let samplingRate = 1; // 默认不采样
      
      if (totalDataLines > maxDataPoints) {
        samplingRate = Math.ceil(totalDataLines / maxDataPoints);
        console.log(`数据量较大(${totalDataLines}行)，将按${samplingRate}:1比率采样，预计处理约${Math.ceil(totalDataLines / samplingRate)}行`);
      } else {
        console.log(`数据量适中(${totalDataLines}行)，将处理全部数据`);
      }
      
      let samplingCounter = 0;
      
      for (let i = dataStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
          console.log(`跳过空行 ${i+1}`);
          continue; // 跳过空行
        }
        
        // 数据采样：只处理符合采样率的行
        if (samplingCounter % samplingRate !== 0) {
          samplingCounter++;
          continue;
        }
        samplingCounter++;
        
        const values = line.split(separator)
          .map(v => v.trim().replace(/\r/g, ''))
          .filter(v => v.length > 0); // 过滤掉空的值
        
        // 详细调试前几行
        if (processedLines < 3) {
          console.log(`调试第${i+1}行(采样后第${processedLines+1}行):`);
          console.log('- 原始行:', line);
          console.log('- 原始分割数量:', line.split(separator).length);
          console.log('- 过滤后values.length:', values.length);
          console.log('- headers.length:', headers.length);
          console.log('- values:', values);
        }
        
        if (values.length < headers.length) {
          if (processedLines < 3) {
            console.log(`第${i+1}行列数不匹配，跳过`);
          }
          continue;
        }
        
        processedLines++;
        
        // 调试前几行数据
        if (processedLines <= 3) {
          console.log(`处理第${processedLines}行数据:`, values);
          console.log(`时间戳值: "${values[timeIndex >= 0 ? timeIndex : 0]}"`);
          if (gsrIndex >= 0) console.log(`GSR值: "${values[gsrIndex]}"`);
          if (ppgIndex >= 0) console.log(`PPG值: "${values[ppgIndex]}"`);
        }
        
        // 解析时间戳 - 支持完整日期时间格式
        const timeStr = values[timeIndex >= 0 ? timeIndex : 0];
        let totalSeconds;
        
        if (timeStr.includes('/') && timeStr.includes(':')) {
          // 完整日期时间格式: 2025/09/08 19:37:30.318
          try {
            const dateObj = new Date(timeStr);
            if (!isNaN(dateObj.getTime())) {
              totalSeconds = dateObj.getTime() / 1000; // 转换为Unix时间戳(秒)
            } else {
              throw new Error('Invalid date');
            }
          } catch (e) {
            if (processedLines <= 3) {
              console.log(`日期解析失败: "${timeStr}" -> ${e.message}`);
            }
            continue;
          }
        } else if (timeStr.includes(':')) {
          // 简单时间格式: 37:30.3 或 00:37:30.3
          const timeParts = timeStr.split(':');
          if (timeParts.length === 2) {
            // MM:SS.mmm 格式
            totalSeconds = parseInt(timeParts[0]) * 60 + parseFloat(timeParts[1]);
          } else if (timeParts.length === 3) {
            // HH:MM:SS.mmm 格式
            totalSeconds = parseInt(timeParts[0]) * 3600 + parseInt(timeParts[1]) * 60 + parseFloat(timeParts[2]);
          } else {
            totalSeconds = parseFloat(timeStr);
          }
        } else {
          // 纯数字格式
          totalSeconds = parseFloat(timeStr);
        }
        
        if (isNaN(totalSeconds)) {
          if (processedLines <= 3) {
            console.log(`时间解析失败: "${timeStr}" -> NaN`);
          }
          continue; // 跳过无效时间
        }
        
        validTimeCount++;
        
        if (startTime === null) {
          startTime = totalSeconds;
          console.log('开始时间(Unix时间戳):', startTime, '日期:', new Date(startTime * 1000).toISOString());
        }
        
        // 相对时间（从0开始）
        const relativeTime = totalSeconds - startTime;
        
        // 调试前几行的时间转换
        if (processedLines <= 3) {
          console.log(`第${processedLines}行时间转换:`, {
            原始时间: timeStr,
            绝对时间戳: totalSeconds,
            相对时间: relativeTime
          });
        }
        
        // 解析GSR数据
        if (gsrIndex !== -1 && values[gsrIndex]) {
          const gsrValue = parseFloat(values[gsrIndex]);
          if (!isNaN(gsrValue)) {
            gsrTimeSeries.push([gsrValue]);
            gsrTimeStamps.push(relativeTime);
            validGSRCount++;
          } else if (processedLines <= 3) {
            console.log(`GSR解析失败: "${values[gsrIndex]}" -> NaN`);
          }
        }
        
        // 解析PPG数据
        if (ppgIndex !== -1 && values[ppgIndex]) {
          const ppgValue = parseFloat(values[ppgIndex]);
          if (!isNaN(ppgValue)) {
            ppgTimeSeries.push([ppgValue]);
            ppgTimeStamps.push(relativeTime);
            validPPGCount++;
          } else if (processedLines <= 3) {
            console.log(`PPG解析失败: "${values[ppgIndex]}" -> NaN`);
          }
        }
      }
      
      // 创建符合LSL标准的XDF格式数据
      const xdfData = {
        "info": {
          "version": "1.0",
          "created": new Date().toISOString(),
          "software": "EmotionAnalysisApp_GSR_Extension",
          "session_id": `physio_session_${Date.now()}`
        },
        "streams": []
      };

      // 添加GSR流 - 符合LSL标准
      if (gsrTimeSeries.length > 0) {
        xdfData.streams.push({
          "info": {
            "name": "Shimmer_GSR",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": gsrTimeSeries.length > 1 ? Math.round(1 / (gsrTimeStamps[1] - gsrTimeStamps[0])) : 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "GSR_Conductance",
                "unit": "microsiemens",
                "type": "GSR",
                "description": "Galvanic Skin Response - Skin Conductance"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["GSR"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": gsrTimeSeries,
          "time_stamps": gsrTimeStamps
        });
      }

      // 添加PPG流 - 符合LSL标准
      if (ppgTimeSeries.length > 0) {
        xdfData.streams.push({
          "info": {
            "name": "Shimmer_PPG",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": ppgTimeSeries.length > 1 ? Math.round(1 / (ppgTimeStamps[1] - ppgTimeStamps[0])) : 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "PPG_A13",
                "unit": "millivolts",
                "type": "PPG",
                "description": "Photoplethysmography - Heart Rate Signal"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["PPG"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": ppgTimeSeries,
          "time_stamps": ppgTimeStamps
        });
      }
      
      console.log(`CSV转XDF成功: GSR ${gsrTimeSeries.length}点, PPG ${ppgTimeSeries.length}点`);
      console.log('详细统计:');
      console.log('- 总数据行数:', lines.length - dataStartIndex);
      console.log('- 采样率:', samplingRate + ':1');
      console.log('- 处理的行数:', processedLines);
      console.log('- 有效时间戳:', validTimeCount);
      console.log('- 有效GSR数据:', validGSRCount);
      console.log('- 有效PPG数据:', validPPGCount);
      if (samplingRate > 1) {
        console.log('- 数据压缩率:', `${((processedLines / (lines.length - dataStartIndex)) * 100).toFixed(1)}%`);
      }
      
      if (gsrTimeSeries.length === 0 && ppgTimeSeries.length === 0) {
        console.warn('警告：没有解析到任何数据，请检查：');
        console.warn('1. 数据是否从第', dataStartIndex + 1, '行开始');
        console.warn('2. 时间戳格式是否为 MM:SS.mmm');
        console.warn('3. GSR/PPG数据是否为有效数字');
        
        // 显示前几行原始数据用于调试
        console.warn('前3行原始数据:');
        for (let i = dataStartIndex; i < Math.min(dataStartIndex + 3, lines.length); i++) {
          console.warn(`第${i+1}行:`, lines[i]);
        }
      }
      
      return xdfData;
    }

    // XDF解析函数
    function parseXDFData(xdfData) {
      try {
        const data = typeof xdfData === 'string' ? JSON.parse(xdfData) : xdfData;
        
        const gsrData = [];
        const ppgData = [];
        
        if (data.streams) {
          for (const stream of data.streams) {
            if (stream.info.name === 'Shimmer_GSR' && stream.time_series) {
              // 使用time_stamps字段或计算时间
              const timeStamps = stream.time_stamps;
              const sampleRate = stream.info.nominal_srate || 50;
              
              stream.time_series.forEach((sample, index) => {
                const time = timeStamps ? timeStamps[index] : (index / sampleRate);
                const value = Array.isArray(sample) ? sample[0] : sample;
                if (Number.isFinite(value)) {
                  gsrData.push({ time, gsr: value });
                }
              });
            }
            
            if (stream.info.name === 'Shimmer_PPG' && stream.time_series) {
              const timeStamps = stream.time_stamps;
              const sampleRate = stream.info.nominal_srate || 50;
              
              stream.time_series.forEach((sample, index) => {
                const time = timeStamps ? timeStamps[index] : (index / sampleRate);
                const value = Array.isArray(sample) ? sample[0] : sample;
                if (Number.isFinite(value)) {
                  ppgData.push({ time, ppg: value });
                }
              });
            }
          }
        }
        
        console.log(`XDF解析结果: GSR ${gsrData.length}点, PPG ${ppgData.length}点`);
        return { gsr: gsrData, ppg: ppgData };
      } catch (error) {
        throw new Error('XDF数据解析失败: ' + error.message);
      }
    }

    // 将生理信号和异常标记数据转换为XDF格式
    function convertPhysiologicalToXDF(gsrData, ppgData) {
      const hasGSR = gsrData && gsrData.length > 0;
      const hasPPG = ppgData && ppgData.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      
      const xdfData = {
        "info": {
          "version": "1.0",
          "created": new Date().toISOString(),
          "software": "EmotionAnalysisApp_Manual_Annotation",
          "source": hasGSR || hasPPG ? "Shimmer_Sensor_With_Manual_Annotation" : "Manual_Annotation_Only",
          "description": hasAnomalies ? 
            `${hasGSR || hasPPG ? 'GSR and PPG data from Shimmer sensor with' : 'Only'} manual anomaly annotations` :
            "GSR and PPG data from Shimmer wearable sensor"
        },
        "streams": []
      };

      console.log(`📦 创建XDF数据包: GSR=${hasGSR}, PPG=${hasPPG}, 异常标记=${hasAnomalies}`);

      // GSR数据流
      if (hasGSR) {
        const gsrStream = {
          "info": {
            "name": "Shimmer_GSR",
            "type": "Physiological",
            "channel_count": 1,
            "nominal_srate": 50, // 假设50Hz采样率
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "GSR_Conductance",
                "unit": "microsiemens",
                "type": "GSR",
                "description": "Galvanic Skin Response - Skin Conductance"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["GSR"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor",
                "serial": "A923"
              }
            }
          },
          "time_series": gsrData.map(d => [d.gsr]),
          "time_stamps": gsrData.map(d => d.time)
        };
        xdfData.streams.push(gsrStream);
      }

      // PPG数据流
      if (hasPPG) {
        const ppgStream = {
          "info": {
            "name": "Shimmer_PPG",
            "type": "Physiological", 
            "channel_count": 1,
            "nominal_srate": 50,
            "channel_format": "float32",
            "source_id": "Shimmer_A923",
            "channels": [
              {
                "label": "PPG_A13",
                "unit": "millivolts",
                "type": "PPG",
                "description": "Photoplethysmography - Heart Rate Signal"
              }
            ],
            "manufacturer": "Shimmer",
            "caps": ["PPG"],
            "desc": {
              "device": {
                "name": "Shimmer GSR+ Unit",
                "type": "wearable_sensor", 
                "serial": "A923"
              }
            }
          },
          "time_series": ppgData.map(d => [d.ppg]),
          "time_stamps": ppgData.map(d => d.time)
        };
        xdfData.streams.push(ppgStream);
      }

      // 手动异常标记数据流
      if (manualAnomalyMarks && manualAnomalyMarks.length > 0) {
        const anomalyStream = {
          "info": {
            "name": "ManualAnomalyMarks",
            "type": "Annotations",
            "channel_count": 2,
            "nominal_srate": 0, // 事件流，非周期采样
            "channel_format": "float32",
            "source_id": "EmotionAnalysisApp_Manual",
            "channels": [
              {
                "label": "AnomalyFlag",
                "unit": "binary",
                "type": "Marker",
                "description": "Manual anomaly detection flag (1=anomaly, 0=normal)"
              },
              {
                "label": "ValenceValue",
                "unit": "normalized",
                "type": "Emotion",
                "description": "Valence value at anomaly point (-1 to 1)"
              }
            ],
            "manufacturer": "EmotionAnalysisApp",
            "caps": ["ManualAnnotation"],
            "desc": {
              "device": {
                "name": "Manual Annotation Tool",
                "type": "software_annotation",
                "version": "1.0"
              }
            }
          },
          "time_series": manualAnomalyMarks.map(mark => [1, mark.valence]), // 异常标记=1，valence值
          "time_stamps": manualAnomalyMarks.map(mark => mark.time)
        };
        xdfData.streams.push(anomalyStream);
      }

      return xdfData;
    }

    // 导出XDF文件
    function exportPhysiologicalXDF(xdfData, filename = 'physiological_data.xdf') {
      const blob = new Blob([JSON.stringify(xdfData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // XDF 格式处理器类
    class XDFFormatter {
      constructor() {
        this.startTime = Date.now();
      }

      // 导出为 XDF 格式
      exportToXDF(dataLog, emotionDetectionEnabled, emotionNames) {
        if (dataLog.length === 0) {
          throw new Error('No data to export');
        }

        // 创建符合LabRecorder标准的XDF格式
        const xdfData = {
          info: {
            version: [1, 0], // LabRecorder期望的版本格式
            created: new Date().toISOString(),
            software: 'EmotionAnalysisApp',
            hostname: window.location.hostname || 'localhost',
            session_id: `emotion_session_${this.startTime}`
          },
          streams: []
        };

        // VA数据流 - 包含所有数据点，包括无人脸的
        const vaStream = {
          info: {
            name: 'EmotionAnalysis_VA',
            type: 'Emotion',
            channel_count: 3,
            nominal_srate: 0.0, // LabRecorder期望浮点数
            channel_format: 'float32',
            source_id: `EmotionVA_${this.startTime}`,
            uid: this.generateUID(),
            created_at: (Date.now() / 1000.0), // Unix时间戳
            hostname: window.location.hostname || 'localhost',
            // LabRecorder兼容的通道描述格式
            desc: {
              acquisition: {
                manufacturer: 'EmotionAnalysisApp',
                model: 'VA_Analyzer_v1.0'
              },
              channels: {
                channel: [
                  {
                    label: 'Valence',
                    unit: 'normalized',
                    type: 'VA'
                  },
                  {
                    label: 'Arousal', 
                    unit: 'normalized',
                    type: 'VA'
                  },
                  {
                    label: 'FaceDetected',
                    unit: 'boolean',
                    type: 'Marker'
                  }
                ]
              }
            }
          },
          time_series: [],
          time_stamps: []
        };

        // 情绪数据流 - 只包含有人脸且有情绪数据的点
        let emotionStream = null;
        if (emotionDetectionEnabled && dataLog.some(d => d.emotions)) {
          emotionStream = {
            info: {
              name: 'EmotionAnalysis_Emotions',
              type: 'Emotion',
              channel_count: 7,
              nominal_srate: 0.0,
              channel_format: 'float32',
              source_id: `Emotions_${this.startTime}`,
              uid: this.generateUID(),
              created_at: (Date.now() / 1000.0),
              hostname: window.location.hostname || 'localhost',
              desc: {
                acquisition: {
                  manufacturer: 'EmotionAnalysisApp',
                  model: 'Emotion_Analyzer_v1.0'
                },
                channels: {
                  channel: emotionNames.map(name => ({
                    label: name,
                    unit: 'probability',
                    type: 'Emotion'
                  }))
                }
              }
            },
            time_series: [],
            time_stamps: []
          };
        }

        // 填充所有数据点，确保时间戳是相对于第一个数据点的
        const baseTime = dataLog.length > 0 ? dataLog[0].time : 0;
        
        dataLog.forEach(entry => {
          const relativeTime = (entry.time || 0) - baseTime;
          
          // VA数据流：包含所有数据点
          vaStream.time_series.push([
            isFinite(entry.valence) ? entry.valence : 0,  // 无人脸时为0
            isFinite(entry.arousal) ? entry.arousal : 0,  // 无人脸时为0  
            entry.face ? 1.0 : 0.0   // 人脸检测状态
          ]);
          vaStream.time_stamps.push(relativeTime);

          // 情绪数据流：只包含有人脸且有情绪数据的点
          if (emotionStream && entry.face && entry.emotions) {
            const emotionArray = emotionNames.map(name => 
              entry.emotions[name] || 0.0
            );
            emotionStream.time_series.push(emotionArray);
            emotionStream.time_stamps.push(relativeTime);
          }
        });

        xdfData.streams.push(vaStream);
        if (emotionStream) {
          xdfData.streams.push(emotionStream);
        }

        // 手动异常标记数据流
        if (typeof manualAnomalyMarks !== 'undefined' && manualAnomalyMarks.length > 0) {
          console.log(`📤 准备导出异常标记数据流，包含 ${manualAnomalyMarks.length} 个标记:`, manualAnomalyMarks);
          
          const anomalyStream = {
            info: {
              name: 'ManualAnomalyMarks',
              type: 'Annotations',
              channel_count: 2,
              nominal_srate: 0.0,
              channel_format: 'float32',
              source_id: `AnomalyMarks_${this.startTime}`,
              uid: this.generateUID(),
              created_at: (Date.now() / 1000.0),
              hostname: window.location.hostname || 'localhost',
              desc: {
                acquisition: {
                  manufacturer: 'EmotionAnalysisApp',
                  model: 'Manual_Annotation_Tool_v1.0'
                },
                channels: {
                  channel: [
                    {
                      label: 'AnomalyFlag',
                      unit: 'binary',
                      type: 'Marker'
                    },
                    {
                      label: 'ValenceValue',
                      unit: 'normalized',
                      type: 'Emotion'
                    }
                  ]
                }
              }
            },
            time_series: [],
            time_stamps: []
          };

          // 添加异常标记数据
          manualAnomalyMarks.forEach(mark => {
            anomalyStream.time_series.push([1, mark.valence]); // 异常标记=1，valence值
            anomalyStream.time_stamps.push(mark.time);
          });

          xdfData.streams.push(anomalyStream);
          console.log(`📦 XDF导出包含 ${manualAnomalyMarks.length} 个异常标记`);
        }

      return xdfData;
    }

    // 生成LSL标准的UID
      generateUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }      // 从 XDF 格式导入
      importFromXDF(xdfData) {
        try {
          const newDataLog = [];
          
          // 找到VA和情绪数据流
          const vaStream = xdfData.streams.find(s => s.info.name === 'EmotionAnalysis_VA');
          const emotionStream = xdfData.streams.find(s => s.info.name === 'EmotionAnalysis_Emotions');
          const anomalyStream = xdfData.streams.find(s => s.info.name === 'ManualAnomalyMarks');

          if (!vaStream) {
            throw new Error('No VA data stream found in XDF file');
          }

          console.log(`📥 XDF导入检测到的数据流:`, {
            VA数据流: !!vaStream,
            情绪数据流: !!emotionStream,
            异常标记流: !!anomalyStream
          });

          // 重建所有数据点（包括无人脸的）
          vaStream.time_series.forEach((vaData, index) => {
            const timestamp = vaStream.time_stamps[index];
            const faceDetected = vaData.length > 2 ? vaData[2] > 0.5 : true; // 向后兼容
            
            const dataPoint = {
              time: timestamp,
              valence: faceDetected ? vaData[0] : NaN,
              arousal: faceDetected ? vaData[1] : NaN,
              face: faceDetected
            };

            // 添加情绪数据（如果有且有人脸）
            if (emotionStream && faceDetected) {
              // 查找最接近时间戳的情绪数据
              let closestEmotionIndex = -1;
              let minTimeDiff = Infinity;
              
              emotionStream.time_stamps.forEach((emotionTime, i) => {
                const timeDiff = Math.abs(emotionTime - timestamp);
                if (timeDiff < minTimeDiff) {
                  minTimeDiff = timeDiff;
                  closestEmotionIndex = i;
                }
              });

              if (closestEmotionIndex !== -1 && minTimeDiff < 0.1) { // 100ms容差
                const emotionData = emotionStream.time_series[closestEmotionIndex];
                const emotionNames = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise'];
                
                dataPoint.emotions = {};
                emotionNames.forEach((name, i) => {
                  dataPoint.emotions[name] = emotionData[i] || 0;
                });
                
                // 计算主导情绪
                let maxEmotion = 'Neutral';
                let maxValue = dataPoint.emotions.Neutral || 0;
                emotionNames.forEach(name => {
                  if (dataPoint.emotions[name] > maxValue) {
                    maxValue = dataPoint.emotions[name];
                    maxEmotion = name;
                  }
                });
                dataPoint.dominantEmotion = maxEmotion;
              }
            }

            newDataLog.push(dataPoint);
          });

          // 处理异常标记数据流
          if (anomalyStream) {
            console.log(`🎯 发现异常标记数据流，包含 ${anomalyStream.time_series.length} 个标记`);
            
            // 清空现有异常标记
            manualAnomalyMarks.splice(0, manualAnomalyMarks.length);
            
            // 导入异常标记
            anomalyStream.time_series.forEach((markData, index) => {
              const timestamp = anomalyStream.time_stamps[index];
              const valenceValue = markData[1]; // 第二个通道是valence值
              
              manualAnomalyMarks.push({
                time: timestamp,
                valence: valenceValue,
                marked: true,
                markTime: Date.now()
              });
            });
            
            console.log(`✅ 已导入 ${manualAnomalyMarks.length} 个异常标记:`, manualAnomalyMarks);
            
            // 更新异常标记状态显示
            updateAnomalyMarkingStatus();
            
            // 更新图表中的异常标记
            updateChartAnomalyMarks();
          } else {
            console.log(`ℹ️ XDF文件中未发现异常标记数据流`);
          }

          return newDataLog;
        } catch (error) {
          console.error('Failed to import XDF data:', error);
          throw error;
        }
      }
    }

    // 创建XDF格式处理器实例
    const xdfFormatter = new XDFFormatter();

    // 情绪检测切换
    function toggleEmotionDetection() {
      const container = document.getElementById('emotionChartContainer');
      if (emotionDetectionEnabled) {
        container.style.display = 'block';
      } else {
        container.style.display = 'none';
      }
    }

    document.getElementById('emotionToggle').addEventListener('change', (e) => {
      emotionDetectionEnabled = e.target.checked;
      window.emotionDetectionEnabled = emotionDetectionEnabled; // 更新全局变量
      toggleEmotionDetection();
    });

    // API 选择器事件监听
    document.getElementById('apiSelector').addEventListener('change', async (e) => {
      currentAPI = e.target.value;
      console.log(`切换到 ${currentAPI} API`);
      
      if (currentAPI === 'deepface') {
        await checkDeepFaceAPI();
      } else {
        apiConnected = true; // MorphCast 总是可用的（如果有license key）
        updateApiStatus('MorphCast 已选择');
      }
    });

    // 检查 DeepFace API 状态
    async function checkDeepFaceAPI() {
      const statusSpan = document.getElementById('apiStatus');
      
      try {
        statusSpan.textContent = '状态: 连接中...';
        statusSpan.style.color = '#fbbf24';
        
        const response = await fetch(`${deepfaceApiUrl}/health`, {
          method: 'GET',
          timeout: 5000
        });
        
        if (response.ok) {
          apiConnected = true;
          updateApiStatus('DeepFace 已连接');
          console.log('DeepFace API 连接成功');
        } else {
          throw new Error('API 响应错误');
        }
      } catch (error) {
        console.error('DeepFace API 连接失败:', error);
        apiConnected = false;
        updateApiStatus('DeepFace 未连接');
        
        // 如果连接失败，询问用户是否启动服务
        if (confirm('DeepFace API 服务未启动。\n\n点击"确定"查看启动说明，点击"取消"切换回 MorphCast。')) {
          showDeepFaceStartupHelp();
        } else {
          document.getElementById('apiSelector').value = 'morphcast';
          currentAPI = 'morphcast';
          apiConnected = true;
          updateApiStatus('MorphCast 已选择');
        }
      }
    }

    // 更新 API 状态显示
    function updateApiStatus(message) {
      const statusSpan = document.getElementById('apiStatus');
      statusSpan.textContent = `状态: ${message}`;
      
      if (message.includes('已连接') || message.includes('已选择')) {
        statusSpan.style.color = '#10b981';
      } else if (message.includes('连接中')) {
        statusSpan.style.color = '#fbbf24';
      } else {
        statusSpan.style.color = '#ef4444';
      }
    }

    // 显示 DeepFace 启动帮助
    function showDeepFaceStartupHelp() {
      alert(`DeepFace API 服务启动说明：

1. 打开命令行，进入项目目录：
   cd c:\\MyWork\\RunMorphCast\\deepface-api

2. 运行管理脚本：
   manage_python.bat

3. 选择 "1. Install Python Environment"（首次使用）
   然后选择 "2. Start Service"

4. 等待服务启动后，刷新本页面即可使用 DeepFace API`);
    }

    // 生理信号导入事件监听器
    
    // 统一文件导入事件（支持CSV和XDF）
    document.getElementById('physioFileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const fileExtension = file.name.toLowerCase().split('.').pop();
        let xdfData;
        
        if (fileExtension === 'csv') {
          // CSV先转换为XDF格式
          console.log('检测到CSV文件，转换为XDF格式...');
          xdfData = parseShimmerCSVToXDF(text);
        } else if (fileExtension === 'xdf' || fileExtension === 'json') {
          // 直接解析XDF
          console.log('检测到XDF文件，直接解析...');
          xdfData = typeof text === 'string' ? JSON.parse(text) : text;
        } else {
          throw new Error('不支持的文件格式。请选择 CSV、XDF 或 JSON 文件。');
        }
        
        // 从XDF格式解析数据用于显示
        const parsedData = parseXDFData(xdfData);
        
        // 存储数据
        physiologicalData.gsr = parsedData.gsr || [];
        physiologicalData.ppg = parsedData.ppg || [];
        physiologicalData.startTime = Date.now();
        
        // 存储XDF格式数据用于导出
        window.convertedPhysiologicalXDF = xdfData;
        
        // 更新状态
        document.getElementById('physiologicalStatus').textContent = 
          `已导入: GSR ${physiologicalData.gsr.length}点, PPG ${physiologicalData.ppg.length}点`;
        
        // 启用转换按钮
        document.getElementById('convertToXdfBtn').disabled = false;
        
        // 更新图表并自动显示
        if (physiologicalData.gsr.length > 0) {
          chart.updateGSRData(physiologicalData.gsr);
          chart.toggleGSRDisplay(true); // 自动显示GSR
        }
        if (physiologicalData.ppg.length > 0) {
          chart.updatePPGData(physiologicalData.ppg);
          chart.togglePPGDisplay(true); // 自动显示PPG
        }
        
        console.log(`${fileExtension.toUpperCase()}数据处理成功:`, {
          gsrPoints: physiologicalData.gsr.length,
          ppgPoints: physiologicalData.ppg.length,
          xdfStreams: xdfData.streams.length
        });
        
      } catch (error) {
        alert(`文件导入失败: ${error.message}`);
        console.error('文件解析错误:', error);
      }
    });

    // 转换并导出XDF按钮
    document.getElementById('convertToXdfBtn').addEventListener('click', () => {
      // 检查是否有可导出的数据
      const hasGSR = physiologicalData.gsr && physiologicalData.gsr.length > 0;
      const hasPPG = physiologicalData.ppg && physiologicalData.ppg.length > 0;
      const hasAnomalies = manualAnomalyMarks && manualAnomalyMarks.length > 0;
      const hasEmotionData = dataLog && dataLog.some(record => record.face && isFinite(record.valence));
      
      if (!hasGSR && !hasPPG && !hasAnomalies && !hasEmotionData) {
        alert('请先导入数据或添加异常标记');
        return;
      }
      
      try {
        let xdfData;
        
        // 如果已经有转换好的XDF数据，直接使用；否则重新转换
        if (window.convertedPhysiologicalXDF) {
          xdfData = window.convertedPhysiologicalXDF;
          
          // 如果有新的异常标记，需要更新XDF数据
          if (manualAnomalyMarks && manualAnomalyMarks.length > 0) {
            xdfData = convertPhysiologicalToXDF(physiologicalData.gsr || [], physiologicalData.ppg || []);
          }
        } else {
          // 从当前数据重新生成XDF格式
          xdfData = convertPhysiologicalToXDF(physiologicalData.gsr || [], physiologicalData.ppg || []);
        }
        
        // 直接导出XDF文件
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `physiological_data_${timestamp}.xdf`;
        
        exportPhysiologicalXDF(xdfData, filename);
        
        const anomalyCount = manualAnomalyMarks ? manualAnomalyMarks.length : 0;
        alert(`导出成功！\n文件名: ${filename}\n- 数据流: ${xdfData.streams.length} 个\n- GSR: ${physiologicalData.gsr?.length || 0} 数据点\n- PPG: ${physiologicalData.ppg?.length || 0} 数据点\n- 手动异常标记: ${anomalyCount} 个`);
        
        console.log('XDF文件导出成功:', xdfData);
        
      } catch (error) {
        alert('XDF导出失败: ' + error.message);
        console.error('XDF导出错误:', error);
      }
    });

    // 全局变量存储异常检测结果
    let netsDetector = null;
    let anomalyResults = null;
    let detectionCancelled = false; // 检测取消标志
    let edaPreprocessor = new EDAPreprocessor(); // EDA预处理器
    let cleanedGSRData = null; // 存储清理后的GSR数据

    // 清除异常检测结果功能
    function clearAnomalyResults() {
      anomalyResults = null;
      cleanedGSRData = null; // 重置清理后的数据
      netsDetector = null; // 重置检测器
      
      // 清除图表上的异常点显示和清理后数据
      if (chart) {
        chart.clearAnomalies();
        clearCleanedData();
      }
    }

    // 更新图表显示异常点的函数
    function updateChartWithAnomalies() {
      if (!anomalyResults || !chart) return;
      
      // 默认显示异常点，使用默认大小
      const pointSize = 8;
      
      // 准备异常点数据 - 使用清理后的数据或原始数据
      const anomalyPoints = anomalyResults.anomalies.map(anomaly => ({
        x: physiologicalData.gsr[anomaly.index]?.time || anomaly.index,
        y: anomaly.value,
        score: anomaly.score,
        entropy: anomaly.entropy
      }));
      
      chart.showAnomalies(anomalyPoints, {
        color: '#ff4444',
        size: pointSize
      });
    }

    // —— 视频文件选择功能 —— //
    let videoSelected = false;
    
    // 点击选择视频按钮
    selectVideoBtn.onclick = () => videoInput.click();
    
    // 处理视频文件选择
    videoInput.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      // 验证文件类型
      if (!file.type.startsWith('video/')) {
        alert('请选择有效的视频文件');
        return;
      }
      
      // 创建本地URL
      const videoURL = URL.createObjectURL(file);
      
      // 设置视频源
      video.src = videoURL;
      video.style.display = 'block';
      
      // 更新信息显示
      const fileSize = (file.size / 1024 / 1024).toFixed(2);
      videoInfo.textContent = `已选择: ${file.name} (${fileSize}MB)`;
      
      // 重置状态
      videoSelected = true;
      analyzed = false;
      dataLog = [];
      originalDataLog = [];
      chart.reset();
      analyzeBtn.disabled = false;
      analyzeBtn.textContent = '① Analyze（预处理）';
      downloadBtn.disabled = true;
      statusEl.textContent = '';
      
      // 重置生理信号数据
      physiologicalData = { gsr: [], ppg: [], startTime: null };
      chart.clearPhysiologicalData();
      document.getElementById('physiologicalStatus').textContent = '未导入数据';
      document.getElementById('convertToXdfBtn').disabled = true;
      
      // 重置数据处理状态
      valenceOffset = 0;
      arousalOffset = 0;
      updateDataProcessingStatus();
      
      // 重置SDK状态
      if (sdkInstance) {
        try {
          sdkInstance.stop();
        } catch (e) {
          console.warn('停止旧SDK实例时出错:', e);
        }
        sdkInstance = null;
      }
      loaderStarted = false;
      
      console.log(`视频文件已选择: ${file.name}, 大小: ${fileSize}MB`);
    };

    // —— 数据与状态 —— //
    let dataLog = [];
    let originalDataLog = []; // 保存原始数据，用于重置
    let analyzed = false;
    let loaderStarted = false;
    let lastFaceDetected = true;
    let lastCaptureTime = 0; // 全局声明
    let currentFrameHasFace = false; // 当前帧是否检测到脸部
    let sdkInstance = null; // SDK实例，用于停止

    // 数据处理状态
    let valenceOffset = 0; // Valence偏移量
    let arousalOffset = 0; // Arousal偏移量

    // Rate-of-Change 处理状态
    let processedDataLog = []; // 处理后的数据
    let derivativeDataLog = []; // 导数数据
    let eventsLog = []; // 检测到的事件
    let neurokitProcessed = false; // NeuroKit处理状态
    let anomalyDetected = false; // 异常检测状态
    let cleanedGSRDataPanel = null; // 面板中的清理后GSR数据
    let anomalyResultsPanel = null; // 面板中的异常检测结果
    let processingSteps = {
      step0: false, // 基础整理
      neurokit: false, // NeuroKit预处理
      step1: false, // 去伪迹
      step2: false, // 标准化
      step3: false, // 导数计算
      step4: false, // 导数后处理
      step5: false, // 事件判定
      nets: false   // 异常检测
    };
    let showDerivative = false; // 是否显示导数曲线
    let showEvents = false; // 是否显示事件标记

    // =================== Rate-of-Change 数据处理函数 ===================
    
    // 中值滤波函数
    function medianFilter(series, win = 5) {
      const half = Math.floor(win / 2);
      const out = series.map(v => v);
      for (let i = 0; i < series.length; i++) {
        const w = [];
        for (let k = i - half; k <= i + half; k++) {
          if (k >= 0 && k < series.length) {
            const v = series[k];
            if (Number.isFinite(v)) w.push(v);
          }
        }
        out[i] = w.length ? w.sort((a,b)=>a-b)[Math.floor(w.length/2)] : NaN;
      }
      return out;
    }

    // Z-score标准化
    function zscore(arr) {
      const vals = arr.filter(Number.isFinite);
      if (vals.length === 0) return arr.map(() => NaN);
      const mu = vals.reduce((s,v)=>s+v,0)/vals.length;
      const sigma = Math.sqrt(vals.reduce((s,v)=>s+(v-mu)*(v-mu),0)/vals.length) || 1;
      return arr.map(v => Number.isFinite(v) ? (v - mu) / sigma : NaN);
    }

    // 鲁棒导数（滑动线性回归斜率）
    function slopeByWindow(t, x, win = 9) {
      const half = Math.floor(win/2);
      const out = Array(x.length).fill(NaN);
      for (let i = 0; i < x.length; i++) {
        const L = Math.max(0, i - half), R = Math.min(x.length - 1, i + half);
        let n=0, sumT=0, sumX=0, sumTT=0, sumTX=0;
        for (let k = L; k <= R; k++) {
          const xi = x[k]; if (!Number.isFinite(xi)) continue;
          const ti = t[k];
          n++; sumT += ti; sumX += xi; sumTT += ti*ti; sumTX += ti*xi;
        }
        const denom = n * sumTT - sumT * sumT;
        if (n >= 2 && denom !== 0) out[i] = (n * sumTX - sumT * sumX) / denom;
      }
      return out;
    }

    // SG导数（简化版：滑动多项式拟合）
    function sgDerivative(t, x, win = 15, poly = 3) {
      const half = Math.floor(win/2);
      const out = Array(x.length).fill(NaN);
      
      for (let i = 0; i < x.length; i++) {
        const L = Math.max(0, i - half), R = Math.min(x.length - 1, i + half);
        const T = [], Y = [];
        const t0 = t[i];
        
        for (let k = L; k <= R; k++) {
          if (!Number.isFinite(x[k])) continue;
          const dt = t[k] - t0;
          const row = [];
          for (let d = 0; d <= poly; d++) row.push(Math.pow(dt, d));
          T.push(row);
          Y.push(x[k]);
        }
        
        if (T.length < poly + 1) continue;
        
        try {
          if (typeof numeric !== 'undefined') {
            const TT = numeric.dot(numeric.transpose(T), T);
            const TY = numeric.dot(numeric.transpose(T), Y);
            const a = numeric.solve(TT, TY);
            out[i] = a[1]; // 一阶导数系数
          } else {
            // 回退到简单差分
            if (i > 0 && i < x.length - 1 && Number.isFinite(x[i-1]) && Number.isFinite(x[i+1])) {
              out[i] = (x[i+1] - x[i-1]) / (t[i+1] - t[i-1]);
            }
          }
        } catch (e) {
          // 如果矩阵求解失败，回退到简单差分
          if (i > 0 && i < x.length - 1 && Number.isFinite(x[i-1]) && Number.isFinite(x[i+1])) {
            out[i] = (x[i+1] - x[i-1]) / (t[i+1] - t[i-1]);
          }
        }
      }
      return out;
    }

    // 移动平均平滑
    function movingAverage(series, win = 3) {
      const half = Math.floor(win / 2);
      const out = Array(series.length).fill(NaN);
      for (let i = 0; i < series.length; i++) {
        let sum = 0, count = 0;
        for (let k = i - half; k <= i + half; k++) {
          if (k >= 0 && k < series.length && Number.isFinite(series[k])) {
            sum += series[k];
            count++;
          }
        }
        out[i] = count > 0 ? sum / count : NaN;
      }
      return out;
    }

    // 事件检测
    function detectEvents(t, dxdt, up=0.12, dn=-0.12, minDur=0.8) {
      const events = [];
      let state = 0, startIdx = -1;
      
      for (let i = 0; i < dxdt.length; i++) {
        const v = dxdt[i];
        if (!Number.isFinite(v)) continue;

        if (state === 0) {
          if (v >= up) { state = 1; startIdx = i; }
          else if (v <= dn) { state = -1; startIdx = i; }
        } else if (state === 1) {
          if (v < up * 0.5) {
            const dur = t[i] - t[startIdx];
            if (dur >= minDur) events.push({type:'rise', t:t[startIdx], dur, idx: startIdx});
            state = 0; startIdx = -1;
          }
        } else if (state === -1) {
          if (v > dn * 0.5) {
            const dur = t[i] - t[startIdx];
            if (dur >= minDur) events.push({type:'fall', t:t[startIdx], dur, idx: startIdx});
            state = 0; startIdx = -1;
          }
        }
      }
      return events;
    }

    // 更新处理状态显示
    function updateProcessingStatus(step, status, message = '') {
      processingSteps[step] = status;
      const statusEl = document.getElementById(`${step}Status`) || document.getElementById(`${step}StatusPanel`);
      if (statusEl) {
        statusEl.textContent = status ? '✓ 已完成' : '未处理';
        statusEl.style.color = status ? '#4caf50' : '#888';
      }
      
      // 支持NeuroKit和NETS状态元素
      if (step === 'neurokit') {
        const neurokitStatus = document.getElementById('neurokitStatus');
        if (neurokitStatus) {
          neurokitStatus.textContent = status ? '✓ 已完成' : '未处理';
          neurokitStatus.style.color = status ? '#4caf50' : '#888';
        }
      } else if (step === 'nets') {
        const netsStatus = document.getElementById('netsStatusPanel');
        if (netsStatus) {
          netsStatus.textContent = status ? '✓ 已完成' : '未处理';
          netsStatus.style.color = status ? '#ff6b6b' : '#888';
        }
      }
      
      const mainStatus = document.getElementById('processingStatus');
      if (mainStatus && message) {
        mainStatus.textContent = message;
      }
    }

    // 面板中的清理后数据显示功能
    function updateChartWithCleanedData() {
      // 检查是否有可用的清理后数据（优先使用面板数据）
      const cleanedData = cleanedGSRDataPanel || cleanedGSRData;
      const dataSource = cleanedGSRDataPanel ? 'NeuroKit' : 'NETS';
      
      if (!chart || !cleanedData || !physiologicalData.gsr) {
        console.log('chart或清理后数据未准备好');
        return;
      }
      
      try {
        // 准备清理后的数据点
        const cleanedPoints = cleanedData.map((value, idx) => {
          const originalPoint = physiologicalData.gsr[idx];
          return {
            x: originalPoint ? originalPoint.time : idx,
            y: value
          };
        });
        
        // 根据数据源设置样式
        const isNeuroKit = dataSource === 'NeuroKit';
        const cleanedDataset = {
          label: `GSR (${isNeuroKit ? 'NeuroKit清理' : 'NETS清理'})`,
          data: cleanedPoints,
          borderColor: isNeuroKit ? '#4caf50' : '#ff9800',
          backgroundColor: isNeuroKit ? 'rgba(76, 175, 80, 0.1)' : 'rgba(255, 152, 0, 0.1)',
          borderWidth: 1.5,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 3,
          yAxisID: 'y'
        };
        
        // 检查是否已经有清理后的数据集，移除旧的
        const existingIndices = [];
        chart.data.datasets.forEach((dataset, idx) => {
          if (dataset.label.includes('清理')) {
            existingIndices.push(idx);
          }
        });
        
        // 从后往前删除，避免索引变化
        existingIndices.reverse().forEach(idx => {
          chart.data.datasets.splice(idx, 1);
        });
        
        // 添加新的清理后数据集
        chart.data.datasets.push(cleanedDataset);
        
        chart.update();
        console.log(`显示${dataSource}清理后的GSR数据: ${cleanedPoints.length}个点`);
      } catch (error) {
        console.error('显示清理后数据失败:', error);
      }
    }

    // 清除清理后的数据
    function clearCleanedData() {
      if (!chart) return;
      
      // 查找所有清理后的数据集
      const indicesToRemove = [];
      chart.data.datasets.forEach((dataset, index) => {
        if (dataset.label.includes('清理')) {
          indicesToRemove.push(index);
        }
      });
      
      // 从后往前删除，避免索引变化
      indicesToRemove.reverse().forEach(index => {
        chart.data.datasets.splice(index, 1);
      });
      
      if (indicesToRemove.length > 0) {
        chart.update();
        console.log(`已清除${indicesToRemove.length}个清理后的数据集`);
      }
    }

    // 面板中的异常点显示功能
    function updateChartWithAnomaliesPanelData() {
      console.log('updateChartWithAnomaliesPanelData called');
      console.log('anomalyResultsPanel:', anomalyResultsPanel);
      console.log('chart:', chart);
      
      if (!anomalyResultsPanel || !chart) {
        console.log('anomalyResultsPanel或chart未准备好');
        return;
      }
      
      console.log('anomalyResultsPanel.anomalies:', anomalyResultsPanel.anomalies);
      console.log('anomalies count:', anomalyResultsPanel.anomalies ? anomalyResultsPanel.anomalies.length : 'N/A');
      
      try {
        // 获取当前选择的数据源
        const dataSource = document.getElementById('netsDataSourcePanel').value;
        let sourceData;
        let yAxisID = 'y-axis-default'; // 默认坐标系
        
        console.log('数据源:', dataSource);
        
        if (dataSource === 'gsr') {
          sourceData = physiologicalData.gsr;
          yAxisID = 'y-axis-gsr';
        } else if (dataSource === 'valence') {
          sourceData = window.valenceData || [];
          yAxisID = 'y-axis-default'; // Valence使用默认坐标系
        }
        
        console.log('sourceData length:', sourceData ? sourceData.length : 'N/A');
        console.log('异常点索引:', anomalyResultsPanel.anomalies.map(a => a.index));
        
        // 准备异常点数据 - 根据数据源获取正确的坐标
        const anomalyPoints = anomalyResultsPanel.anomalies.map(anomaly => {
          let x, y;
          
          console.log(`处理异常点索引 ${anomaly.index}`);
          
          if (sourceData && sourceData[anomaly.index]) {
            x = sourceData[anomaly.index].time || anomaly.index;
            y = sourceData[anomaly.index].value || anomaly.value;
            console.log(`从sourceData获取: x=${x}, y=${y}`);
          } else {
            x = anomaly.index;
            y = anomaly.value;
            console.log(`使用anomaly.value: x=${x}, y=${y}`);
          }
          
          console.log(`异常点 ${anomaly.index}: x=${x}, y=${y}`);
          
          return {
            x: x,
            y: y,
            score: anomaly.score,
            entropy: anomaly.entropy
          };
        });
        
        console.log(`准备显示${anomalyPoints.length}个异常点 (数据源: ${dataSource}, Y轴: ${yAxisID})`);
        
        // 更新异常点数据集的Y轴
        if (chart._datasets && chart._datasets[10]) {
          chart._datasets[10].yAxisID = yAxisID;
          console.log('异常点数据集Y轴已设置为:', yAxisID);
        } else {
          console.error('异常点数据集不存在 chart._datasets[10]');
        }
        
        chart.showAnomalies(anomalyPoints, {
          color: '#ff6b6b',
          size: 6
        });
      } catch (error) {
        console.error('显示异常点失败:', error);
      }
    }

    // MorphCast 自定义帧源 - 控制处理节奏
    const customSource = {
      crtImgData: null,
      resolver: null,
      shouldProcess: true, // 新增：控制是否处理帧
      _stopped: false,     // 添加停止状态
      analyzeFrame(imgData) {
        if (!this.shouldProcess || this._stopped) return; // 跳过不需要处理的帧
        if (this.resolver) { this.resolver(imgData); this.resolver = null; }
        else { this.crtImgData = imgData; }
      },
      getFrame() {
        if (this._stopped) return Promise.reject(new Error('Source stopped'));
        if (this.crtImgData) { const p = Promise.resolve(this.crtImgData); this.crtImgData = null; return p; }
        return new Promise(res => this.resolver = res);
      },
      start() { 
        this._stopped = false; 
        console.log('自定义帧源已启动');
      },
      stop() { 
        this._stopped = true; 
        this.shouldProcess = false;
        if (this.resolver) { 
          this.resolver = null; // 清理未完成的Promise
        }
        console.log('自定义帧源已停止');
      },
      get stopped() { return this._stopped; }
    };

    async function ensureLoader() {
      if (loaderStarted) return;
      loaderStarted = true;

      // 优先顺序：写死常量 -> URL ?key= -> localStorage('mc_license')
      const licKey = (LICENSE_KEY && LICENSE_KEY.trim()) || new URLSearchParams(location.search).get('key') || localStorage.getItem('mc_license') || '';
      let builder = CY.loader();
      if (licKey) builder = builder.licenseKey(licKey);
      else console.warn('未提供 MorphCast license key，SDK 可能无法初始化 (E07)。可在 LICENSE_KEY 填入，或用 ?key= / localStorage 设置。');

      await builder
        .addModule(CY.modules().FACE_DETECTOR.name) // 先加检测器
        .addModule(CY.modules().FACE_AROUSAL_VALENCE.name, { smoothness: 0.7 })
        .addModule(CY.modules().FACE_EMOTION.name, { smoothness: 0.4 }) // 添加情绪检测
        .source(customSource)
        .load()
        .catch((e) => { console.error('SDK 初始化失败', e); throw e; })
        .then((result) => { 
          sdkInstance = result; // 保存SDK实例
          window.currentCYInstance = result; // 也保存到全局变量用于重新初始化
          return result.start(); 
        });

      // 修正 FACE_DETECTOR 事件监听器
      window.addEventListener(CY.modules().FACE_DETECTOR.eventName, evt => {
        const detail = evt.detail || {};
        
        // 根据文档，直接使用 totalFaces 字段（范围 [0,6]）
        const totalFaces = detail.totalFaces || 0;
        currentFrameHasFace = totalFaces > 0;
        
        // 调试输出：显示检测结果
        console.log(`Face Detection: ${totalFaces} faces detected at time ${(lastCaptureTime || video.currentTime).toFixed(2)}s`);
        
        // 无论有无脸部，都记录一个数据点（用于标记无脸区域）
        const t = lastCaptureTime || video.currentTime;
        if (!currentFrameHasFace) {
          // 无脸时直接记录（VA事件不会触发）
          dataLog.push({ 
            time: t, 
            arousal: NaN, 
            valence: NaN, 
            face: false
          });
        }
      });

      // VA 输出：只有检测到脸部时才会触发
      window.addEventListener(CY.modules().FACE_AROUSAL_VALENCE.eventName, evt => {
        const out = evt.detail.output;
        const t = lastCaptureTime || video.currentTime;
        
        // 调试输出：显示VA检测结果
        console.log(`VA Detection: arousal=${out.arousal.toFixed(3)}, valence=${out.valence.toFixed(3)} at time ${t.toFixed(2)}s`);
        
        // 查找或创建当前时间的数据记录
        let dataRecord = dataLog.find(r => Math.abs(r.time - t) < 0.01);
        if (!dataRecord) {
          dataRecord = { 
            time: t, 
            arousal: out.arousal, 
            valence: out.valence, 
            face: true,
            emotions: {},
            dominantEmotion: undefined
          };
          dataLog.push(dataRecord);
        } else {
          dataRecord.arousal = out.arousal;
          dataRecord.valence = out.valence;
          dataRecord.face = true;
        }
      });

      // 情绪检测输出
      window.addEventListener(CY.modules().FACE_EMOTION.eventName, evt => {
        if (!emotionDetectionEnabled) return;
        
        const out = evt.detail.output;
        const t = lastCaptureTime || video.currentTime;
        
        // 调试输出：显示情绪检测结果
        console.log(`Emotion Detection at time ${t.toFixed(2)}s:`, out);
        
        // 查找或创建当前时间的数据记录
        let dataRecord = dataLog.find(r => Math.abs(r.time - t) < 0.01);
        if (!dataRecord) {
          dataRecord = { 
            time: t, 
            arousal: NaN, 
            valence: NaN, 
            face: true,
            emotions: out.emotion,
            dominantEmotion: out.dominantEmotion
          };
          dataLog.push(dataRecord);
        } else {
          dataRecord.emotions = out.emotion;
          dataRecord.dominantEmotion = out.dominantEmotion;
          dataRecord.face = true;
        }
      });
    }

    // 获取用户配置的检测区域
    function getDetectionRegion() {
      const overlay = document.getElementById('regionOverlay');
      
      // 如果区域检测未启用，返回全屏
      if (overlay.style.display === 'none' || overlay.style.display === '') {
        return {
          x: 0,
          y: 0,
          width: video.videoWidth,
          height: video.videoHeight
        };
      }
      
      // 从覆盖层获取区域信息
      const scaleX = video.videoWidth / video.clientWidth;
      const scaleY = video.videoHeight / video.clientHeight;
      
      // 直接从style属性获取位置和尺寸
      const overlayLeft = parseInt(overlay.style.left) || 0;
      const overlayTop = parseInt(overlay.style.top) || 0;
      const overlayWidth = parseInt(overlay.style.width) || 0;
      const overlayHeight = parseInt(overlay.style.height) || 0;
      
      const region = {
        x: Math.floor(overlayLeft * scaleX),
        y: Math.floor(overlayTop * scaleY),
        width: Math.floor(overlayWidth * scaleX),
        height: Math.floor(overlayHeight * scaleY)
      };
      
      // 边界检查
      region.x = Math.max(0, Math.min(region.x, video.videoWidth - 1));
      region.y = Math.max(0, Math.min(region.y, video.videoHeight - 1));
      region.width = Math.max(1, Math.min(region.width, video.videoWidth - region.x));
      region.height = Math.max(1, Math.min(region.height, video.videoHeight - region.y));
      
      return region;
    }

    // 区域检测功能
    let regionEnabled = false;

    function toggleRegion() {
      // 如果已经分析过，或者SDK已经初始化，则刷新页面
      if (analyzed || loaderStarted || sdkInstance) {
        console.log('检测到SDK状态，刷新页面以重置...');
        location.reload();
        return;
      }
      
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      const btn = document.getElementById('toggleRegion');
      const info = document.getElementById('regionInfo');
      
      regionEnabled = !regionEnabled;
      
      if (regionEnabled) {
        // 启用区域检测
        btn.textContent = '禁用区域检测';
        info.textContent = '拖拽红框移动位置，拖拽右下角红点调整大小';
        info.style.color = '#4caf50';
        
        // 确保视频已加载
        if (!video.videoWidth || !video.videoHeight) {
          alert('请等待视频加载完成后再启用区域检测');
          regionEnabled = false;
          btn.textContent = '启用区域检测';
          info.textContent = '点击启用后可在视频上拖拽选择检测区域';
          info.style.color = '#ccc';
          return;
        }
        
        // 显示默认区域（视频中心50%x60%）
        const videoRect = video.getBoundingClientRect();
        const defaultWidth = Math.floor(videoRect.width * 0.5);
        const defaultHeight = Math.floor(videoRect.height * 0.6);
        const defaultLeft = Math.floor(videoRect.width * 0.25);
        const defaultTop = Math.floor(videoRect.height * 0.1);
        
        overlay.style.display = 'block';
        overlay.style.left = defaultLeft + 'px';
        overlay.style.top = defaultTop + 'px';
        overlay.style.width = defaultWidth + 'px';
        overlay.style.height = defaultHeight + 'px';
        overlay.style.pointerEvents = 'auto';
        overlay.style.cursor = 'move';
        
        handle.style.display = 'block';
        handle.style.left = (defaultLeft + defaultWidth - 6) + 'px';
        handle.style.top = (defaultTop + defaultHeight - 6) + 'px';
        handle.style.cursor = 'se-resize';
        
        // 输出初始区域信息
        setTimeout(() => {
          const region = getDetectionRegion();
          console.log('区域检测已启用，初始区域:');
          console.log(`  视频尺寸: ${video.videoWidth}x${video.videoHeight}`);
          console.log(`  检测区域: ${region.x}x${region.y} ${region.width}x${region.height}`);
          console.log(`  覆盖率: ${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}%`);
          
          info.textContent = `检测区域: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% 覆盖)`;
        }, 100);
        
      } else {
        // 禁用区域检测
        btn.textContent = '启用区域检测';
        info.textContent = '点击启用后可在视频上拖拽选择检测区域';
        info.style.color = '#ccc';
        
        overlay.style.display = 'none';
        handle.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        
        console.log('区域检测已禁用，将使用全屏检测');
      }
    }

    // 初始化区域拖拽功能
    function initRegionDragHandlers() {
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      
      let isDraggingOverlay = false;
      let isDraggingHandle = false;
      let startX, startY, startLeft, startTop, startWidth, startHeight;
      
      // 覆盖层拖拽（移动位置）
      overlay.addEventListener('mousedown', (e) => {
        if (!regionEnabled) return;
        
        isDraggingOverlay = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(overlay.style.left) || 0;
        startTop = parseInt(overlay.style.top) || 0;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      // 拖拽控制点（调整大小）
      handle.addEventListener('mousedown', (e) => {
        if (!regionEnabled) return;
        
        isDraggingHandle = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(overlay.style.width) || 0;
        startHeight = parseInt(overlay.style.height) || 0;
        startLeft = parseInt(overlay.style.left) || 0;
        startTop = parseInt(overlay.style.top) || 0;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      // 鼠标移动事件
      document.addEventListener('mousemove', (e) => {
        if (!regionEnabled) return;
        
        const videoRect = video.getBoundingClientRect();
        
        if (isDraggingOverlay) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          let newLeft = startLeft + deltaX;
          let newTop = startTop + deltaY;
          
          // 边界限制
          const overlayWidth = parseInt(overlay.style.width) || 0;
          const overlayHeight = parseInt(overlay.style.height) || 0;
          
          newLeft = Math.max(0, Math.min(newLeft, videoRect.width - overlayWidth));
          newTop = Math.max(0, Math.min(newTop, videoRect.height - overlayHeight));
          
          overlay.style.left = newLeft + 'px';
          overlay.style.top = newTop + 'px';
          
          // 更新拖拽控制点位置
          updateHandlePosition();
          
          e.preventDefault();
        }
        
        if (isDraggingHandle) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          let newWidth = startWidth + deltaX;
          let newHeight = startHeight + deltaY;
          
          // 最小尺寸限制
          newWidth = Math.max(50, newWidth);
          newHeight = Math.max(50, newHeight);
          
          // 边界限制
          const currentLeft = parseInt(overlay.style.left) || 0;
          const currentTop = parseInt(overlay.style.top) || 0;
          
          newWidth = Math.min(newWidth, videoRect.width - currentLeft);
          newHeight = Math.min(newHeight, videoRect.height - currentTop);
          
          overlay.style.width = newWidth + 'px';
          overlay.style.height = newHeight + 'px';
          
          // 更新拖拽控制点位置
          updateHandlePosition();
          
          e.preventDefault();
        }
      });
      
      // 鼠标释放事件
      document.addEventListener('mouseup', () => {
        if (isDraggingOverlay || isDraggingHandle) {
          isDraggingOverlay = false;
          isDraggingHandle = false;
          
          // 输出当前区域信息
          logCurrentRegion();
        }
      });
      
      // 更新拖拽控制点位置
      function updateHandlePosition() {
        const overlayLeft = parseInt(overlay.style.left) || 0;
        const overlayTop = parseInt(overlay.style.top) || 0;
        const overlayWidth = parseInt(overlay.style.width) || 0;
        const overlayHeight = parseInt(overlay.style.height) || 0;
        
        handle.style.left = (overlayLeft + overlayWidth - 6) + 'px';
        handle.style.top = (overlayTop + overlayHeight - 6) + 'px';
      }
      
      // 输出当前区域信息
      function logCurrentRegion() {
        const region = getDetectionRegion();
        const videoRect = video.getBoundingClientRect();
        
        console.log('检测区域已更新:');
        console.log(`  显示区域: ${parseInt(overlay.style.left)}x${parseInt(overlay.style.top)} ${parseInt(overlay.style.width)}x${parseInt(overlay.style.height)}`);
        console.log(`  视频坐标: ${region.x}x${region.y} ${region.width}x${region.height}`);
        console.log(`  覆盖率: ${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}%`);
        
        // 更新信息显示
        const info = document.getElementById('regionInfo');
        info.textContent = `检测区域: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% 覆盖)`;
      }
    }

    function waitForVideoReady(v) {
      return new Promise(res => {
        if (v.videoWidth && v.videoHeight) return res();
        const tm = setInterval(() => {
          if (v.videoWidth && v.videoHeight) { clearInterval(tm); res(); }
        }, 100);
      });
    }

    // DeepFace API 调用函数
    async function analyzeFrameWithDeepFace(canvas) {
      try {
        // 将 canvas 转换为 base64
        const dataURL = canvas.toDataURL('image/jpeg', 0.8);
        
        // 调用 DeepFace API
        const response = await fetch(`${deepfaceApiUrl}/analyze`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            img: dataURL,
            enforce_detection: false
          })
        });
        
        if (!response.ok) {
          throw new Error(`DeepFace API 错误: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.status === 'success' && result.face) {
          return {
            valence: result.valence_arousal.valence,
            arousal: result.valence_arousal.arousal,
            emotions: result.emotions,
            dominant_emotion: result.dominant_emotion,
            face: true
          };
        } else {
          console.warn('DeepFace 分析失败:', result.message || '未检测到面部');
          return { face: false };
        }
      } catch (error) {
        console.error('DeepFace API 调用失败:', error);
        return { face: false };
      }
    }

    // 统一的帧分析函数
    async function analyzeFrame(imgData, canvas) {
      if (currentAPI === 'deepface') {
        return await analyzeFrameWithDeepFace(canvas);
      } else {
        // 使用 MorphCast
        customSource.analyzeFrame(imgData);
        return null; // MorphCast 通过事件异步返回结果
      }
    }

    // —— 阶段 1：预处理 —— //
    analyzeBtn.onclick = async () => {
      // 检查是否已选择视频
      if (!videoSelected || !video.src) {
        alert('请先选择视频文件');
        return;
      }
      
      // 检查 API 连接状态
      if (!apiConnected) {
        alert(`${currentAPI === 'deepface' ? 'DeepFace' : 'MorphCast'} API 未连接，请检查服务状态`);
        return;
      }
      
      // 立即禁用按钮，防止重复点击
      analyzeBtn.disabled = true;
      analyzeBtn.textContent = '处理中...';
      
      // 只有 MorphCast 需要加载 SDK
      if (currentAPI === 'morphcast') {
        await ensureLoader();
      }
      analyzed = false;
      dataLog = [];
      chart.reset();
      statusEl.textContent = 'Analyzing...';

      await waitForVideoReady(video);

      const oldRate = video.playbackRate;
      const oldControls = video.controls;
      const oldCurrentTime = video.currentTime;
      video.muted = true;
      video.controls = false;
      video.playbackRate = 1.0;

      // 真正的按帧抓取模式：基于帧序号计算精确时间
      const duration = video.duration;
      const everyN = parseInt(frameIntervalInput.value) || 10; // 从用户输入获取抽帧间隔，默认10帧
      
      // 尝试获取视频真实帧率，如果获取不到则抛出错误
      let fps = null;
      let fpsDetected = false;
      
      try {
        // 方法1：通过videoTracks API获取帧率
        if (video.videoTracks && video.videoTracks.length > 0) {
          const track = video.videoTracks[0];
          if (track.frameRate) {
            fps = track.frameRate;
            fpsDetected = true;
            console.log(`从videoTracks获取帧率: ${fps}fps`);
          }
        }
        // 方法2：通过captureStream API估算（备用）
        if (!fpsDetected && video.captureStream) {
          try {
            const stream = video.captureStream();
            const videoTrack = stream.getVideoTracks()[0];
            const settings = videoTrack.getSettings();
            if (settings.frameRate) {
              fps = settings.frameRate;
              fpsDetected = true;
              console.log(`从captureStream获取帧率: ${fps}fps`);
            }
          } catch (e) {
            // 忽略captureStream错误
          }
        }
        // 如果都获取不到，抛出错误
        if (!fpsDetected) {
          throw new Error('无法获取视频帧率，请检查视频文件');
        }
      } catch (e) {
        console.error('获取视频帧率失败:', e);
        alert('无法获取视频帧率，分析可能不准确。建议尝试其他视频文件。');
        // 使用一个保守的默认值，但要明确告知用户
        fps = 25;
        console.warn(`使用保守默认帧率: ${fps}fps`);
      }
      
      // 计算视频总帧数和要处理的帧序号
      const totalVideoFrames = Math.floor(duration * fps);
      const frameNumbers = [];
      for (let frameNum = 0; frameNum < totalVideoFrames; frameNum += everyN) {
        frameNumbers.push(frameNum);
      }
      
      console.log(`开始预处理：视频时长 ${duration.toFixed(1)}s，${fps}fps，总帧数 ${totalVideoFrames}，每${everyN}帧抓一帧，需处理 ${frameNumbers.length} 帧`);
      console.log(`处理帧序号: [${frameNumbers.slice(0, 5).join(', ')}${frameNumbers.length > 5 ? '...' : ''}]`);
      
      let frameCount = 0;
      const startTime = performance.now();

      // 预处理函数：直接跳转到指定帧的精确时间
      const processFrame = (frameNumber) => {
        return new Promise((resolve) => {
          const exactTime = frameNumber / fps; // 精确的帧时间戳
          
          const onSeeked = async () => {
            video.removeEventListener('seeked', onSeeked);
            
            // 抓取当前帧（使用区域检测）
            lastCaptureTime = exactTime; // 使用计算出的精确时间，不是video.currentTime
            
            console.log(`🎯 Processing frame ${frameNumber} at time ${exactTime.toFixed(3)}s`);
            
            // 每次都重新获取区域配置，确保使用最新状态
            const region = getDetectionRegion();
            
            // 每次都重新调整canvas尺寸以匹配当前区域设置
            grabCanvas.width = region.width;
            grabCanvas.height = region.height;
            
            // 清空canvas确保干净绘制
            grabCtx.clearRect(0, 0, grabCanvas.width, grabCanvas.height);
            
            // 只绘制指定区域
            grabCtx.drawImage(
              video,                          // 源视频
              region.x,                       // 源x坐标
              region.y,                       // 源y坐标
              region.width,                   // 源宽度
              region.height,                  // 源高度
              0,                              // 目标x（canvas左上角）
              0,                              // 目标y（canvas左上角）
              region.width,                   // 目标宽度
              region.height                   // 目标高度
            );
            
            const imgData = grabCtx.getImageData(0, 0, grabCanvas.width, grabCanvas.height);
            
            // 根据选择的 API 进行分析
            if (currentAPI === 'deepface') {
              const result = await analyzeFrame(imgData, grabCanvas);
              if (result && result.face) {
                // 直接添加到数据日志中
                const dataPoint = {
                  time: exactTime,
                  valence: result.valence,
                  arousal: result.arousal,
                  face: true
                };
                
                // 如果启用了情绪检测，添加情绪数据
                if (emotionDetectionEnabled && result.emotions) {
                  dataPoint.emotions = result.emotions;
                  dataPoint.dominantEmotion = result.dominant_emotion;
                  
                  // 添加7种基础情绪数据
                  Object.assign(dataPoint, result.emotions);
                }
                
                dataLog.push(dataPoint);
                console.log(`DeepFace 结果 @${exactTime.toFixed(3)}s:`, result);
              } else {
                dataLog.push({ time: exactTime, face: false });
              }
            } else {
              // 使用 MorphCast
              customSource.analyzeFrame(imgData);
            }
            
            frameCount++;
            const progress = ((frameCount / frameNumbers.length) * 100).toFixed(1);
            statusEl.textContent = `分析中... ${progress}% (${frameCount}/${frameNumbers.length}) - 帧${frameNumber}/${totalVideoFrames}@${exactTime.toFixed(3)}s [${fps}fps]`;
            
            resolve();
          };
          
          video.addEventListener('seeked', onSeeked);
          video.currentTime = exactTime;
        });
      };

      // 逐帧处理：按帧序号顺序处理
      try {
        for (const frameNumber of frameNumbers) {
          await processFrame(frameNumber);
          
          // 给SDK一点时间处理（可选，避免过快）
          await new Promise(resolve => setTimeout(resolve, 50));
        }

        // 处理完成，整理数据
        dataLog.sort((a, b) => a.time - b.time);
        const clean = [];
        let prev = -Infinity;
        for (const r of dataLog) {
          const hasVA = isFinite(r.arousal) && isFinite(r.valence);
          const hasFaceInfo = typeof r.face === 'boolean';
          if (r.time >= prev && (hasVA || hasFaceInfo)) {
            clean.push(r);
            prev = r.time;
          }
        }
        dataLog = clean;

        // 保存原始数据
        originalDataLog = dataLog.map(r => ({ ...r }));

        analyzed = true;
        statusEl.textContent = `分析完成！共 ${dataLog.length} 点，用时: ${((performance.now() - startTime) / 1000).toFixed(1)}s`;
        
        // 更新导出按钮状态
        updateEmotionXDFExportButtonState();
        
        // 保持分析按钮永久禁用，防止重复分析
        analyzeBtn.disabled = true;
        analyzeBtn.textContent = '已完成分析';

        // 停止自定义帧源和SDK实例
        console.log('停止帧源处理...');
        customSource.stop();
        
        // 停止SDK实例，释放资源
        if (sdkInstance) {
          try {
            sdkInstance.stop();
            console.log('SDK实例已停止');
          } catch (e) {
            console.warn('停止SDK时出错:', e);
          }
          sdkInstance = null;
        }
        
        // 重置loader状态，以便下次重新初始化
        loaderStarted = false;
        console.log('分析完成，SDK已关闭');

        // 加载数据到图表
        loadAllDataToChart();

      } catch (error) {
        console.error('预处理出错:', error);
        statusEl.textContent = '分析失败';
        // 即使出错也保持按钮禁用，防止重复尝试
        analyzeBtn.disabled = true;
        analyzeBtn.textContent = '分析失败';
      } finally {
        // 恢复视频状态
        video.playbackRate = oldRate;
        video.controls = oldControls;
        video.muted = false;
        video.currentTime = oldCurrentTime;
      }
    };

    // —— 导出 XDF —— //
    downloadBtn.onclick = () => {
      if (dataLog.length === 0) { alert('没有可导出的数据'); return; }
      
      console.log(`📤 开始导出情绪XDF数据...`);
      console.log(`📊 当前状态:`, {
        数据点数量: dataLog.length,
        异常标记数量: manualAnomalyMarks ? manualAnomalyMarks.length : 0,
        情绪检测启用: emotionDetectionEnabled
      });
      
      try {
        // 使用XDF格式处理器导出
        const xdfData = xdfFormatter.exportToXDF(dataLog, emotionDetectionEnabled, emotionNames);
        
        console.log(`✅ XDF数据生成成功:`, {
          数据流数量: xdfData.streams.length,
          数据流名称: xdfData.streams.map(s => s.info.name)
        });
        
        const xdfContent = JSON.stringify(xdfData, null, 2);
        const blob = new Blob([xdfContent], { type: 'application/json;charset=utf-8;' });
        
        // 创建下载链接
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        const timestamp = new Date().toISOString().slice(0,16).replace(/[:-]/g,'');
        const filename = `emotion_analysis_${timestamp}.xdf`;
        a.download = filename;
        a.style.display = 'none';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        
        console.log(`XDF数据已导出: ${filename}`);
        statusEl.textContent += ` | XDF已导出：${dataLog.length}个数据点`;
        
      } catch (error) {
        console.error('XDF export failed:', error);
        alert('XDF 导出失败：' + error.message);
      }
    };

    // —— 导入 XDF 回放 —— //
    importBtn.onclick = () => xdfInput.click();

    // —— 区域检测切换 —— //
    const toggleBtn = document.getElementById('toggleRegion');
    toggleBtn.onclick = () => toggleRegion();

    // 添加键盘快捷键支持
    document.addEventListener('keydown', (e) => {
      if (!regionEnabled) return;
      
      const overlay = document.getElementById('regionOverlay');
      const handle = document.getElementById('dragHandle');
      const step = e.shiftKey ? 10 : 1; // Shift键加速移动
      
      let currentLeft = parseInt(overlay.style.left) || 0;
      let currentTop = parseInt(overlay.style.top) || 0;
      let currentWidth = parseInt(overlay.style.width) || 0;
      let currentHeight = parseInt(overlay.style.height) || 0;
      
      const videoRect = video.getBoundingClientRect();
      
      switch(e.key) {
        case 'ArrowLeft':
          currentLeft = Math.max(0, currentLeft - step);
          overlay.style.left = currentLeft + 'px';
          e.preventDefault();
          break;
        case 'ArrowRight':
          currentLeft = Math.min(videoRect.width - currentWidth, currentLeft + step);
          overlay.style.left = currentLeft + 'px';
          e.preventDefault();
          break;
        case 'ArrowUp':
          currentTop = Math.max(0, currentTop - step);
          overlay.style.top = currentTop + 'px';
          e.preventDefault();
          break;
        case 'ArrowDown':
          currentTop = Math.min(videoRect.height - currentHeight, currentTop + step);
          overlay.style.top = currentTop + 'px';
          e.preventDefault();
          break;
        case '+':
        case '=':
          // 放大区域
          const newWidth = Math.min(videoRect.width - currentLeft, currentWidth + step * 5);
          const newHeight = Math.min(videoRect.height - currentTop, currentHeight + step * 5);
          overlay.style.width = newWidth + 'px';
          overlay.style.height = newHeight + 'px';
          e.preventDefault();
          break;
        case '-':
          // 缩小区域
          const minSize = 50;
          overlay.style.width = Math.max(minSize, currentWidth - step * 5) + 'px';
          overlay.style.height = Math.max(minSize, currentHeight - step * 5) + 'px';
          e.preventDefault();
          break;
      }
      
      // 更新拖拽控制点位置
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', '+', '=', '-'].includes(e.key)) {
        const newLeft = parseInt(overlay.style.left) || 0;
        const newTop = parseInt(overlay.style.top) || 0;
        const newWidth = parseInt(overlay.style.width) || 0;
        const newHeight = parseInt(overlay.style.height) || 0;
        
        handle.style.left = (newLeft + newWidth - 6) + 'px';
        handle.style.top = (newTop + newHeight - 6) + 'px';
        
        // 输出区域信息
        const region = getDetectionRegion();
        const info = document.getElementById('regionInfo');
        info.textContent = `检测区域: ${region.width}x${region.height} (${((region.width * region.height) / (video.videoWidth * video.videoHeight) * 100).toFixed(1)}% 覆盖)`;
      }
    });

    // 确保数据完整性
    function loadAllDataToChart() {
      const valenceData = [];
      const arousalData = [];
      const noFaceData = [];

      for (const r of dataLog) {
        if (r.face) {
          // 只有当值是有限数字时才添加到对应的数据集
          if (isFinite(r.valence)) valenceData.push({ x: r.time, y: r.valence });
          if (isFinite(r.arousal)) arousalData.push({ x: r.time, y: r.arousal });
        } else {
          noFaceData.push({ x: r.time, y: 1 });
        }
      }

      chart._datasets[0].data = valenceData;
      chart._datasets[1].data = arousalData;
      chart._datasets[2].data = noFaceData;
      
      // 同时更新GSR数据
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0 && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
      }
      
      chart._chart.update();
      
      // 加载情绪数据到情绪图表
      if (emotionChart && emotionDetectionEnabled) {
        loadEmotionDataToChart();
      }
      
      // 更新XDF导出按钮状态
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
    }

    // 加载情绪数据到情绪图表
    function loadEmotionDataToChart() {
      // 初始化每个情绪的数据数组
      emotionNames.forEach((emotion, index) => {
        emotionChart.data.datasets[index].data = [];
      });

      // 填充情绪数据
      for (const r of dataLog) {
        if (r.face && r.emotions) {
          emotionNames.forEach((emotion, index) => {
            if (r.emotions[emotion] !== undefined) {
              emotionChart.data.datasets[index].data.push({ 
                x: r.time, 
                y: r.emotions[emotion] 
              });
            }
          });
        }
      }

      // 同步时间轴范围
      const vaXAxis = chart._config.options.scales.xAxes[0];
      emotionChart.options.scales.xAxes[0].ticks.min = vaXAxis.ticks.min;
      emotionChart.options.scales.xAxes[0].ticks.max = vaXAxis.ticks.max;
      
      emotionChart.update();
    }

    // 更新当前情绪显示
    function updateCurrentEmotionDisplay(currentTime) {
      // 查找最接近当前时间的情绪数据
      let closestRecord = null;
      let minTimeDiff = Infinity;
      
      for (const record of dataLog) {
        if (record.face && record.emotions) {
          const timeDiff = Math.abs(record.time - currentTime);
          if (timeDiff < minTimeDiff) {
            minTimeDiff = timeDiff;
            closestRecord = record;
          }
        }
      }
      
      const currentEmotionDisplay = document.getElementById('currentEmotionDisplay');
      
      if (closestRecord && minTimeDiff < 0.5) { // 0.5秒容差
        // 显示主导情绪
        const dominantEmotion = closestRecord.dominantEmotion || 'Unknown';
        let emotionValue = 0;
        
        if (closestRecord.emotions && closestRecord.emotions[dominantEmotion]) {
          emotionValue = closestRecord.emotions[dominantEmotion];
          // DeepFace返回0-100的值，确保显示为百分比
          if (emotionValue > 1) {
            emotionValue = emotionValue; // 已经是0-100
          } else {
            emotionValue = emotionValue * 100; // 如果是0-1，转换为0-100
          }
        }
        
        currentEmotionDisplay.innerHTML = `
          <strong>${dominantEmotion}</strong> (${emotionValue.toFixed(1)}%)
        `;
      } else {
        currentEmotionDisplay.innerHTML = '<span class="muted">无数据</span>';
      }
    }

    // 数据处理函数
    function calculateDataMeans() {
      const valenceValues = [];
      const arousalValues = [];
      
      for (const r of dataLog) {
        if (r.face && isFinite(r.valence) && isFinite(r.arousal)) {
          valenceValues.push(r.valence);
          arousalValues.push(r.arousal);
        }
      }
      
      const valenceMean = valenceValues.length > 0 ? 
        valenceValues.reduce((sum, val) => sum + val, 0) / valenceValues.length : 0;
      const arousalMean = arousalValues.length > 0 ? 
        arousalValues.reduce((sum, val) => sum + val, 0) / arousalValues.length : 0;
        
      return { valenceMean, arousalMean };
    }

    function resetDataProcessing() {
      if (originalDataLog.length === 0) {
        alert('没有原始数据可恢复');
        return;
      }
      
      // 恢复原始数据
      dataLog = originalDataLog.map(r => ({ ...r }));
      
      // 重置状态
      valenceOffset = 0;
      arousalOffset = 0;
      
      loadAllDataToChart();
      updateDataProcessingStatus();
      
      console.log('数据处理已重置到原始状态');
    }

    function updateDataProcessingStatus() {
      const statusEl = document.getElementById('dataProcessingStatus');
      statusEl.textContent = '数据处理状态：正常显示';
    }

    // 应用自定义时间范围
    const applyWindowBtn = document.getElementById('applyWindow');
    applyWindowBtn.onclick = () => {
      const startInput = document.getElementById('windowStart');
      const endInput = document.getElementById('windowEnd');

      const start = parseFloat(startInput.value);
      const end = parseFloat(endInput.value);

      if (!isFinite(start) || !isFinite(end) || start >= end) {
        alert('请输入有效的起点和终点时间');
        return;
      }

      // 同时设置V/A图表和情绪图表的时间范围
      chart.setViewRange(start, end);
      
      // 同步设置情绪图表的时间范围
      if (emotionChart && emotionDetectionEnabled) {
        emotionChart.options.scales.xAxes[0].ticks.min = start;
        emotionChart.options.scales.xAxes[0].ticks.max = end;
        emotionChart.update();
      }
    };

    // XDF 导入逻辑
    xdfInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const xdfData = JSON.parse(reader.result);
          
          // 使用XDF格式处理器导入数据
          const importedData = xdfFormatter.importFromXDF(xdfData);
          
          // 更新数据
          dataLog = importedData;
          originalDataLog = importedData.map(r => ({ ...r }));
          processedDataLog = importedData.map(r => ({ ...r }));
          
          console.log('导入的前5个XDF数据点：', dataLog.slice(0, 5));
          
          // 检查是否包含情绪数据
          const hasEmotionData = dataLog.some(r => r.emotions);
          if (hasEmotionData && !emotionDetectionEnabled) {
            emotionDetectionEnabled = true;
            document.getElementById('emotionToggle').checked = true;
            toggleEmotionDetection();
          }
          
          loadAllDataToChart();
          statusEl.textContent = `XDF 导入成功：${dataLog.length} 点${hasEmotionData ? '（包含情绪数据）' : ''}`;
          
          // 显示Rate-of-Change处理面板
          document.getElementById('rocProcessingPanel').style.display = 'block';
          updateProcessingStatus('step0', false, 'XDF已导入，可开始数据处理');
          
        } catch (error) {
          console.error('XDF import failed:', error);
          alert('XDF 导入失败：' + error.message);
        }
      };
      reader.readAsText(file);
    };

    // 点击标记点跳转视频 + 异常标记功能
    chartCanvas.addEventListener('click', (evt) => {
      console.log('🖱️ 图表点击事件触发');
      console.log('🔍 事件详情:', {
        ctrlKey: evt.ctrlKey,
        shiftKey: evt.shiftKey,
        button: evt.button,
        clientX: evt.clientX,
        clientY: evt.clientY
      });
      
      // 异常标记模式处理 - 检测Ctrl+点击
      if (evt.ctrlKey) {
        console.log('🎯 检测到Ctrl+点击，进入异常标记模式');
        
        const t = chart.getTimeAtEvent(evt);
        console.log(`📍 点击位置时间: ${t}`);
        
        if (t != null && isFinite(t)) {
          console.log(`🔄 搜索最近的valence数据点，当前数据记录总数: ${dataLog.length}`);
          
          // 查找最接近的valence数据点
          let closestPoint = null;
          let minDistance = Infinity;
          let validPointsCount = 0;
          
          for (const record of dataLog) {
            if (record.face && isFinite(record.valence)) {
              validPointsCount++;
              const distance = Math.abs(record.time - t);
              if (distance < minDistance && distance < 1.0) { // 1秒容差
                minDistance = distance;
                closestPoint = record;
              }
            }
          }
          
          console.log(`📊 搜索结果: 有效valence数据点${validPointsCount}个, 最近距离${minDistance.toFixed(3)}s`);
          console.log(`🔍 找到最近的数据点:`, closestPoint);
          
          if (closestPoint) {
            if (evt.shiftKey) {
              // Ctrl + Shift + 点击 = 移除标记
              console.log('🗑️ Ctrl+Shift+点击 - 尝试移除异常标记');
              removeAnomalyMark(closestPoint.time);
            } else {
              // Ctrl + 点击 = 添加标记
              console.log('⭐ Ctrl+点击 - 尝试添加异常标记');
              addAnomalyMark(closestPoint.time, closestPoint.valence);
            }
          } else {
            console.log('❌ 未找到附近的有效valence数据点');
            alert('未找到附近的有效valence数据点，请确保有情绪数据');
          }
          
          evt.preventDefault();
          return;
        } else {
          console.log('❌ 无法获取点击位置的时间');
        }
      } else {
        console.log('📍 普通点击 - 执行时间跳转');
      }
      
      // 原有的时间跳转功能
      const t = chart.getTimeAtEvent(evt);
      if (t == null || !isFinite(t)) {
        console.log('❌ 时间跳转失败: 无效时间');
        return;
      }
      
      console.log(`⏰ 时间跳转到: ${t.toFixed(3)}s`);
      video.currentTime = Math.max(0, t);
      chart.updatePlaybackMarker(t);
    });

    // 修复播放时 Chart 显示问题
    video.addEventListener('timeupdate', () => {
      const t = video.currentTime;
      chart.updatePlaybackMarker(t);
      
      // 更新情绪显示（如果情绪检测启用）
      if (emotionDetectionEnabled) {
        updateCurrentEmotionDisplay(t);
      }
    });

    // 情绪图表点击跳转视频时间
    document.addEventListener('DOMContentLoaded', () => {
      console.log('🚀 页面DOMContentLoaded事件触发');
      console.log('🔧 开始初始化异常标记功能');
      
      // 初始化异常标记状态显示
      updateAnomalyMarkingStatus();
      
      // 初始化XDF导出按钮状态
      updateXDFExportButtonState();
      updateEmotionXDFExportButtonState();
      
      // 初始化 API 状态
      apiConnected = true; // MorphCast 默认可用
      updateApiStatus('MorphCast 已选择');
      
      // 初始化区域拖拽功能
      initRegionDragHandlers();
      
      console.log('🎯 异常标记功能已初始化完成');
      
      const emotionCanvas = document.getElementById('emotionChart');
      if (emotionCanvas) {
        emotionCanvas.addEventListener('click', (evt) => {
          if (!emotionChart || !emotionDetectionEnabled) return;
          
          // 获取点击位置的时间
          const canvasPosition = Chart.helpers.getRelativePosition(evt, emotionChart);
          const dataX = emotionChart.scales['x-axis-0'].getValueForPixel(canvasPosition.x);
          
          if (dataX != null && isFinite(dataX)) {
            video.currentTime = Math.max(0, dataX);
            chart.updatePlaybackMarker(dataX);
            updateCurrentEmotionDisplay(dataX);
          }
        });
      }
    });

    // =================== Rate-of-Change 处理步骤事件监听器 ===================
    
    // 步骤0: 基础整理
    document.getElementById('sortDataBtn').addEventListener('click', () => {
      if (originalDataLog.length === 0) {
        alert('请先导入CSV数据');
        return;
      }
      
      // 时间对齐和去重
      processedDataLog.sort((a, b) => a.time - b.time);
      const uniqueData = [];
      let lastTime = -Infinity;
      
      for (const record of processedDataLog) {
        if (record.time > lastTime + 0.001) { // 1ms容差
          uniqueData.push({ ...record });
          lastTime = record.time;
        }
      }
      
      processedDataLog = uniqueData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      updateProcessingStatus('step0', true, `时间对齐完成，保留${processedDataLog.length}个数据点`);
    });
    
    document.getElementById('resampleBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行时间对齐');
        return;
      }
      
      // 重采样到5Hz (200ms间隔)
      const startTime = processedDataLog[0].time;
      const endTime = processedDataLog[processedDataLog.length - 1].time;
      const interval = 0.2; // 200ms
      const newData = [];
      
      for (let t = startTime; t <= endTime; t += interval) {
        // 找到最近的有效数据点进行插值
        let beforeIdx = -1, afterIdx = -1;
        
        for (let i = 0; i < processedDataLog.length; i++) {
          if (processedDataLog[i].face && processedDataLog[i].time <= t) {
            beforeIdx = i;
          }
          if (processedDataLog[i].face && processedDataLog[i].time >= t && afterIdx === -1) {
            afterIdx = i;
            break;
          }
        }
        
        if (beforeIdx !== -1 && afterIdx !== -1 && beforeIdx !== afterIdx) {
          const before = processedDataLog[beforeIdx];
          const after = processedDataLog[afterIdx];
          const ratio = (t - before.time) / (after.time - before.time);
          
          newData.push({
            time: t,
            valence: before.valence + ratio * (after.valence - before.valence),
            arousal: before.arousal + ratio * (after.arousal - before.arousal),
            face: true
          });
        } else if (beforeIdx !== -1) {
          const record = processedDataLog[beforeIdx];
          if (Math.abs(record.time - t) < 0.1) { // 100ms容差
            newData.push({ ...record, time: t });
          }
        }
      }
      
      processedDataLog = newData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      updateProcessingStatus('step0', true, `重采样完成，${newData.length}个数据点@5Hz`);
    });

    // 50Hz重采样
    document.getElementById('resample50HzBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行时间对齐');
        return;
      }
      
      // 重采样到50Hz (20ms间隔)
      const startTime = processedDataLog[0].time;
      const endTime = processedDataLog[processedDataLog.length - 1].time;
      const interval = 0.02; // 20ms = 50Hz
      const newData = [];
      
      console.log(`🔄 开始50Hz重采样: ${startTime.toFixed(3)}s 到 ${endTime.toFixed(3)}s, 间隔=${interval}s`);
      
      for (let t = startTime; t <= endTime; t += interval) {
        // 找到最近的有效数据点进行插值
        let beforeIdx = -1, afterIdx = -1;
        
        for (let i = 0; i < processedDataLog.length; i++) {
          if (processedDataLog[i].face && processedDataLog[i].time <= t) {
            beforeIdx = i;
          }
          if (processedDataLog[i].face && processedDataLog[i].time >= t && afterIdx === -1) {
            afterIdx = i;
            break;
          }
        }
        
        if (beforeIdx !== -1 && afterIdx !== -1 && beforeIdx !== afterIdx) {
          // 线性插值
          const before = processedDataLog[beforeIdx];
          const after = processedDataLog[afterIdx];
          const ratio = (t - before.time) / (after.time - before.time);
          
          const newRecord = {
            time: t,
            valence: before.valence + ratio * (after.valence - before.valence),
            arousal: before.arousal + ratio * (after.arousal - before.arousal),
            face: true
          };
          
          // 如果有GSR数据，也进行插值
          if (before.gsr !== undefined && after.gsr !== undefined) {
            newRecord.gsr = before.gsr + ratio * (after.gsr - before.gsr);
          }
          
          // 如果有PPG数据，也进行插值
          if (before.ppg !== undefined && after.ppg !== undefined) {
            newRecord.ppg = before.ppg + ratio * (after.ppg - before.ppg);
          }
          
          newData.push(newRecord);
        } else if (beforeIdx !== -1) {
          const record = processedDataLog[beforeIdx];
          if (Math.abs(record.time - t) < 0.01) { // 10ms容差
            newData.push({ ...record, time: t });
          }
        }
      }
      
      processedDataLog = newData;
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      console.log(`✅ 50Hz重采样完成: ${newData.length}个数据点`);
      updateProcessingStatus('step0', true, `50Hz重采样完成，${newData.length}个数据点@50Hz`);
    });

    // NeuroKit GSR预处理
    document.getElementById('neurokitProcessBtn').addEventListener('click', async () => {
      if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
        alert('请先导入包含GSR数据的文件');
        return;
      }

      const method = document.getElementById('neurokitMethod').value || 'neurokit';
      const progressDiv = document.getElementById('neurokitProgress');
      const statusSpan = document.getElementById('neurokitStatus');
      const btn = document.getElementById('neurokitProcessBtn');
      
      try {
        btn.disabled = true;
        progressDiv.style.display = 'block';
        progressDiv.textContent = '开始NeuroKit预处理...';
        
        const rawGSRValues = physiologicalData.gsr.map(item => item.gsr);
        const samplingRate = physiologicalData.gsr.length > 1 ? 
          1 / (physiologicalData.gsr[1].time - physiologicalData.gsr[0].time) : 50;

        const progressCallback = (info) => {
          progressDiv.textContent = info.message;
        };

        cleanedGSRDataPanel = await edaPreprocessor.clean(rawGSRValues, samplingRate, method, progressCallback);
        
        // 直接替换physiologicalData中的GSR数据
        for (let i = 0; i < Math.min(physiologicalData.gsr.length, cleanedGSRDataPanel.length); i++) {
          physiologicalData.gsr[i].gsr = cleanedGSRDataPanel[i];
        }
        
        // 重新加载图表数据以显示清理后的数据
        loadAllDataToChart();
        
        progressDiv.style.display = 'none';
        updateProcessingStatus('neurokit', true, `NeuroKit处理完成: ${method}方法, 已替换原GSR数据`);
        neurokitProcessed = true;

      } catch (error) {
        progressDiv.style.display = 'none';
        progressDiv.textContent = '';
        alert('NeuroKit处理失败: ' + error.message);
        console.error('NeuroKit处理错误:', error);
      } finally {
        btn.disabled = false;
      }
    });
    
    // 异常检测事件监听器
    document.getElementById('runAnomalyDetectionBtn').addEventListener('click', async () => {
      const dataSource = document.getElementById('anomalyDataSource').value;
      const contamination = parseFloat(document.getElementById('contaminationRate').value) || 0.1;
      
      const statusEl = document.getElementById('anomalyDetectionStatus');
      const resultsEl = document.getElementById('anomalyDetectionResults');
      const runBtn = document.getElementById('runAnomalyDetectionBtn');
      const toggleBtn = document.getElementById('toggleAnomalyDisplay');
      
      try {
        runBtn.disabled = true;
        statusEl.textContent = '正在运行Isolation Forest检测...';
        statusEl.style.color = '#fbbf24';
        resultsEl.style.display = 'none';
        
        // 运行异常检测
        const results = await isolationForestDetector.runDetection(dataSource, contamination);
        
        // 显示结果
        const anomalyCount = results.anomalies.length;
        const anomalyPercentage = ((anomalyCount / results.totalPoints) * 100).toFixed(1);
        
        document.getElementById('anomalyCount').textContent = anomalyCount;
        document.getElementById('totalPoints').textContent = results.totalPoints;
        document.getElementById('anomalyPercentage').textContent = anomalyPercentage + '%';
        
        statusEl.textContent = `检测完成 - ${results.sourceInfo}`;
        statusEl.style.color = '#4caf50';
        resultsEl.style.display = 'block';
        toggleBtn.disabled = false;
        toggleBtn.textContent = '显示异常点';
        
        // 启用区间显示按钮
        document.getElementById('toggleIntervalDisplay').disabled = false;
        document.getElementById('recalculateIntervals').disabled = false;
        
        // 自动显示异常点
        isolationForestDetector.showAnomalies();
        toggleBtn.textContent = '隐藏异常点';
        
        // 🔍 新增：异常区间检测
        if (results.anomalies.length > 0) {
          console.log('🔍 开始异常区间检测...');
          
          // 从UI获取区间检测参数
          const intervalConfig = {
            maxGap: parseFloat(document.getElementById('maxGapParam').value) || 2.0,
            minDuration: parseFloat(document.getElementById('minDurationParam').value) || 1.0
          };
          
          console.log(`区间参数: 最大间隔=${intervalConfig.maxGap}s, 最小时长=${intervalConfig.minDuration}s`);
          
          // 检测异常区间
          const intervals = anomalyIntervalDetector.detectIntervals(results.anomalies, intervalConfig);
          
          // 应用前向偏移到异常区间
          const forwardOffset = parseFloat(document.getElementById('forwardOffsetParam').value) || 0.0;
          let displayIntervals = intervals;
          
          // 统一使用 startTime 和 endTime 属性
          if (forwardOffset > 0) {
            displayIntervals = intervals.map(interval => {
              const duration = interval.endTime - interval.startTime;
              const offset = duration * forwardOffset;
              const newStart = Math.max(0, interval.startTime - offset);
              const newEnd = Math.max(0, interval.endTime - offset);
              return {
                ...interval,
                startTime: newStart,
                endTime: newEnd,
                originalStart: interval.startTime,
                originalEnd: interval.endTime,
                offset: offset
              };
            });
            console.log(`⏪ 应用前向偏移 ${(forwardOffset * 100).toFixed(0)}%:`, displayIntervals);
          } else {
            // 不做偏移，直接使用原始数据
            displayIntervals = intervals;
          }
          
          // 显示异常区间
          if (displayIntervals.length > 0) {
            if (chart && typeof chart.showAnomalyIntervals === 'function') {
              // 添加详细的调试信息
              console.log(`🔍 显示区间详情 (偏移${(forwardOffset * 100).toFixed(0)}%):`, 
                displayIntervals.slice(0, 3).map(i => {
                  const hasOriginal = i.originalStart !== undefined && i.originalEnd !== undefined;
                  return {
                    original: hasOriginal ? `${i.originalStart.toFixed(1)}s-${i.originalEnd.toFixed(1)}s` : `无原始数据`,
                    display: `${i.startTime.toFixed(1)}s-${i.endTime.toFixed(1)}s`,
                    offset: i.offset ? i.offset.toFixed(1) + 's' : '无偏移'
                  };
                })
              );
              chart.showAnomalyIntervals(displayIntervals);
              console.log(`✨ 在图表上显示了 ${displayIntervals.length} 个异常区间`);
            } else {
              console.warn('图表不支持显示异常区间功能');
            }
            
            // 更新状态显示
            const offsetText = forwardOffset > 0 ? ` ⏪${(forwardOffset * 100).toFixed(0)}%偏移` : '';
            statusEl.textContent = `检测完成 - ${results.sourceInfo} (🔶${displayIntervals.length}个区间${offsetText})`;
            
            // 保存区间结果（保存原始区间和显示区间）
            results.intervals = intervals;
            results.displayIntervals = displayIntervals;
          } else {
            console.log('未检测到有效的异常区间');
          }
        }
        
        // 保存检测结果
        anomalyDetectionResults = results;
        
        console.log(`异常检测完成：${dataSource}数据，${anomalyCount}/${results.totalPoints}异常点 (${anomalyPercentage}%)`);
        
      } catch (error) {
        statusEl.textContent = '检测失败: ' + error.message;
        statusEl.style.color = '#ef4444';
        resultsEl.style.display = 'none';
        
        // 重置按钮状态
        document.getElementById('toggleIntervalDisplay').disabled = true;
        document.getElementById('toggleIntervalDisplay').textContent = '🔶 显示异常区间';
        document.getElementById('toggleIntervalDisplay').style.background = '#8b5cf6';
        document.getElementById('recalculateIntervals').disabled = true;
        
        console.error('异常检测错误:', error);
      } finally {
        runBtn.disabled = false;
      }
    });

    // 显示/隐藏异常点按钮
    document.getElementById('toggleAnomalyDisplay').addEventListener('click', () => {
      const btn = document.getElementById('toggleAnomalyDisplay');
      
      isolationForestDetector.toggleAnomalies();
      
      btn.textContent = showingAnomalies ? '隐藏异常点' : '显示异常点';
    });

    // 显示/隐藏异常区间按钮
    let showingIntervals = false;
    document.getElementById('toggleIntervalDisplay').addEventListener('click', () => {
      const btn = document.getElementById('toggleIntervalDisplay');
      
      if (!anomalyDetectionResults || !anomalyDetectionResults.intervals) {
        alert('请先运行异常检测并生成区间');
        return;
      }
      
      if (!chart || typeof chart.showAnomalyIntervals !== 'function') {
        alert('当前图表不支持异常区间显示');
        return;
      }
      
      showingIntervals = !showingIntervals;
      
      if (showingIntervals) {
        const intervalsToShow = anomalyDetectionResults.displayIntervals || anomalyDetectionResults.intervals;
        chart.showAnomalyIntervals(intervalsToShow);
        btn.textContent = '🔶 隐藏异常区间';
        btn.style.background = '#7c3aed';
        console.log(`🎨 显示 ${intervalsToShow.length} 个异常区间`);
      } else {
        chart.hideAnomalyIntervals();
        btn.textContent = '🔶 显示异常区间';
        btn.style.background = '#8b5cf6';
        console.log('🗑️ 隐藏异常区间');
      }
    });

    // 重新计算异常区间按钮
    document.getElementById('recalculateIntervals').addEventListener('click', () => {
      if (!anomalyDetectionResults || !anomalyDetectionResults.anomalies) {
        alert('请先运行异常检测');
        return;
      }

      const btn = document.getElementById('recalculateIntervals');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = '🔄 计算中...';
        
        // 从UI获取当前参数
        const intervalConfig = {
          maxGap: parseFloat(document.getElementById('maxGapParam').value) || 2.0,
          minDuration: parseFloat(document.getElementById('minDurationParam').value) || 1.0
        };
        
        console.log(`🔄 重新计算区间，参数: 最大间隔=${intervalConfig.maxGap}s, 最小时长=${intervalConfig.minDuration}s`);
        
        // 重新检测异常区间
        const intervals = anomalyIntervalDetector.detectIntervals(anomalyDetectionResults.anomalies, intervalConfig);
        
        // 应用前向偏移
        const forwardOffset = parseFloat(document.getElementById('forwardOffsetParam').value) || 0.0;
        let displayIntervals = intervals;
        
        if (forwardOffset > 0) {
          displayIntervals = intervals.map(interval => {
            const duration = interval.end - interval.start;
            const offset = duration * forwardOffset;
            const newStart = Math.max(0, interval.start - offset);
            const newEnd = Math.max(0, interval.end - offset);
            return {
              ...interval,
              start: newStart,
              end: newEnd,
              startTime: newStart,  // 图表需要的属性
              endTime: newEnd,      // 图表需要的属性
              originalStart: interval.start,
              originalEnd: interval.end,
              offset: offset
            };
          });
          console.log(`⏪ 重新计算时应用前向偏移 ${(forwardOffset * 100).toFixed(0)}%:`, displayIntervals);
        } else {
          // 即使没有偏移，也要确保有startTime和endTime属性
          displayIntervals = intervals.map(interval => ({
            ...interval,
            startTime: interval.start,
            endTime: interval.end
          }));
        }
        
        // 更新结果
        anomalyDetectionResults.intervals = intervals;
        anomalyDetectionResults.displayIntervals = displayIntervals;
        
        // 如果当前正在显示区间，则更新显示
        if (showingIntervals && chart && typeof chart.showAnomalyIntervals === 'function') {
          chart.hideAnomalyIntervals();
          chart.showAnomalyIntervals(displayIntervals);
        }
        
        // 更新状态
        const statusEl = document.getElementById('anomalyDetectionStatus');
        const offsetText = forwardOffset > 0 ? ` ⏪${(forwardOffset * 100).toFixed(0)}%偏移` : '';
        statusEl.textContent = `检测完成 - ${anomalyDetectionResults.sourceInfo} (🔶${displayIntervals.length}个区间${offsetText})`;
        
        console.log(`✅ 重新计算完成: ${intervals.length} 个异常区间`);
        
      } catch (error) {
        console.error('重新计算区间失败:', error);
        alert('重新计算失败: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });
    
    // 步骤1: 去伪迹
    document.getElementById('medianFilterBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行基础整理');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('medianWindow').value) || 5;
      const valenceValues = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalValues = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const filteredValence = medianFilter(valenceValues, windowSize);
      const filteredArousal = medianFilter(arousalValues, windowSize);
      
      // 处理GSR数据的去伪迹
      let gsrProcessedCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrValues = physiologicalData.gsr.map(item => item.gsr);
        const filteredGSR = medianFilter(gsrValues, windowSize);
        
        for (let i = 0; i < physiologicalData.gsr.length; i++) {
          physiologicalData.gsr[i].gsr = filteredGSR[i];
        }
        
        // 更新图表中的GSR数据
        chart.updateGSRData(physiologicalData.gsr);
        gsrProcessedCount = physiologicalData.gsr.length;
      }
      
      for (let i = 0; i < processedDataLog.length; i++) {
        if (processedDataLog[i].face) {
          processedDataLog[i].valence = filteredValence[i];
          processedDataLog[i].arousal = filteredArousal[i];
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      const message = gsrProcessedCount > 0 ? 
        `中值滤波完成，窗口=${windowSize}，处理VA和GSR数据(${gsrProcessedCount}点)` :
        `中值滤波完成，窗口=${windowSize}`;
      updateProcessingStatus('step1', true, message);
    });
    
    document.getElementById('outlierClipBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行基础整理');
        return;
      }
      
      // 异常值截断 (winsorize)
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite).sort((a,b) => a-b);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite).sort((a,b) => a-b);
      
      const vP1 = valenceVals[Math.floor(valenceVals.length * 0.01)];
      const vP99 = valenceVals[Math.floor(valenceVals.length * 0.99)];
      const aP1 = arousalVals[Math.floor(arousalVals.length * 0.01)];
      const aP99 = arousalVals[Math.floor(arousalVals.length * 0.99)];
      
      let clippedCount = 0;
      for (const record of processedDataLog) {
        if (record.face) {
          if (record.valence < vP1) { record.valence = vP1; clippedCount++; }
          if (record.valence > vP99) { record.valence = vP99; clippedCount++; }
          if (record.arousal < aP1) { record.arousal = aP1; clippedCount++; }
          if (record.arousal > aP99) { record.arousal = aP99; clippedCount++; }
        }
      }
      
      // 处理GSR数据的异常值截断
      let gsrClippedCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite).sort((a,b) => a-b);
        const gsrP1 = gsrVals[Math.floor(gsrVals.length * 0.01)];
        const gsrP99 = gsrVals[Math.floor(gsrVals.length * 0.99)];
        
        for (const item of physiologicalData.gsr) {
          if (item.gsr < gsrP1) { item.gsr = gsrP1; gsrClippedCount++; }
          if (item.gsr > gsrP99) { item.gsr = gsrP99; gsrClippedCount++; }
        }
        
        // 更新图表中的GSR数据
        chart.updateGSRData(physiologicalData.gsr);
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      const message = gsrClippedCount > 0 ? 
        `异常值截断完成，调整VA ${clippedCount}个值，GSR ${gsrClippedCount}个值` :
        `异常值截断完成，调整${clippedCount}个值`;
      updateProcessingStatus('step1', true, message);
    });
    
    // 步骤2: 标准化
    document.getElementById('zeroMeanBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行去伪迹处理');
        return;
      }
      
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite);
      
      const vMean = valenceVals.reduce((s,v) => s+v, 0) / valenceVals.length;
      const aMean = arousalVals.reduce((s,v) => s+v, 0) / arousalVals.length;
      
      // 处理GSR数据 - 从physiologicalData.gsr中获取
      let gsrMean = 0;
      let gsrCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrMean = gsrVals.length > 0 ? gsrVals.reduce((s,v) => s+v, 0) / gsrVals.length : 0;
        gsrCount = gsrVals.length;
        
        // 应用零均值化到GSR数据
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr -= gsrMean;
          }
        }
        
        // 更新图表中的GSR数据
        if (chart && chart.updateGSRData) {
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // 处理PPG数据 - 从physiologicalData.ppg中获取
      let ppgMean = 0;
      let ppgCount = 0;
      if (physiologicalData.ppg && physiologicalData.ppg.length > 0) {
        const ppgVals = physiologicalData.ppg.map(item => item.ppg).filter(Number.isFinite);
        ppgMean = ppgVals.length > 0 ? ppgVals.reduce((s,v) => s+v, 0) / ppgVals.length : 0;
        ppgCount = ppgVals.length;
        
        // 应用零均值化到PPG数据
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg -= ppgMean;
          }
        }
        
        // 更新图表中的PPG数据
        if (chart && chart.updatePPGData) {
          chart.updatePPGData(physiologicalData.ppg);
        }
      }
      
      console.log(`🔄 零均值化: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})个数据点`);
      
      // 处理VA数据
      for (const record of processedDataLog) {
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence -= vMean;
          record.arousal -= aMean;
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // 强制刷新GSR和PPG图表显示
      if (gsrCount > 0 && chart && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
        console.log(`🔄 已刷新GSR图表显示，${gsrCount}个数据点`);
      }
      
      if (ppgCount > 0 && chart && chart.updatePPGData) {
        chart.updatePPGData(physiologicalData.ppg);
        console.log(`🔄 已刷新PPG图表显示，${ppgCount}个数据点`);
      }
      
      const statusMsg = `零均值化完成 - V均值=${vMean.toFixed(3)}, A均值=${aMean.toFixed(3)}` +
        (gsrCount > 0 ? `, GSR均值=${gsrMean.toFixed(3)}` : '') +
        (ppgCount > 0 ? `, PPG均值=${ppgMean.toFixed(3)}` : '');
      
      console.log(`✅ ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });
    
    // 归零缩放 (零均值化 + 缩放到[-1,1])
    document.getElementById('zeroScaleBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行去伪迹处理');
        return;
      }
      
      const faceData = processedDataLog.filter(r => r.face);
      const valenceVals = faceData.map(r => r.valence).filter(Number.isFinite);
      const arousalVals = faceData.map(r => r.arousal).filter(Number.isFinite);
      
      // 1. 计算VA均值
      const vMean = valenceVals.reduce((s,v) => s+v, 0) / valenceVals.length;
      const aMean = arousalVals.reduce((s,v) => s+v, 0) / arousalVals.length;
      
      // 处理GSR数据 - 从physiologicalData.gsr中获取
      let gsrMean = 0;
      let gsrCount = 0;
      let gsrNormVals = [];
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrMean = gsrVals.length > 0 ? gsrVals.reduce((s,v) => s+v, 0) / gsrVals.length : 0;
        gsrCount = gsrVals.length;
        
        // 应用均值偏移到GSR数据
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr -= gsrMean;
            gsrNormVals.push(item.gsr);
          }
        }
      }
      
      // 处理PPG数据 - 从physiologicalData.ppg中获取
      let ppgMean = 0;
      let ppgCount = 0;
      let ppgNormVals = [];
      if (physiologicalData.ppg && physiologicalData.ppg.length > 0) {
        const ppgVals = physiologicalData.ppg.map(item => item.ppg).filter(Number.isFinite);
        ppgMean = ppgVals.length > 0 ? ppgVals.reduce((s,v) => s+v, 0) / ppgVals.length : 0;
        ppgCount = ppgVals.length;
        
        // 应用均值偏移到PPG数据
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg -= ppgMean;
            ppgNormVals.push(item.ppg);
          }
        }
      }
      
      console.log(`🔄 归零缩放: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})个数据点`);
      
      // 2. 应用均值偏移到VA数据
      let vVals = [];
      let aVals = [];
      
      for (const record of processedDataLog) {
        // 处理VA数据
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence -= vMean;
          record.arousal -= aMean;
          vVals.push(record.valence);
          aVals.push(record.arousal);
        }
      }
      
      // 3. 缩放到 [-1, 1] 范围
      const vMax = vVals.length > 0 ? Math.max(...vVals.map(Math.abs)) : 0;
      const aMax = aVals.length > 0 ? Math.max(...aVals.map(Math.abs)) : 0;
      const gsrMax = gsrNormVals.length > 0 ? Math.max(...gsrNormVals.map(Math.abs)) : 0;
      const ppgMax = ppgNormVals.length > 0 ? Math.max(...ppgNormVals.map(Math.abs)) : 0;
      
      // 缩放VA数据
      for (const record of processedDataLog) {
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          if (vMax > 0) record.valence /= vMax;
          if (aMax > 0) record.arousal /= aMax;
        }
      }
      
      // 缩放GSR数据
      if (physiologicalData.gsr && gsrMax > 0) {
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            item.gsr /= gsrMax;
          }
        }
        
        // 更新图表中的GSR数据
        if (chart && chart.updateGSRData) {
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // 缩放PPG数据
      if (physiologicalData.ppg && ppgMax > 0) {
        for (const item of physiologicalData.ppg) {
          if (Number.isFinite(item.ppg)) {
            item.ppg /= ppgMax;
          }
        }
        
        // 更新图表中的PPG数据
        if (chart && chart.updatePPGData) {
          chart.updatePPGData(physiologicalData.ppg);
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // 强制刷新GSR和PPG图表显示 - 已经在上面处理了，这里无需重复
      
      const statusMsg = `归零缩放完成 - VA: V均值=${vMean.toFixed(3)}, A均值=${aMean.toFixed(3)}` +
        (gsrCount > 0 ? `, GSR均值=${gsrMean.toFixed(3)}` : '') +
        (ppgCount > 0 ? `, PPG均值=${ppgMean.toFixed(3)}` : '');
      
      console.log(`✅ ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });
    
    document.getElementById('zScoreBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行去伪迹处理');
        return;
      }
      
      // 处理VA数据
      const valenceVals = processedDataLog.filter(r => r.face).map(r => r.valence).filter(Number.isFinite);
      const arousalVals = processedDataLog.filter(r => r.face).map(r => r.arousal).filter(Number.isFinite);
      
      console.log(`🔍 Valence原始数据样本: [${valenceVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      console.log(`🔍 Arousal原始数据样本: [${arousalVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      
      const vZScored = zscore(valenceVals);
      const aZScored = zscore(arousalVals);
      
      console.log(`🔍 Valence标准化样本: [${vZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      console.log(`🔍 Arousal标准化样本: [${aZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
      
      // 处理GSR数据 - 从physiologicalData.gsr中获取
      let gsrZScored = [];
      let gsrCount = 0;
      if (physiologicalData.gsr && physiologicalData.gsr.length > 0) {
        const gsrVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        gsrZScored = zscore(gsrVals);
        gsrCount = gsrVals.length;
        
        console.log(`🔍 GSR原始数据样本: [${gsrVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        console.log(`🔍 GSR标准化样本: [${gsrZScored.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        
        // 应用Z-score到GSR数据
        let gsrIdx = 0;
        for (const item of physiologicalData.gsr) {
          if (Number.isFinite(item.gsr)) {
            const originalValue = item.gsr;
            item.gsr = gsrZScored[gsrIdx++];
            
            // 调试前几个数据点的变化
            if (gsrIdx <= 3) {
              console.log(`🔍 GSR数据点${gsrIdx}: ${originalValue.toFixed(3)} -> ${item.gsr.toFixed(3)}`);
            }
          }
        }
        
        // 验证数据是否真的被修改了
        const afterVals = physiologicalData.gsr.map(item => item.gsr).filter(Number.isFinite);
        console.log(`🔍 GSR修改后样本: [${afterVals.slice(0, 5).map(v => v.toFixed(3)).join(', ')}]`);
        console.log(`🔍 GSR修改后统计: 均值=${(afterVals.reduce((s,v)=>s+v,0)/afterVals.length).toFixed(3)}, 标准差=${Math.sqrt(afterVals.reduce((s,v)=>s+Math.pow(v-afterVals.reduce((a,b)=>a+b,0)/afterVals.length,2),0)/afterVals.length).toFixed(3)}`);
        
        // 更新图表中的GSR数据
        if (chart && chart.updateGSRData) {
          console.log(`🔄 调用 chart.updateGSRData() 更新图表`);
          chart.updateGSRData(physiologicalData.gsr);
        }
      }
      
      // PPG数据不需要处理
      let ppgCount = 0;
      
      console.log(`🔄 Z-Score标准化: VA(${valenceVals.length}), GSR(${gsrCount}), PPG(${ppgCount})个数据点`);
      
      // 应用VA数据标准化结果
      let vIdx = 0, aIdx = 0;
      for (const record of processedDataLog) {
        // 标准化VA数据
        if (record.face && Number.isFinite(record.valence) && Number.isFinite(record.arousal)) {
          record.valence = vZScored[vIdx++];
          record.arousal = aZScored[aIdx++];
        }
      }
      
      dataLog = processedDataLog.map(r => ({ ...r }));
      loadAllDataToChart();
      
      // 强制刷新GSR和PPG图表显示
      if (gsrCount > 0 && chart && chart.updateGSRData) {
        chart.updateGSRData(physiologicalData.gsr);
        console.log(`🔄 已刷新GSR图表显示，${gsrCount}个数据点`);
      }
      
      // 更新主Y轴范围以适应标准化后的VA数据
      if (chart && chart.updateMainAxisRange) {
        console.log(`🔄 调用 chart.updateMainAxisRange() 更新主Y轴`);
        chart.updateMainAxisRange(processedDataLog, processedDataLog);
      }
      
      // PPG数据不需要处理，跳过
      
      const statusMsg = `Z-Score标准化完成 (VA: ${valenceVals.length}, GSR: ${gsrCount}个数据点)`;
      console.log(`✅ ${statusMsg}`);
      updateProcessingStatus('step2', true, statusMsg);
    });

    // 创建时间对齐处理器实例
    const timeAlignmentProcessor = new TimeAlignmentProcessor();

    // 时间对齐按钮点击事件
    document.getElementById('alignDataBtn').addEventListener('click', async () => {
      // 检查数据可用性
      if (processedDataLog.length === 0) {
        alert('请先进行前置数据处理（如重采样、滤波等）');
        return;
      }
      
      if (!physiologicalData.gsr || physiologicalData.gsr.length === 0) {
        alert('请先导入GSR数据');
        return;
      }
      
      const btn = document.getElementById('alignDataBtn');
      const statusEl = document.getElementById('step2Status');
      const originalText = btn.textContent;
      
      try {
        btn.disabled = true;
        btn.textContent = '对齐中...';
        statusEl.textContent = '正在进行时间对齐...';
        statusEl.style.color = '#fbbf24';
        
        // 获取用户配置
        const config = {
          maxLagSeconds: parseFloat(document.getElementById('maxLagSeconds').value) || 5.0
        };
        
        // 准备数据 - 使用经过处理的数据
        const valenceData = processedDataLog.filter(r => r.face && isFinite(r.valence));
        const gsrData = physiologicalData.gsr.filter(item => isFinite(item.gsr));
        
        console.log(`🚀 开始互相关时间对齐`);
        console.log(`📊 输入数据: Valence ${valenceData.length}点, GSR ${gsrData.length}点`);
        console.log(`📊 数据来源: 使用经过处理的数据 (processedDataLog + physiologicalData.gsr)`);
        
        // 执行对齐
        const alignmentResult = await timeAlignmentProcessor.alignData(valenceData, gsrData, config);
        
        // 更新处理后的数据
        processedDataLog = alignmentResult.alignedValence;
        dataLog = processedDataLog.map(r => ({ ...r }));
        physiologicalData.gsr = alignmentResult.alignedGSR;
        
        // 更新图表
        loadAllDataToChart();
        
        // 显示结果
        const report = timeAlignmentProcessor.generateAlignmentReport();
        console.log(report);
        
        const summaryMsg = `互相关时间对齐完成 | 偏移: ${alignmentResult.lagSeconds.toFixed(2)}s | 置信度: ${alignmentResult.confidence.toFixed(3)}`;
        statusEl.textContent = summaryMsg;
        statusEl.style.color = '#4caf50';
        
        updateProcessingStatus('step2', true, summaryMsg);
        
        console.log('✅ 时间对齐完成，已更新 processedDataLog 和 physiologicalData.gsr');
        
      } catch (error) {
        console.error('时间对齐失败:', error);
        statusEl.textContent = '对齐失败: ' + error.message;
        statusEl.style.color = '#ef4444';
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });



    // 显示详细分析按钮
    document.getElementById('showAlignmentDetails').addEventListener('click', () => {
      const report = timeAlignmentProcessor.generateAlignmentReport();
      if (report === '没有对齐结果') {
        alert('请先执行时间对齐');
      } else {
        console.log('📊 详细对齐分析报告:');
        console.log(report);
        alert('详细报告已输出到控制台，请按F12查看');
      }
    });
    
    // 步骤3: 导数计算
    document.getElementById('sgDerivativeBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行标准化处理');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('sgWindow').value) || 15;
      const timeArray = processedDataLog.map(r => r.time);
      const valenceArray = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalArray = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const vDerivative = sgDerivative(timeArray, valenceArray, windowSize);
      const aDerivative = sgDerivative(timeArray, arousalArray, windowSize);
      
      derivativeDataLog = processedDataLog.map((r, i) => ({
        time: r.time,
        valence_dt: vDerivative[i],
        arousal_dt: aDerivative[i],
        face: r.face
      }));
      
      // 立即显示导数曲线
      chart.updateDerivativeData(derivativeDataLog);
      chart.toggleDerivativeDisplay(true);
      showDerivative = true;
      document.getElementById('showDerivativeBtn').textContent = '隐藏导数曲线';
      
      updateProcessingStatus('step3', true, `SG导数计算完成，窗口=${windowSize}`);
    });
    
    document.getElementById('slopeDerivativeBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('请先进行标准化处理');
        return;
      }
      
      const windowSize = parseInt(document.getElementById('slopeWindow').value) || 9;
      const timeArray = processedDataLog.map(r => r.time);
      const valenceArray = processedDataLog.map(r => r.face ? r.valence : NaN);
      const arousalArray = processedDataLog.map(r => r.face ? r.arousal : NaN);
      
      const vDerivative = slopeByWindow(timeArray, valenceArray, windowSize);
      const aDerivative = slopeByWindow(timeArray, arousalArray, windowSize);
      
      derivativeDataLog = processedDataLog.map((r, i) => ({
        time: r.time,
        valence_dt: vDerivative[i],
        arousal_dt: aDerivative[i],
        face: r.face
      }));
      
      // 立即显示导数曲线
      chart.updateDerivativeData(derivativeDataLog);
      chart.toggleDerivativeDisplay(true);
      showDerivative = true;
      document.getElementById('showDerivativeBtn').textContent = '隐藏导数曲线';
      
      updateProcessingStatus('step3', true, `鲁棒斜率计算完成，窗口=${windowSize}`);
    });
    
    // 步骤4: 导数后处理
    document.getElementById('smoothDerivativeBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('请先计算导数');
        return;
      }
      
      const vDerivativeSmoothed = movingAverage(derivativeDataLog.map(r => r.valence_dt), 3);
      const aDerivativeSmoothed = movingAverage(derivativeDataLog.map(r => r.arousal_dt), 3);
      
      for (let i = 0; i < derivativeDataLog.length; i++) {
        derivativeDataLog[i].valence_dt = vDerivativeSmoothed[i];
        derivativeDataLog[i].arousal_dt = aDerivativeSmoothed[i];
      }
      
      // 更新导数显示
      chart.updateDerivativeData(derivativeDataLog);
      
      updateProcessingStatus('step4', true, '导数平滑完成(3点移动平均)');
    });
    
    document.getElementById('normalizeDerivativeBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('请先计算导数');
        return;
      }
      
      const vDtVals = derivativeDataLog.filter(r => r.face).map(r => r.valence_dt).filter(Number.isFinite);
      const aDtVals = derivativeDataLog.filter(r => r.face).map(r => r.arousal_dt).filter(Number.isFinite);
      
      const vDtNormalized = zscore(vDtVals);
      const aDtNormalized = zscore(aDtVals);
      
      let vIdx = 0, aIdx = 0;
      for (const record of derivativeDataLog) {
        if (record.face && Number.isFinite(record.valence_dt) && Number.isFinite(record.arousal_dt)) {
          record.valence_dt = vDtNormalized[vIdx++];
          record.arousal_dt = aDtNormalized[aIdx++];
        }
      }
      
      // 更新导数显示
      chart.updateDerivativeData(derivativeDataLog);
      
      updateProcessingStatus('step4', true, '导数标准化完成');
    });
    
    // 步骤5: 事件检测
    document.getElementById('detectEventsBtn').addEventListener('click', () => {
      if (derivativeDataLog.length === 0) {
        alert('请先计算导数');
        return;
      }
      
      // 从用户输入获取阈值
      const upThreshold = parseFloat(document.getElementById('upThreshold').value) || 0.12;
      const downThreshold = parseFloat(document.getElementById('downThreshold').value) || -0.12;
      const minDuration = parseFloat(document.getElementById('minDuration').value) || 0.8;
      
      // 验证阈值的合理性
      if (upThreshold <= 0) {
        alert('上升阈值必须大于0');
        return;
      }
      if (downThreshold >= 0) {
        alert('下降阈值必须小于0');
        return;
      }
      if (upThreshold <= Math.abs(downThreshold)) {
        if (!confirm(`当前设置：上升阈值=${upThreshold}, 下降阈值=${downThreshold}\n\n建议上升阈值的绝对值大于下降阈值的绝对值，以更好地捕捉情绪变化特性。\n\n是否继续使用当前设置？`)) {
          return;
        }
      }
      
      const timeArray = derivativeDataLog.map(r => r.time);
      const vDtArray = derivativeDataLog.map(r => r.valence_dt);
      const aDtArray = derivativeDataLog.map(r => r.arousal_dt);
      
      const vEvents = detectEvents(timeArray, vDtArray, upThreshold, downThreshold, minDuration);
      const aEvents = detectEvents(timeArray, aDtArray, upThreshold, downThreshold, minDuration);
      
      eventsLog = [
        ...vEvents.map(e => ({ ...e, type: `valence_${e.type}` })),
        //todo 暂时只基于v试试
        // ...aEvents.map(e => ({ ...e, type: `arousal_${e.type}` }))
      ].sort((a, b) => a.t - b.t);
      
      // 立即显示事件标记
      chart.updateEventData(eventsLog, processedDataLog);
      chart.toggleEventDisplay(true);
      showEvents = true;
      document.getElementById('showEventsBtn').style.display = 'inline-block';
      document.getElementById('showEventsBtn').textContent = '隐藏事件标记';
      
      updateProcessingStatus('step5', true, `事件检测完成：${eventsLog.length}个事件 (上升>${upThreshold}, 下降<${downThreshold}, 持续>${minDuration}s)`);
      console.log('检测到的事件:', eventsLog);
      console.log(`使用阈值: 上升=${upThreshold}, 下降=${downThreshold}, 最小持续=${minDuration}s`);
    });

    // 控制按钮
    document.getElementById('resetProcessingBtn').addEventListener('click', () => {
      processedDataLog = originalDataLog.map(r => ({ ...r }));
      dataLog = processedDataLog.map(r => ({ ...r }));
      derivativeDataLog = [];
      eventsLog = [];
      
      // 重置NeuroKit和异常检测状态
      neurokitProcessed = false;
      anomalyDetected = false;
      cleanedGSRDataPanel = null;
      anomalyResultsPanel = null;
      
      // 清除异常检测结果
      anomalyDetectionResults = null;
      showingAnomalies = false;
      showingIntervals = false;
      if (isolationForestDetector) {
        isolationForestDetector.results = null;
        isolationForestDetector.hideAnomalies();
      }
      
      // 清除图表上的ML异常点和异常区间
      if (chart) {
        chart.hideMLAnomalies();
        if (typeof chart.hideAnomalyIntervals === 'function') {
          chart.hideAnomalyIntervals();
        }
      }
      
      // 重置异常检测UI
      document.getElementById('anomalyDetectionStatus').textContent = '未运行检测';
      document.getElementById('anomalyDetectionStatus').style.color = '#888';
      document.getElementById('anomalyDetectionResults').style.display = 'none';
      document.getElementById('toggleAnomalyDisplay').disabled = true;
      document.getElementById('toggleAnomalyDisplay').textContent = '显示异常点';
      document.getElementById('toggleIntervalDisplay').disabled = true;
      document.getElementById('toggleIntervalDisplay').textContent = '🔶 显示异常区间';
      document.getElementById('toggleIntervalDisplay').style.background = '#8b5cf6';
      document.getElementById('recalculateIntervals').disabled = true;
      
      // 隐藏导数曲线
      chart.toggleDerivativeDisplay(false);
      showDerivative = false;
      document.getElementById('showDerivativeBtn').textContent = '显示导数曲线';
      
      // 隐藏事件标记
      chart.toggleEventDisplay(false);
      showEvents = false;
      document.getElementById('showEventsBtn').style.display = 'none';
      document.getElementById('showEventsBtn').textContent = '显示事件标记';
      
      // 清除异常点和清理后数据
      chart.clearAnomalies();
      clearCleanedData();
      
      Object.keys(processingSteps).forEach(step => {
        updateProcessingStatus(step, false);
      });
      
      loadAllDataToChart();
      updateProcessingStatus('step0', false, '处理已重置，可重新开始');
    });
    
    document.getElementById('showDerivativeBtn').addEventListener('click', () => {
      showDerivative = !showDerivative;
      
      if (derivativeDataLog.length > 0) {
        chart.toggleDerivativeDisplay(showDerivative);
        
        const derivativeValenceData = derivativeDataLog
          .filter(r => r.face && Number.isFinite(r.valence_dt))
          .map(r => ({ x: r.time, y: r.valence_dt }));
        const derivativeArousalData = derivativeDataLog
          .filter(r => r.face && Number.isFinite(r.arousal_dt))
          .map(r => ({ x: r.time, y: r.arousal_dt }));
        
        console.log(`导数显示${showDerivative ? '开启' : '关闭'}：V导数${derivativeValenceData.length}点，A导数${derivativeArousalData.length}点`);
      } else {
        alert('请先计算导数数据');
        showDerivative = false;
      }
      
      document.getElementById('showDerivativeBtn').textContent = 
        showDerivative ? '隐藏导数曲线' : '显示导数曲线';
    });
    
    // 事件显示控制
    document.getElementById('showEventsBtn').addEventListener('click', () => {
      showEvents = !showEvents;
      
      if (eventsLog.length > 0) {
        chart.toggleEventDisplay(showEvents);
        console.log(`事件标记${showEvents ? '显示' : '隐藏'}：共${eventsLog.length}个事件`);
      } else {
        alert('请先检测事件');
        showEvents = false;
      }
      
      document.getElementById('showEventsBtn').textContent = 
        showEvents ? '隐藏事件标记' : '显示事件标记';
    });
    
    document.getElementById('exportProcessedBtn').addEventListener('click', () => {
      if (processedDataLog.length === 0) {
        alert('没有处理后的数据可导出');
        return;
      }
      
      // 构建包含导数和事件的CSV
      let header = ['time', 'valence', 'arousal', 'face'];
      if (derivativeDataLog.length > 0) {
        header.push('valence_dt', 'arousal_dt');
      }
      
      const rows = processedDataLog.map((r, i) => {
        let row = [
          r.time.toFixed(3),
          Number.isFinite(r.valence) ? r.valence.toFixed(4) : '',
          Number.isFinite(r.arousal) ? r.arousal.toFixed(4) : '',
          r.face ? '1' : '0'
        ];
        
        if (derivativeDataLog.length > 0 && derivativeDataLog[i]) {
          row.push(
            Number.isFinite(derivativeDataLog[i].valence_dt) ? derivativeDataLog[i].valence_dt.toFixed(4) : '',
            Number.isFinite(derivativeDataLog[i].arousal_dt) ? derivativeDataLog[i].arousal_dt.toFixed(4) : ''
          );
        }
        
        return row.join(',');
      });
      
      rows.unshift(header.join(','));
      
      // 添加事件信息作为注释
      if (eventsLog.length > 0) {
        rows.push('');
        rows.push('# Events:');
        eventsLog.forEach(event => {
          rows.push(`# ${event.type},${event.t.toFixed(3)},${event.dur.toFixed(3)}`);
        });
      }
      
      const csvContent = rows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = 'processed_va_data.csv';
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    });

  </script>

</body>
</html>
